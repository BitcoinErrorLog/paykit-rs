# BIP ???: Paykit - Universal Payment Protocol Substrate

```
  BIP: ???
  Layer: Application
  Title: Paykit - Universal Payment Protocol Substrate
  Author: John Carvalho
  Comments-Summary: No comments yet.
  Status: Draft
  Type: Standards Track
  Created: 2025-01-XX
  License: MIT
  Post-History: [To be added]
```

## Abstract

Paykit is a universal payment protocol substrate that abstracts payment method discovery, negotiation, and coordination across incompatible payment protocols. It provides a unified interface for payments, subscriptions, receipts, and payment requests, enabling applications to support any payment method through a single protocol layer. Paykit leverages the Pubky decentralized identity and storage infrastructure for discovery and uses the Noise Protocol Framework for encrypted peer-to-peer communication.

## Copyright

This BIP is licensed under the MIT License.

## Motivation

The Bitcoin and cryptocurrency ecosystem has fragmented into numerous incompatible payment protocols and methods:

* **On-chain Bitcoin**: Native Bitcoin transactions with various address formats
* **Lightning Network**: BOLT11 invoices, LNURL, and other Lightning protocols
* **Other blockchains**: Ethereum, Solana, and countless altcoins
* **Traditional payment methods**: Bank transfers, credit cards, payment apps
* **Emerging protocols**: New payment methods continuously being developed

Each payment method requires:
* Unique discovery mechanisms
* Different negotiation protocols
* Incompatible receipt formats
* Custom integration code
* Protocol-specific error handling

This fragmentation creates significant barriers:
* Applications must implement support for each payment method individually
* Users must manage multiple payment interfaces
* Payment method changes require application updates
* New payment methods cannot be adopted without code changes
* Cross-method features (subscriptions, auto-pay) are difficult to implement

Paykit solves this by providing a **universal payment protocol substrate** that:
* Abstracts payment method discovery through a unified directory protocol
* Provides a common interface for payment negotiation and coordination
* Standardizes receipt exchange and payment proofs
* Enables cross-method features (subscriptions, auto-pay, spending limits)
* Supports extensible plugin architecture for new payment methods
* Works with any underlying payment protocol through method-specific plugins

Paykit is designed to be the **ubiquitous payment interface** that everyone uses, leaving payment method details to local protocol implementations underneath.

## Specification

### Overview

Paykit consists of three main protocol layers:

1. **Directory Protocol**: Public payment method discovery via Pubky homeservers
2. **Interactive Protocol**: Encrypted peer-to-peer payment negotiation via Noise Protocol
3. **Subscription Protocol**: Recurring payments, auto-pay, and spending limits

All three layers work together to provide a complete payment substrate that abstracts underlying payment methods.

### Assumptions and Dependencies

Paykit assumes the following infrastructure:

* **Pubky Protocol**: Decentralized identity and storage system
  * Public keys (Ed25519) for identity
  * Pubky homeservers for public data storage
  * PKARR for endpoint discovery and metadata
* **Noise Protocol Framework**: For encrypted peer-to-peer communication
  * Noise_IK handshake pattern for authenticated key exchange
  * ChaCha20-Poly1305 for encryption
  * X25519 for key exchange
* **Transport Layer**: Underlying network transport (TCP, WebSocket, etc.)

### Core Concepts

#### PublicKey

A Paykit participant is identified by their Ed25519 public key, typically represented as a Pubky URI (`pubky://<base58-encoded-public-key>`). This public key serves as:
* Payment recipient identifier
* Directory lookup key
* Authentication credential (via Ed25519 signatures)
* Noise protocol identity binding

#### MethodId

A `MethodId` is a string identifier for a payment method. Examples:
* `"onchain"` - Bitcoin on-chain addresses
* `"lightning"` - Lightning Network (BOLT11)
* `"lnurl"` - LNURL payment protocol
* `"ethereum"` - Ethereum transactions
* `"cashapp"` - Cash App payments
* `"paypal"` - PayPal payments
* `"bank-sepa"` - SEPA bank transfers

The format is intentionally flexible to allow any payment method identifier. Method IDs are case-sensitive and should follow a consistent naming convention (lowercase with hyphens recommended).

#### EndpointData

`EndpointData` is an opaque string payload that encodes whatever the payment method requires:
* **On-chain**: Bitcoin address (e.g., `"bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh"`)
* **Lightning**: BOLT11 invoice or LNURL (e.g., `"lnurl1dp68gurn8ghj7um9wfmxjcm99e3k7mf0v9cxj0m385ekvcenxc6r2c35xvukxefcv5mkvv34x5ekzd3ev56nyd3hxqyf3ex"`)
* **Private endpoints**: Noise protocol connection string (e.g., `"noise://host:port@server_static_key_hex"`)

The format is method-specific and opaque to Paykit. Paykit only stores and retrieves endpoint data; it does not interpret or validate the format.

#### SupportedPayments

A collection of payment methods supported by a payee, represented as a map from `MethodId` to `EndpointData`. This allows payees to publish multiple payment methods simultaneously.

### Directory Protocol

The Directory Protocol enables public discovery of payment methods via Pubky homeservers.

#### Storage Path

Payment endpoints are stored under the Pubky path:
```
/pub/paykit.app/v0/{method_id}
```

Where `{method_id}` is the payment method identifier (e.g., `"onchain"`, `"lightning"`).

The path prefix `/pub/paykit.app/v0/` is standardized to ensure interoperability.

#### Publishing Payment Methods

To publish a payment method, the payee:

1. Authenticates with their Pubky homeserver using their Ed25519 keypair
2. Writes the endpoint data to `/pub/paykit.app/v0/{method_id}`
3. Optionally removes old endpoints by deleting the file

The endpoint data is stored as UTF-8 text. Binary data should be base64-encoded.

#### Discovering Payment Methods

To discover a payee's payment methods, the payer:

1. Resolves the payee's Pubky URI to their public key
2. Queries the Pubky homeserver for files under `/pub/paykit.app/v0/`
3. Reads each endpoint file to get the `EndpointData` for each method

The discovery process returns a `SupportedPayments` map containing all published methods.

#### Endpoint Rotation

Payees may rotate payment endpoints for privacy or security:
* **On-chain addresses**: Rotate after use to prevent address reuse
* **Lightning invoices**: Generate new invoices for each payment
* **Private endpoints**: Update Noise protocol connection strings

Paykit supports endpoint rotation by:
* Allowing payees to update endpoint data at any time
* Payers always fetching the latest endpoint data before payment
* Supporting automatic rotation detection and updates
* Providing a public onchain address that is always available and rotated when usage is detected

#### Private Endpoints

In addition to public endpoints, Paykit supports **private endpoints** shared over encrypted channels:
* Private endpoints are not published to the public directory
* They are exchanged via the Interactive Protocol (see below)
* They enable per-peer dedicated payment addresses or channels
* They provide enhanced privacy by avoiding public address reuse
* Private endpoints can be provided for specific key-peers, containing dedicated addresses for them

### Interactive Protocol

The Interactive Protocol enables encrypted peer-to-peer payment negotiation and receipt exchange.

#### Noise Protocol Integration

Paykit uses the Noise Protocol Framework for encrypted communication:
* **Pattern**: Noise_IK (1-RTT handshake, 2-RTT total with response)
* **Cipher Suite**: `Noise_IK_25519_ChaChaPoly_BLAKE2s`
* **Key Exchange**: X25519
* **Encryption**: ChaCha20-Poly1305
* **Hash**: BLAKE2s

The Noise handshake provides:
* Mutual authentication via Ed25519 identity binding
* Forward secrecy through ephemeral key exchange
* Protection against man-in-the-middle attacks
* Encrypted message transport

#### Message Format

Messages are JSON-encoded and sent over the encrypted Noise channel with length-prefixed framing:

```
[4-byte length (big-endian)][JSON-encoded message]
```

The message format is defined by the `PaykitNoiseMessage` enum:

```json
{
  "type": "RequestReceipt",
  "payload": {
    "provisional_receipt": {
      "receipt_id": "receipt_001",
      "payer": "pubky://...",
      "payee": "pubky://...",
      "method_id": "lightning",
      "amount": "1000",
      "currency": "SAT",
      "created_at": 1234567890,
      "metadata": {}
    }
  }
}
```

Message types:
* `OfferPrivateEndpoint` - Share a private payment endpoint
* `RequestReceipt` - Request a receipt for a payment
* `ConfirmReceipt` - Confirm and finalize a receipt
* `Ack` - Acknowledge message receipt
* `Error` - Error reporting

#### Payment Flow

The interactive payment flow consists of three steps:

**Step 1: Establish Encrypted Channel**
* Payer initiates Noise_IK handshake with payee's public key
* Both parties authenticate using Ed25519 identity binding
* Encrypted channel established

**Step 2: Request Receipt**
* Payer sends `RequestReceipt` message with provisional receipt
* Provisional receipt includes: payer, payee, method, amount, currency, metadata
* Payee validates request and generates payment endpoint (e.g., BOLT11 invoice)

**Step 3: Confirm Receipt**
* Payee sends `ConfirmReceipt` message with finalized receipt
* Finalized receipt includes payment endpoint in metadata
* Both parties save receipt for record-keeping
* Payer executes payment using the endpoint (off-protocol)

#### Receipt Format

A `PaykitReceipt` is a cryptographic receipt shared between payer and payee:

```json
{
  "receipt_id": "receipt_001",
  "payer": "pubky://...",
  "payee": "pubky://...",
  "method_id": "lightning",
  "amount": "1000",
  "currency": "SAT",
  "created_at": 1234567890,
  "metadata": {
    "bolt11": "lnbc10u1p3...",
    "preimage": "abc123...",
    "order_id": "ABC123"
  }
}
```

The receipt serves as:
* Proof of payment coordination
* Transaction record for both parties
* Basis for dispute resolution
* Foundation for subscription management

Receipt metadata is method-specific and may include:
* Payment endpoint (invoice, address, etc.)
* Payment proof (transaction ID, preimage, etc.)
* Order information
* Shipping details
* Custom application data

### Subscription Protocol

The Subscription Protocol enables recurring payments, payment requests, and automated payment rules.

#### Subscription Agreement

A subscription is a bilateral agreement between a subscriber and provider:

```json
{
  "subscription_id": "sub_1234567890",
  "subscriber": "pubky://...",
  "provider": "pubky://...",
  "terms": {
    "amount": "1000",
    "currency": "SAT",
    "frequency": "monthly:1",
    "method": "lightning",
    "description": "Monthly service subscription"
  },
  "metadata": {},
  "created_at": 1234567890,
  "starts_at": 1234567890,
  "ends_at": null
}
```

Subscription terms include:
* **Amount**: Payment amount per period
* **Currency**: Currency code (e.g., "SAT", "USD")
* **Frequency**: Payment frequency (daily, weekly, monthly, yearly, custom)
* **Method**: Preferred payment method
* **Description**: Human-readable description

#### Payment Frequency

Payment frequencies are specified as strings:
* `"daily"` - Daily payments
* `"weekly"` - Weekly payments (every 7 days)
* `"monthly:1"` - Monthly on the 1st of each month
* `"monthly:15"` - Monthly on the 15th of each month
* `"yearly:01-01"` - Yearly on January 1st
* `"custom:86400"` - Custom interval in seconds

#### Cryptographic Signatures

Subscriptions are cryptographically signed using Ed25519:

1. Serialize subscription to canonical JSON
2. Create signing message: `SHA-256("PAYKIT_SUBSCRIPTION_V2" || subscription_json || nonce || timestamp || expiration)`
3. Sign with subscriber's Ed25519 private key
4. Include signature, nonce, timestamp, and expiration in subscription record

Signature verification:
* Verify Ed25519 signature
* Check nonce hasn't been used (replay protection)
* Validate timestamp is within acceptable range
* Check expiration hasn't passed

#### Payment Requests

Payment requests are asynchronous payment solicitations:

```json
{
  "request_id": "req_1234567890",
  "from": "pubky://...",
  "to": "pubky://...",
  "amount": "1000",
  "currency": "SAT",
  "method": "lightning",
  "description": "Monthly subscription payment",
  "due_date": 1234567890,
  "metadata": {},
  "created_at": 1234567890,
  "expires_at": 1234567890
}
```

Payment requests can be:
* Created by providers to request payment from subscribers
* Stored in Pubky directory for async discovery
* Responded to by subscribers (accept, decline, or propose subscription)

#### Auto-Pay Rules

Auto-pay rules enable automated payment approval:

```json
{
  "rule_id": "rule_1234567890",
  "subscription_id": "sub_1234567890",
  "peer": "pubky://...",
  "method": "lightning",
  "max_amount": "5000",
  "currency": "SAT",
  "enabled": true,
  "require_confirmation": false
}
```

Auto-pay rules:
* Automatically approve payments up to `max_amount`
* Can require manual confirmation before each payment
* Can be enabled/disabled dynamically
* Respect spending limits (see below)

#### Spending Limits

Spending limits (allowances) restrict total spending per peer over a time period:

```json
{
  "peer": "pubky://...",
  "max_amount": "10000",
  "currency": "SAT",
  "period": "monthly",
  "current_spending": "5000",
  "period_start": 1234567890,
  "period_end": 1237894560
}
```

Spending limits:
* Track spending per peer over configurable periods (daily, weekly, monthly)
* Automatically reset at period boundaries
* Prevent exceeding configured limits
* Apply to all payment methods for a peer

### Payment Method Abstraction

Paykit abstracts payment methods through a plugin architecture:

#### Method Plugin Interface

A payment method plugin must provide:
* **Method ID**: Unique identifier (e.g., `"onchain"`, `"lightning"`)
* **Endpoint Format**: Specification for `EndpointData` format
* **Payment Execution**: How to execute payment using endpoint
* **Payment Proof**: How to generate/verify payment proof
* **Receipt Metadata**: What metadata to include in receipts

#### Built-in Methods

Paykit provides built-in support for:

**On-chain Bitcoin** (`"onchain"`):
* Endpoint: Bitcoin address (any format: legacy, segwit, bech32)
* Execution: Create Bitcoin transaction to address
* Proof: Transaction ID (txid)
* Rotation: Generate new address after use
* Always available as public endpoint, rotated when usage detected

**Lightning Network** (`"lightning"`):
* Endpoint: BOLT11 invoice (BOLT12 not supported due to conflicting subscription scheme)
* Execution: Pay Lightning invoice
* Proof: Payment preimage
* Rotation: Generate new invoice for each payment

#### Custom Methods

Applications can add custom payment methods by:
1. Defining a `MethodId` (e.g., `"ethereum"`, `"cashapp"`)
2. Implementing payment execution logic
3. Publishing endpoint data in Paykit directory
4. Handling payment proofs appropriately

Custom methods integrate seamlessly with Paykit's directory, interactive, and subscription protocols. Any chain or payment protocol can create a plugin and apply Paykit (and thus PKARR keys) as the overarching payment interface to customers.

### Payment Request Standardization

Paykit provides a standardized payment request format that abstracts invoice generation across payment methods:

#### Payment Request Format

```json
{
  "request_id": "req_1234567890",
  "from": "pubky://...",
  "to": "pubky://...",
  "amount": "1000",
  "currency": "SAT",
  "method": "lightning",
  "description": "Payment for services",
  "due_date": 1234567890,
  "expires_at": 1234567890,
  "metadata": {
    "invoice_number": "INV-001",
    "items": [],
    "tax": "0",
    "shipping": "0"
  },
  "created_at": 1234567890
}
```

#### Invoice Generation

Payment requests enable standardized invoice generation:
* Unified format across all payment methods
* Method-specific invoice details in metadata
* Payment due dates and expiration
* Structured item lists and tax information

### Payment Status Tracking

Paykit provides unified payment status tracking across all payment methods:

#### Payment Status

```json
{
  "receipt_id": "receipt_001",
  "status": "pending",
  "method": "lightning",
  "amount": "1000",
  "currency": "SAT",
  "created_at": 1234567890,
  "updated_at": 1234567890,
  "confirmed_at": null
}
```

Status values:
* `"pending"` - Payment initiated, awaiting confirmation
* `"confirmed"` - Payment confirmed on network
* `"failed"` - Payment failed
* `"expired"` - Payment request expired

### Payment Routing Hints

Paykit supports payment routing hints for complex payment scenarios:

#### Routing Information

```json
{
  "method": "lightning",
  "routing_hints": [
    {
      "method": "lightning",
      "endpoint": "lnurl1...",
      "priority": 1
    },
    {
      "method": "onchain",
      "endpoint": "bc1q...",
      "priority": 2
    }
  ],
  "fallback_chain": ["lightning", "onchain"]
}
```

Routing hints enable:
* Automatic payment method selection
* Fallback payment chains
* Payment method negotiation
* Complex payment scenarios

### Payment Proof Standardization

Paykit provides a unified proof format for all payment methods:

#### Payment Proof Format

```json
{
  "receipt_id": "receipt_001",
  "method": "lightning",
  "proof": {
    "type": "lightning_preimage",
    "preimage": "abc123...",
    "payment_hash": "def456..."
  }
}
```

Proof types:
* **On-chain**: `{"type": "bitcoin_txid", "txid": "...", "block_height": 123456}`
* **Lightning**: `{"type": "lightning_preimage", "preimage": "...", "payment_hash": "..."}`
* **Custom**: Method-specific proof format

### Payment Metadata Standards

Paykit standardizes payment metadata for common use cases:

#### Standard Metadata Fields

```json
{
  "order_id": "ORD-001",
  "invoice_number": "INV-001",
  "items": [
    {
      "description": "Product name",
      "quantity": 1,
      "price": "1000",
      "currency": "SAT"
    }
  ],
  "shipping": {
    "address": "...",
    "method": "standard",
    "cost": "500"
  },
  "tax": {
    "amount": "100",
    "rate": "0.10",
    "jurisdiction": "US-CA"
  },
  "notes": "Customer notes"
}
```

### Protocol Flow Examples

#### Basic Payment Discovery

```
Payer                          Pubky Homeserver              Payee
  |                                    |                         |
  |--Query /pub/paykit.app/v0/-------->|                         |
  |                                    |                         |
  |<--Return: onchain, lightning-------|                         |
  |                                    |                         |
  |--Read /pub/paykit.app/v0/onchain->|                         |
  |<--Return: bc1q...-----------------|                         |
  |                                    |                         |
  |--Read /pub/paykit.app/v0/lightning|                         |
  |<--Return: lnurl1...---------------|                         |
```

#### Interactive Payment

```
Payer                          Noise Channel                  Payee
  |                                    |                         |
  |--Noise_IK Handshake--------------->|                         |
  |<--Handshake Complete---------------|                         |
  |                                    |                         |
  |--RequestReceipt------------------->|                         |
  |  (provisional receipt)             |                         |
  |                                    |--Generate Invoice--------|
  |<--ConfirmReceipt-------------------|                         |
  |  (finalized receipt with invoice)  |                         |
  |                                    |                         |
  |--Execute Payment (off-protocol)---|                         |
  |  (Pay Lightning invoice)           |                         |
  |                                    |                         |
  |--Save Receipt                      |--Save Receipt----------|
```

#### Subscription Payment

```
Subscriber                     Pubky Directory                Provider
  |                                    |                         |
  |--Create Subscription-------------->|                         |
  |  (signed agreement)                |                         |
  |                                    |                         |
  |--Store in /pub/paykit.app/--------|                         |
  |  subscriptions/{id}                |                         |
  |                                    |                         |
  |<--Payment Request-----------------|                         |
  |  (monthly payment due)             |                         |
  |                                    |                         |
  |--Check Auto-Pay Rules              |                         |
  |  (if enabled, auto-approve)         |                         |
  |                                    |                         |
  |--Execute Payment------------------>|                         |
  |  (via Interactive Protocol)         |                         |
```

## Security Considerations

### Identity Authentication

* All participants authenticated via Ed25519 public keys
* Noise protocol provides mutual authentication
* Identity binding prevents man-in-the-middle attacks
* Public keys serve as payment recipient identifiers

### Encryption

* All interactive communication encrypted via Noise Protocol
* Forward secrecy through ephemeral key exchange
* ChaCha20-Poly1305 provides authenticated encryption
* Private endpoints not exposed in public directory

### Replay Protection

* Subscription signatures include unique nonces
* Nonce database prevents signature replay
* Timestamp validation prevents old signature reuse
* Expiration times limit signature validity

### Spending Limits

* Atomic check-and-reserve operations
* File-level locking for concurrency safety
* Automatic rollback on payment failure
* Period-based limits prevent unbounded spending

### Key Management

* Private keys must be stored securely (HSMs, secure enclaves)
* Key rotation policies recommended
* Ed25519 keys used for both identity and Noise protocol
* X25519 keys derived from Ed25519 for Noise key exchange

### Privacy

* Public directory exposes payment methods (not amounts or recipients)
* Private endpoints enable per-peer dedicated addresses
* Noise protocol hides payment negotiation from observers
* Receipts stored locally, not in public directory

## Privacy Considerations

### Information Leakage

* Public directory reveals which payment methods a payee supports
* Directory queries reveal which payees a payer is interested in
* Payment method patterns may reveal payment amounts or frequencies
* Private endpoints reduce public address reuse

### Mitigations

* Use private endpoints for sensitive payments
* Rotate public addresses regularly
* Consider directory query privacy (Tor, VPN)
* Limit public directory exposure

## Implementation Guidelines

### Reference Implementation

A reference implementation is available in Rust:
* `paykit-lib`: Core directory protocol
* `paykit-interactive`: Interactive protocol
* `paykit-subscriptions`: Subscription protocol
* `paykit-demo-cli`: Command-line demo
* `paykit-demo-web`: WebAssembly browser demo

Repository: [To be determined - placeholder for John Carvalho's repository]

### Transport Abstraction

Paykit uses trait-based transport abstraction:
* `AuthenticatedTransport`: For publishing endpoints
* `UnauthenticatedTransportRead`: For discovering endpoints
* Pubky adapters provided, but custom transports supported

### Error Handling

Paykit defines structured error types:
* `PaykitError`: Directory protocol errors
* `InteractiveError`: Interactive protocol errors
* `SubscriptionError`: Subscription protocol errors

Applications should handle errors gracefully and provide user-friendly messages.

### Versioning

Paykit uses semantic versioning:
* Path prefix includes version: `/pub/paykit.app/v0/`
* Future versions may use `/pub/paykit.app/v1/`
* Version negotiation may be added in future

### Wallet Integration

Wallets adopt Paykit through:
* `paykit-lib` and related dependencies
* Integration with existing wallet infrastructure
* Plugin architecture for payment method support
* Reference implementation in Bitkit mobile app

## Future Extensions (2026 Roadmap)

### Payment Requests Standardization

Standardized payment request format for:
* Invoice generation
* Payment due dates
* Payment reminders
* Payment status tracking

### Payment Routing Hints

Enhanced routing information for:
* Complex payment scenarios
* Fallback payment chains
* Payment method negotiation
* Automatic method selection

### Payment Proof Standardization

Unified proof format for:
* On-chain transactions (txid, block height)
* Lightning payments (preimage, payment hash)
* Cross-chain proofs
* Payment verification

### Payment Metadata Standards

Structured metadata for:
* Order information
* Shipping details
* Tax information
* Regulatory compliance

### Enhanced Subscription Features

* Payment method fallback chains
* Subscription upgrades/downgrades
* Prorated billing
* Subscription sharing

### Payment Method Health Checks

* Endpoint availability monitoring
* Payment method status reporting
* Automatic failover
* Health check APIs

### Bitkit Integration

Integration work for Bitkit mobile app:
* Native mobile implementation
* UI/UX for Paykit features
* Payment profile management
* Scanner integration for Pubky URIs

## Backward Compatibility

Paykit is designed for extensibility:
* New payment methods can be added without protocol changes
* New message types can be added to interactive protocol
* Schema changes handled through versioned paths
* Old implementations continue to work with new features

Migration path for existing systems:
* Create Paykit plugin for existing payment method
* Publish endpoints via Paykit directory
* Gradually adopt Paykit features
* Maintain backward compatibility during transition

## Test Vectors

[Test vectors may be added if BIP reviewers expect them]

## Reference Implementation

Reference implementation available at:
* Repository: [To be determined - placeholder for John Carvalho's repository]
* Language: Rust
* License: MIT

## Acknowledgments

* Pubky Protocol for decentralized identity and storage
* Noise Protocol Framework for encrypted communication
* Bitcoin and Lightning Network communities for payment method inspiration

## References

* Pubky Protocol: https://pubky.org
* Noise Protocol Framework: https://noiseprotocol.org/
* BOLT 11: Lightning Network Invoice Format
* Ed25519: RFC 8032
* X25519: RFC 7748
* ChaCha20-Poly1305: RFC 8439
* BLAKE2s: RFC 7693

## Changelog

[To be added as the BIP evolves]
