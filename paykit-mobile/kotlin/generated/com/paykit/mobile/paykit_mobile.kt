// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package com.paykit.mobile;

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    @JvmField var capacity: Int = 0
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

    companion object {
        internal fun alloc(size: Int = 0) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_paykit_mobile_rustbuffer_alloc(size, status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: Int, len: Int, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity
            buf.len = len
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_paykit_mobile_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setInt(0, value.capacity)
        pointer.setInt(4, value.len)
        pointer.setPointer(8, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getInt(0))
        value.writeField("len", pointer.getInt(4))
        value.writeField("data", pointer.getPointer(8))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): Int

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity.toLong()).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == 0.toByte()
    }

    fun isError(): Boolean {
        return code == 1.toByte()
    }

    fun isPanic(): Boolean {
        return code == 2.toByte()
    }
}

class InternalException(message: String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus();
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback);
}

// IntegerType that matches Rust's `usize` / C's `size_t`
public class USize(value: Long = 0) : IntegerType(Native.SIZE_T_SIZE, value, true) {
    // This is needed to fill in the gaps of IntegerType's implementation of Number for Kotlin.
    override fun toByte() = toInt().toByte()
    // Needed until https://youtrack.jetbrains.com/issue/KT-47902 is fixed.
    @Deprecated("`toInt().toChar()` is deprecated")
    override fun toChar() = toInt().toChar()
    override fun toShort() = toInt().toShort()

    fun writeToBuffer(buf: ByteBuffer) {
        // Make sure we always write usize integers using native byte-order, since they may be
        // casted to pointer values
        buf.order(ByteOrder.nativeOrder())
        try {
            when (Native.SIZE_T_SIZE) {
                4 -> buf.putInt(toInt())
                8 -> buf.putLong(toLong())
                else -> throw RuntimeException("Invalid SIZE_T_SIZE: ${Native.SIZE_T_SIZE}")
            }
        } finally {
            buf.order(ByteOrder.BIG_ENDIAN)
        }
    }

    companion object {
        val size: Int
            get() = Native.SIZE_T_SIZE

        fun readFromBuffer(buf: ByteBuffer) : USize {
            // Make sure we always read usize integers using native byte-order, since they may be
            // casted from pointer values
            buf.order(ByteOrder.nativeOrder())
            try {
                return when (Native.SIZE_T_SIZE) {
                    4 -> USize(buf.getInt().toLong())
                    8 -> USize(buf.getLong())
                    else -> throw RuntimeException("Invalid SIZE_T_SIZE: ${Native.SIZE_T_SIZE}")
                }
            } finally {
                buf.order(ByteOrder.BIG_ENDIAN)
            }
        }
    }
}


// Map handles to objects
//
// This is used when the Rust code expects an opaque pointer to represent some foreign object.
// Normally we would pass a pointer to the object, but JNA doesn't support getting a pointer from an
// object reference , nor does it support leaking a reference to Rust.
//
// Instead, this class maps USize values to objects so that we can pass a pointer-sized type to
// Rust when it needs an opaque pointer.
//
// TODO: refactor callbacks to use this class
internal class UniFfiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<USize, T>()
    // Use AtomicInteger for our counter, since we may be on a 32-bit system.  4 billion possible
    // values seems like enough. If somehow we generate 4 billion handles, then this will wrap
    // around back to zero and we can assume the first handle generated will have been dropped by
    // then.
    private val counter = java.util.concurrent.atomic.AtomicInteger(0)

    val size: Int
        get() = map.size

    fun insert(obj: T): USize {
        val handle = USize(counter.getAndAdd(1).toLong())
        map.put(handle, obj)
        return handle
    }

    fun get(handle: USize): T? {
        return map.get(handle)
    }

    fun remove(handle: USize): T? {
        return map.remove(handle)
    }
}

// FFI type for Rust future continuations
internal interface UniFffiRustFutureContinuationCallbackType : com.sun.jna.Callback {
    fun callback(continuationHandle: USize, pollResult: Byte);
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "paykit_mobile"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            loadIndirect<UniffiLib>(componentName = "paykit_mobile")
            .also { lib: UniffiLib ->
                uniffiCheckContractApiVersion(lib)
                uniffiCheckApiChecksums(lib)
                uniffiCallbackInterfacePubkyAuthenticatedStorageCallback.register(lib)
                uniffiCallbackInterfacePubkyUnauthenticatedStorageCallback.register(lib)
                uniffiCallbackInterfaceReceiptGeneratorCallback.register(lib)
                }
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    fun uniffi_paykit_mobile_fn_clone_authenticatedtransportffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_free_authenticatedtransportffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_callback(`callback`: Long,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_session_json(`sessionJson`: RustBuffer.ByValue,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_new_mock(`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_delete(`ptr`: Pointer,`path`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_get(`ptr`: Pointer,`path`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_is_mock(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_list(`ptr`: Pointer,`prefix`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_owner_pubkey(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_put(`ptr`: Pointer,`path`: RustBuffer.ByValue,`content`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_clone_contactcacheffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_free_contactcacheffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_constructor_contactcacheffi_new(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_add(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_add_with_name(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,`name`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_clear(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_contains(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_count(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_get(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_get_all(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_remove(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_contactcacheffi_sync(`ptr`: Pointer,`remotePubkeys`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_clone_directoryoperationsasync(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_free_directoryoperationsasync(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_constructor_directoryoperationsasync_new(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_add_contact(`ptr`: Pointer,`transport`: Pointer,`contactPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_known_contacts(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_supported_payments(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_list_contacts(`ptr`: Pointer,`transport`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_publish_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`methodId`: RustBuffer.ByValue,`endpointData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_contact(`ptr`: Pointer,`transport`: Pointer,`contactPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_clone_paykitclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_free_paykitclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_constructor_paykitclient_new(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_paykitclient_add_contact(`ptr`: Pointer,`transport`: Pointer,`contactPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_paykitclient_calculate_proration(`ptr`: Pointer,`currentAmountSats`: Long,`newAmountSats`: Long,`periodStart`: Long,`periodEnd`: Long,`changeDate`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_check_health(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_create_noise_error_message(`ptr`: Pointer,`code`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_create_payment_request(`ptr`: Pointer,`fromPubkey`: RustBuffer.ByValue,`toPubkey`: RustBuffer.ByValue,`amountSats`: Long,`currency`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`description`: RustBuffer.ByValue,`expiresInSecs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_create_receipt(`ptr`: Pointer,`payer`: RustBuffer.ByValue,`payee`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_confirmation_message(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,`payerPubkey`: RustBuffer.ByValue,`payeePubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,`signature`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_request_message(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,`payerPubkey`: RustBuffer.ByValue,`payeePubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_create_subscription(`ptr`: Pointer,`subscriber`: RustBuffer.ByValue,`provider`: RustBuffer.ByValue,`terms`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_days_remaining_in_period(`ptr`: Pointer,`periodEnd`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun uniffi_paykit_mobile_fn_method_paykitclient_discover_noise_endpoint(`ptr`: Pointer,`transport`: Pointer,`recipientPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_extract_key_from_qr(`ptr`: Pointer,`scannedData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_extract_method_from_qr(`ptr`: Pointer,`scannedData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_fetch_known_contacts(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_fetch_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_fetch_supported_payments(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_get_health_status(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_get_in_progress_payments(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_get_payment_status(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_is_method_usable(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_paykit_mobile_fn_method_paykitclient_is_paykit_qr(`ptr`: Pointer,`scannedData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_paykit_mobile_fn_method_paykitclient_list_contacts(`ptr`: Pointer,`transport`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_list_methods(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_parse_noise_payment_message(`ptr`: Pointer,`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_parse_receipt_metadata(`ptr`: Pointer,`metadataJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_parse_scanned_qr(`ptr`: Pointer,`scannedData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_publish_noise_endpoint(`ptr`: Pointer,`transport`: Pointer,`host`: RustBuffer.ByValue,`port`: Short,`noisePubkey`: RustBuffer.ByValue,`metadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_paykitclient_publish_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`methodId`: RustBuffer.ByValue,`endpointData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_paykitclient_remove_contact(`ptr`: Pointer,`transport`: Pointer,`contactPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_paykitclient_remove_noise_endpoint(`ptr`: Pointer,`transport`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_paykitclient_remove_payment_endpoint_from_directory(`ptr`: Pointer,`transport`: Pointer,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_paykitclient_select_method(`ptr`: Pointer,`supportedMethods`: RustBuffer.ByValue,`amountSats`: Long,`preferences`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitclient_validate_endpoint(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_paykit_mobile_fn_clone_paykitinteractivemanagerffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_free_paykitinteractivemanagerffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_constructor_paykitinteractivemanagerffi_new(`store`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_endpoint_offer(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_payment_request(`ptr`: Pointer,`payer`: RustBuffer.ByValue,`payee`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,`metadataJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_private_endpoint(`ptr`: Pointer,`peer`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_receipt(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_store(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_message(`ptr`: Pointer,`messageJson`: RustBuffer.ByValue,`peerPubkey`: RustBuffer.ByValue,`myPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_payment_response(`ptr`: Pointer,`responseJson`: RustBuffer.ByValue,`originalReceiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_private_endpoints(`ptr`: Pointer,`peer`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_receipts(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_set_generator(`ptr`: Pointer,`generator`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_clone_paykitmessagebuilder(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_free_paykitmessagebuilder(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_constructor_paykitmessagebuilder_new(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_ack(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_endpoint_offer(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_error(`ptr`: Pointer,`code`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_confirm(`ptr`: Pointer,`receipt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_request(`ptr`: Pointer,`request`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_get_message_type(`ptr`: Pointer,`messageJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_parse_message(`ptr`: Pointer,`messageJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_clone_receiptstore(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_free_receiptstore(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_constructor_receiptstore_new(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_receiptstore_clear(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_receiptstore_delete_receipt(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_receiptstore_export_receipts_json(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_receiptstore_get_private_endpoint(`ptr`: Pointer,`peer`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_receiptstore_get_receipt(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_receiptstore_import_receipts_json(`ptr`: Pointer,`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun uniffi_paykit_mobile_fn_method_receiptstore_list_private_endpoints(`ptr`: Pointer,`peer`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_receiptstore_list_receipts(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_receiptstore_save_private_endpoint(`ptr`: Pointer,`peer`: RustBuffer.ByValue,`offer`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_method_receiptstore_save_receipt(`ptr`: Pointer,`receipt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_clone_unauthenticatedtransportffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_free_unauthenticatedtransportffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_authenticated(`auth`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_callback(`callback`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_config_json(`configJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_new_mock(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_get(`ptr`: Pointer,`ownerPubkey`: RustBuffer.ByValue,`path`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_is_mock(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_list(`ptr`: Pointer,`ownerPubkey`: RustBuffer.ByValue,`prefix`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_init_callback_pubkyauthenticatedstoragecallback(`handle`: ForeignCallback,
    ): Unit
    fun uniffi_paykit_mobile_fn_init_callback_pubkyunauthenticatedstoragecallback(`handle`: ForeignCallback,
    ): Unit
    fun uniffi_paykit_mobile_fn_init_callback_receiptgeneratorcallback(`handle`: ForeignCallback,
    ): Unit
    fun uniffi_paykit_mobile_fn_func_create_contact_cache(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_func_create_directory_operations_async(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_func_create_error_message(`code`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_create_interactive_manager(`store`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_func_create_message_builder(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_func_create_noise_server_config(uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_create_noise_server_config_with_port(`port`: Short,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_create_paykit_client(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_func_create_private_endpoint_offer_message(`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,`expiresInSecs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_create_receipt_confirmation_message(`receiptId`: RustBuffer.ByValue,`payerPubkey`: RustBuffer.ByValue,`payeePubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,`signature`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_create_receipt_request_message(`receiptId`: RustBuffer.ByValue,`payerPubkey`: RustBuffer.ByValue,`payeePubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_create_receipt_store(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_paykit_mobile_fn_func_derive_x25519_keypair(`ed25519SecretHex`: RustBuffer.ByValue,`deviceId`: RustBuffer.ByValue,`epoch`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_discover_noise_endpoint(`transport`: Pointer,`recipientPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_ed25519_keypair_from_secret(`secretKeyHex`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_export_keypair_to_backup(`secretKeyHex`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_format_public_key_z32(`publicKeyHex`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_generate_device_id(uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_generate_ed25519_keypair(uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_get_version(uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_import_keypair_from_backup(`backup`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_parse_payment_message(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_parse_public_key_z32(`publicKeyZ32`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_publish_noise_endpoint(`transport`: Pointer,`host`: RustBuffer.ByValue,`port`: Short,`noisePubkey`: RustBuffer.ByValue,`metadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_func_remove_noise_endpoint(`transport`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_fn_func_sign_message(`secretKeyHex`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_paykit_mobile_fn_func_verify_signature(`publicKeyHex`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,`signatureHex`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_paykit_mobile_rustbuffer_alloc(`size`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_paykit_mobile_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_paykit_mobile_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun ffi_paykit_mobile_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_paykit_mobile_rust_future_poll_u8(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_u8(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_u8(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_u8(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_paykit_mobile_rust_future_poll_i8(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_i8(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_i8(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_i8(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_paykit_mobile_rust_future_poll_u16(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_u16(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_u16(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_u16(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_paykit_mobile_rust_future_poll_i16(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_i16(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_i16(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_i16(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_paykit_mobile_rust_future_poll_u32(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_u32(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_u32(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_u32(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_paykit_mobile_rust_future_poll_i32(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_i32(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_i32(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_i32(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_paykit_mobile_rust_future_poll_u64(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_u64(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_u64(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_u64(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_paykit_mobile_rust_future_poll_i64(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_i64(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_i64(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_i64(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_paykit_mobile_rust_future_poll_f32(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_f32(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_f32(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_f32(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Float
    fun ffi_paykit_mobile_rust_future_poll_f64(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_f64(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_f64(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_f64(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Double
    fun ffi_paykit_mobile_rust_future_poll_pointer(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_pointer(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_pointer(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_pointer(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun ffi_paykit_mobile_rust_future_poll_rust_buffer(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_rust_buffer(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_rust_buffer(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_rust_buffer(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_paykit_mobile_rust_future_poll_void(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_paykit_mobile_rust_future_cancel_void(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_free_void(`handle`: Pointer,
    ): Unit
    fun ffi_paykit_mobile_rust_future_complete_void(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_paykit_mobile_checksum_func_create_contact_cache(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_directory_operations_async(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_error_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_interactive_manager(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_message_builder(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_noise_server_config(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_noise_server_config_with_port(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_paykit_client(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_private_endpoint_offer_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_receipt_confirmation_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_receipt_request_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_create_receipt_store(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_derive_x25519_keypair(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_discover_noise_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_ed25519_keypair_from_secret(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_export_keypair_to_backup(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_format_public_key_z32(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_generate_device_id(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_generate_ed25519_keypair(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_get_version(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_import_keypair_from_backup(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_parse_payment_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_parse_public_key_z32(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_publish_noise_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_remove_noise_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_sign_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_func_verify_signature(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_delete(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_get(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_is_mock(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_list(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_owner_pubkey(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_put(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_add(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_add_with_name(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_clear(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_contains(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_count(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_get(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_get_all(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_remove(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_contactcacheffi_sync(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_add_contact(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_known_contacts(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_payment_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_supported_payments(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_list_contacts(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_publish_payment_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_contact(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_payment_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_add_contact(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_calculate_proration(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_check_health(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_create_noise_error_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_create_payment_request(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_confirmation_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_request_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_create_subscription(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_days_remaining_in_period(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_discover_noise_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_extract_key_from_qr(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_extract_method_from_qr(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_fetch_known_contacts(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_fetch_payment_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_fetch_supported_payments(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_get_health_status(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_get_in_progress_payments(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_get_payment_status(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_is_method_usable(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_is_paykit_qr(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_list_contacts(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_list_methods(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_parse_noise_payment_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_parse_receipt_metadata(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_parse_scanned_qr(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_publish_noise_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_publish_payment_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_remove_contact(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_remove_noise_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_remove_payment_endpoint_from_directory(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_select_method(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitclient_validate_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_endpoint_offer(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_payment_request(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_private_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_receipt(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_store(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_payment_response(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_private_endpoints(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_receipts(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_set_generator(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_ack(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_endpoint_offer(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_error(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_confirm(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_request(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_get_message_type(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_parse_message(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_clear(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_delete_receipt(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_export_receipts_json(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_get_private_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_get_receipt(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_import_receipts_json(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_list_private_endpoints(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_list_receipts(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_save_private_endpoint(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptstore_save_receipt(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_get(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_is_mock(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_list(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_callback(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_session_json(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_new_mock(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_contactcacheffi_new(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_directoryoperationsasync_new(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_paykitclient_new(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_paykitinteractivemanagerffi_new(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_paykitmessagebuilder_new(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_receiptstore_new(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_authenticated(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_callback(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_config_json(
    ): Short
    fun uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_new_mock(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_put(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_get(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_delete(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_list(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_get(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_list(
    ): Short
    fun uniffi_paykit_mobile_checksum_method_receiptgeneratorcallback_generate_receipt(
    ): Short
    fun ffi_paykit_mobile_uniffi_contract_version(
    ): Int
    
}

private fun uniffiCheckContractApiVersion(lib: UniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_paykit_mobile_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: UniffiLib) {
    if (lib.uniffi_paykit_mobile_checksum_func_create_contact_cache() != 8922.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_directory_operations_async() != 3774.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_error_message() != 25647.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_interactive_manager() != 6575.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_message_builder() != 17772.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_noise_server_config() != 51894.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_noise_server_config_with_port() != 63078.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_paykit_client() != 24343.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_private_endpoint_offer_message() != 34999.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_receipt_confirmation_message() != 39140.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_receipt_request_message() != 38775.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_receipt_store() != 25695.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_derive_x25519_keypair() != 35150.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_discover_noise_endpoint() != 40526.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_ed25519_keypair_from_secret() != 9902.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_export_keypair_to_backup() != 64738.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_format_public_key_z32() != 60670.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_generate_device_id() != 4216.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_generate_ed25519_keypair() != 1379.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_get_version() != 23495.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_import_keypair_from_backup() != 2045.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_parse_payment_message() != 50074.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_parse_public_key_z32() != 18323.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_publish_noise_endpoint() != 28655.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_remove_noise_endpoint() != 59542.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_sign_message() != 46705.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_verify_signature() != 6178.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_delete() != 59452.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_get() != 6767.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_is_mock() != 21711.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_list() != 15374.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_owner_pubkey() != 20095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_put() != 11239.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_add() != 12782.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_add_with_name() != 63134.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_clear() != 8267.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_contains() != 10247.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_count() != 63824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_get() != 19809.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_get_all() != 31771.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_remove() != 23244.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_sync() != 54655.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_add_contact() != 46348.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_known_contacts() != 14389.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_payment_endpoint() != 15229.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_supported_payments() != 25737.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_list_contacts() != 46871.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_publish_payment_endpoint() != 64662.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_contact() != 28065.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_payment_endpoint() != 40611.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_add_contact() != 5322.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_calculate_proration() != 64929.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_check_health() != 61124.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_noise_error_message() != 24747.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_payment_request() != 59726.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt() != 12923.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_confirmation_message() != 23349.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_request_message() != 14340.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_subscription() != 32373.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_days_remaining_in_period() != 4816.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_discover_noise_endpoint() != 24963.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_extract_key_from_qr() != 60905.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_extract_method_from_qr() != 63286.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_fetch_known_contacts() != 48759.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_fetch_payment_endpoint() != 63867.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_fetch_supported_payments() != 45518.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_get_health_status() != 665.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_get_in_progress_payments() != 25824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_get_payment_status() != 49692.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_is_method_usable() != 34148.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_is_paykit_qr() != 30125.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_list_contacts() != 15384.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_list_methods() != 42624.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_parse_noise_payment_message() != 36870.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_parse_receipt_metadata() != 40194.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_parse_scanned_qr() != 50070.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_publish_noise_endpoint() != 20921.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_publish_payment_endpoint() != 17605.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_remove_contact() != 26597.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_remove_noise_endpoint() != 55896.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_remove_payment_endpoint_from_directory() != 33360.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_select_method() != 42832.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_validate_endpoint() != 41220.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_endpoint_offer() != 36215.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_payment_request() != 12387.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_private_endpoint() != 63022.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_receipt() != 3728.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_store() != 2983.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_message() != 28626.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_payment_response() != 41746.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_private_endpoints() != 21632.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_receipts() != 20652.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_set_generator() != 4040.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_ack() != 36644.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_endpoint_offer() != 25884.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_error() != 14599.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_confirm() != 17132.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_request() != 55941.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_get_message_type() != 8687.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_parse_message() != 62982.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_clear() != 37348.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_delete_receipt() != 18988.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_export_receipts_json() != 57252.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_get_private_endpoint() != 22258.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_get_receipt() != 53531.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_import_receipts_json() != 7694.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_list_private_endpoints() != 11893.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_list_receipts() != 50608.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_save_private_endpoint() != 7320.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_save_receipt() != 7972.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_get() != 30485.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_is_mock() != 10080.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_list() != 41862.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_callback() != 46711.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_session_json() != 8313.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_new_mock() != 29404.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_contactcacheffi_new() != 4021.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_directoryoperationsasync_new() != 62626.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_paykitclient_new() != 40010.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_paykitinteractivemanagerffi_new() != 57460.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_paykitmessagebuilder_new() != 30374.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_receiptstore_new() != 33744.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_authenticated() != 21979.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_callback() != 13071.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_config_json() != 23623.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_new_mock() != 13023.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_put() != 59509.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_get() != 7122.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_delete() != 8403.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_list() != 24077.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_get() != 3704.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_list() != 35538.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptgeneratorcallback_generate_receipt() != 62383.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// Async support

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len)
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): Int {
        val sizeForLength = 4
        val sizeForString = value.length * 3
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): Int {
        return 4 + value.size
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}



// The cleaner interface for Object finalization code to run.
// This is the entry point to any implementation that we're using.
//
// The cleaner registers objects and returns cleanables, so now we are
// defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
// different implmentations available at compile time.
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        //  otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

// The base class for all UniFFI Object types.
//
// This class provides core operations for working with the Rust `Arc<T>` pointer to
// the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// the Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each `FFIObject` instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an `FFIObject` is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an `FFIObject` instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each `FFIObject` an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//
abstract class FFIObject: Disposable, AutoCloseable {

    constructor(pointer: Pointer) {
        this.pointer = pointer
    }

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
    }

    protected val pointer: Pointer?
    protected abstract val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    open fun uniffiClonePointer(): Pointer {
        // Overridden by generated subclasses, the default method exists to allow users to manually
        // implement the interface
        throw RuntimeException("uniffiClonePointer not implemented")
    }

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }
}

/** Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly. */
object NoPointer


/**
 * FFI wrapper for authenticated transport operations.
 *
 * This wraps authenticated write access to Pubky homeservers.
 * Mobile apps can use either:
 * - `new_mock()` for testing
 * - `from_callback()` for production with real Pubky SDK
 */
public interface AuthenticatedTransportFfiInterface {
    
    /**
     * Delete a file at the given path.
     */
    fun `delete`(`path`: String)
    
    /**
     * Get a file at the given path.
     */
    fun `get`(`path`: String): String?
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    fun `isMock`(): Boolean
    
    /**
     * List files with a given prefix.
     */
    fun `list`(`prefix`: String): List<String>
    
    /**
     * Get the owner's public key.
     */
    fun `ownerPubkey`(): String
    
    /**
     * Put (create or update) a file at the given path.
     */
    fun `put`(`path`: String, `content`: String)
    
    companion object
}

/**
 * FFI wrapper for authenticated transport operations.
 *
 * This wraps authenticated write access to Pubky homeservers.
 * Mobile apps can use either:
 * - `new_mock()` for testing
 * - `from_callback()` for production with real Pubky SDK
 */
open class AuthenticatedTransportFfi : FFIObject, AuthenticatedTransportFfiInterface {

    constructor(pointer: Pointer): super(pointer)

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    constructor(noPointer: NoPointer): super(noPointer)

    override val cleanable: UniffiCleaner.Cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_authenticatedtransportffi(ptr, status)
                }
            }
        }
    }

    override fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_authenticatedtransportffi(pointer!!, status)
        }
    }

    
    /**
     * Delete a file at the given path.
     */
    @Throws(PaykitMobileException::class)override fun `delete`(`path`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_delete(it,
        FfiConverterString.lower(`path`),
        _status)
}
        }
    
    
    
    /**
     * Get a file at the given path.
     */
    @Throws(PaykitMobileException::class)override fun `get`(`path`: String): String? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_get(it,
        FfiConverterString.lower(`path`),
        _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    @Throws(PaykitMobileException::class)override fun `isMock`(): Boolean =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_is_mock(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    
    /**
     * List files with a given prefix.
     */
    @Throws(PaykitMobileException::class)override fun `list`(`prefix`: String): List<String> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_list(it,
        FfiConverterString.lower(`prefix`),
        _status)
}
        }.let {
            FfiConverterSequenceString.lift(it)
        }
    
    
    /**
     * Get the owner's public key.
     */override fun `ownerPubkey`(): String =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_owner_pubkey(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Put (create or update) a file at the given path.
     */
    @Throws(PaykitMobileException::class)override fun `put`(`path`: String, `content`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_put(it,
        FfiConverterString.lower(`path`),FfiConverterString.lower(`content`),
        _status)
}
        }
    
    
    

    companion object {
        
    /**
     * Create authenticated transport from a storage callback.
     *
     * # Arguments
     *
     * * `callback` - Storage callback implementing PubkyAuthenticatedStorageCallback
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     *
     * # Example (Swift)
     *
     * ```swift
     * class MyPubkyStorage: PubkyAuthenticatedStorageCallback {
     * let session: PubkySession
     *
     * func put(path: String, content: String) -> StorageOperationResult {
     * do {
     * try session.storage.put(path, content)
     * return StorageOperationResult.ok()
     * } catch {
     * return StorageOperationResult.err(error.localizedDescription)
     * }
     * }
     * // ... implement other methods
     * }
     *
     * let transport = AuthenticatedTransportFFI.fromCallback(
     * MyPubkyStorage(session: session),
     * ownerPubkey: myPublicKey
     * )
     * ```
     */
        fun `fromCallback`(`callback`: PubkyAuthenticatedStorageCallback, `ownerPubkey`: String): AuthenticatedTransportFfi =
            AuthenticatedTransportFfi(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_callback(FfiConverterTypePubkyAuthenticatedStorageCallback.lower(`callback`),FfiConverterString.lower(`ownerPubkey`),_status)
})
        
    /**
     * Create authenticated transport from a Pubky session JSON.
     *
     * # Deprecated
     *
     * This method creates a mock transport. Use `from_callback()` for production.
     *
     * # Arguments
     *
     * * `session_json` - JSON configuration (validated but not used)
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     */
        fun `fromSessionJson`(`sessionJson`: String, `ownerPubkey`: String): AuthenticatedTransportFfi =
            AuthenticatedTransportFfi(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_session_json(FfiConverterString.lower(`sessionJson`),FfiConverterString.lower(`ownerPubkey`),_status)
})
        
    /**
     * Create a new authenticated transport for testing/development.
     *
     * Uses in-memory storage - data is not persisted.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     */
        fun `newMock`(`ownerPubkey`: String): AuthenticatedTransportFfi =
            AuthenticatedTransportFfi(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_new_mock(FfiConverterString.lower(`ownerPubkey`),_status)
})
        
    }
    
}

public object FfiConverterTypeAuthenticatedTransportFFI: FfiConverter<AuthenticatedTransportFfi, Pointer> {

    override fun lower(value: AuthenticatedTransportFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): AuthenticatedTransportFfi {
        return AuthenticatedTransportFfi(value)
    }

    override fun read(buf: ByteBuffer): AuthenticatedTransportFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: AuthenticatedTransportFfi) = 8

    override fun write(value: AuthenticatedTransportFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}





/**
 * FFI-safe wrapper for local contact cache.
 */
public interface ContactCacheFfiInterface {
    
    /**
     * Add a contact by public key.
     */
    fun `add`(`pubkey`: String)
    
    /**
     * Add a contact with a display name.
     */
    fun `addWithName`(`pubkey`: String, `name`: String)
    
    /**
     * Clear all cached contacts.
     */
    fun `clear`()
    
    /**
     * Check if a contact exists.
     */
    fun `contains`(`pubkey`: String): Boolean
    
    /**
     * Get the number of cached contacts.
     */
    fun `count`(): UInt
    
    /**
     * Get a specific contact by public key.
     */
    fun `get`(`pubkey`: String): CachedContactFfi?
    
    /**
     * Get all cached contacts.
     */
    fun `getAll`(): List<CachedContactFfi>
    
    /**
     * Remove a contact by public key.
     */
    fun `remove`(`pubkey`: String)
    
    /**
     * Sync with remote contacts.
     */
    fun `sync`(`remotePubkeys`: List<String>): SyncResultFfi
    
    companion object
}

/**
 * FFI-safe wrapper for local contact cache.
 */
open class ContactCacheFfi : FFIObject, ContactCacheFfiInterface {

    constructor(pointer: Pointer): super(pointer)

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    constructor(noPointer: NoPointer): super(noPointer)
    /**
     * Create a new contact cache (uses in-memory storage).
     */
    constructor() :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_contactcacheffi_new(_status)
})

    override val cleanable: UniffiCleaner.Cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_contactcacheffi(ptr, status)
                }
            }
        }
    }

    override fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_contactcacheffi(pointer!!, status)
        }
    }

    
    /**
     * Add a contact by public key.
     */
    @Throws(StorageCacheException::class)override fun `add`(`pubkey`: String) =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_add(it,
        FfiConverterString.lower(`pubkey`),
        _status)
}
        }
    
    
    
    /**
     * Add a contact with a display name.
     */
    @Throws(StorageCacheException::class)override fun `addWithName`(`pubkey`: String, `name`: String) =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_add_with_name(it,
        FfiConverterString.lower(`pubkey`),FfiConverterString.lower(`name`),
        _status)
}
        }
    
    
    
    /**
     * Clear all cached contacts.
     */
    @Throws(StorageCacheException::class)override fun `clear`() =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_clear(it,
        
        _status)
}
        }
    
    
    
    /**
     * Check if a contact exists.
     */
    @Throws(StorageCacheException::class)override fun `contains`(`pubkey`: String): Boolean =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_contains(it,
        FfiConverterString.lower(`pubkey`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    
    /**
     * Get the number of cached contacts.
     */
    @Throws(StorageCacheException::class)override fun `count`(): UInt =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_count(it,
        
        _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    
    
    /**
     * Get a specific contact by public key.
     */
    @Throws(StorageCacheException::class)override fun `get`(`pubkey`: String): CachedContactFfi? =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_get(it,
        FfiConverterString.lower(`pubkey`),
        _status)
}
        }.let {
            FfiConverterOptionalTypeCachedContactFFI.lift(it)
        }
    
    
    /**
     * Get all cached contacts.
     */
    @Throws(StorageCacheException::class)override fun `getAll`(): List<CachedContactFfi> =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_get_all(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeCachedContactFFI.lift(it)
        }
    
    
    /**
     * Remove a contact by public key.
     */
    @Throws(StorageCacheException::class)override fun `remove`(`pubkey`: String) =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_remove(it,
        FfiConverterString.lower(`pubkey`),
        _status)
}
        }
    
    
    
    /**
     * Sync with remote contacts.
     */
    @Throws(StorageCacheException::class)override fun `sync`(`remotePubkeys`: List<String>): SyncResultFfi =
        callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_sync(it,
        FfiConverterSequenceString.lower(`remotePubkeys`),
        _status)
}
        }.let {
            FfiConverterTypeSyncResultFFI.lift(it)
        }
    
    

    
    companion object
    
}

public object FfiConverterTypeContactCacheFFI: FfiConverter<ContactCacheFfi, Pointer> {

    override fun lower(value: ContactCacheFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ContactCacheFfi {
        return ContactCacheFfi(value)
    }

    override fun read(buf: ByteBuffer): ContactCacheFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ContactCacheFfi) = 8

    override fun write(value: ContactCacheFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}





/**
 * Async directory operations manager.
 *
 * Provides non-blocking directory operations with callback support.
 */
public interface DirectoryOperationsAsyncInterface {
    
    /**
     * Add a contact asynchronously.
     */
    fun `addContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: String)
    
    /**
     * Fetch known contacts asynchronously.
     */
    fun `fetchKnownContacts`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String): List<String>
    
    /**
     * Fetch a specific payment endpoint asynchronously.
     */
    fun `fetchPaymentEndpoint`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String, `methodId`: String): String?
    
    /**
     * Fetch all supported payment methods asynchronously.
     */
    fun `fetchSupportedPayments`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String): List<PaymentMethod>
    
    /**
     * List all contacts asynchronously.
     */
    fun `listContacts`(`transport`: AuthenticatedTransportFfi): List<String>
    
    /**
     * Publish a payment endpoint asynchronously.
     *
     * This is a blocking call that wraps the async operation.
     * For true non-blocking behavior, use the callback-based methods from mobile SDKs.
     */
    fun `publishPaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: String, `endpointData`: String)
    
    /**
     * Remove a contact asynchronously.
     */
    fun `removeContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: String)
    
    /**
     * Remove a payment endpoint asynchronously.
     */
    fun `removePaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: String)
    
    companion object
}

/**
 * Async directory operations manager.
 *
 * Provides non-blocking directory operations with callback support.
 */
open class DirectoryOperationsAsync : FFIObject, DirectoryOperationsAsyncInterface {

    constructor(pointer: Pointer): super(pointer)

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    constructor(noPointer: NoPointer): super(noPointer)
    /**
     * Create a new async directory operations manager.
     */
    constructor() :
        this(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_directoryoperationsasync_new(_status)
})

    override val cleanable: UniffiCleaner.Cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_directoryoperationsasync(ptr, status)
                }
            }
        }
    }

    override fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_directoryoperationsasync(pointer!!, status)
        }
    }

    
    /**
     * Add a contact asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `addContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_add_contact(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`contactPubkey`),
        _status)
}
        }
    
    
    
    /**
     * Fetch known contacts asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `fetchKnownContacts`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String): List<String> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_known_contacts(it,
        FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),
        _status)
}
        }.let {
            FfiConverterSequenceString.lift(it)
        }
    
    
    /**
     * Fetch a specific payment endpoint asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `fetchPaymentEndpoint`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String, `methodId`: String): String? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_payment_endpoint(it,
        FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),FfiConverterString.lower(`methodId`),
        _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    
    
    /**
     * Fetch all supported payment methods asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `fetchSupportedPayments`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String): List<PaymentMethod> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_supported_payments(it,
        FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),
        _status)
}
        }.let {
            FfiConverterSequenceTypePaymentMethod.lift(it)
        }
    
    
    /**
     * List all contacts asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `listContacts`(`transport`: AuthenticatedTransportFfi): List<String> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_list_contacts(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),
        _status)
}
        }.let {
            FfiConverterSequenceString.lift(it)
        }
    
    
    /**
     * Publish a payment endpoint asynchronously.
     *
     * This is a blocking call that wraps the async operation.
     * For true non-blocking behavior, use the callback-based methods from mobile SDKs.
     */
    @Throws(PaykitMobileException::class)override fun `publishPaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: String, `endpointData`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_publish_payment_endpoint(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpointData`),
        _status)
}
        }
    
    
    
    /**
     * Remove a contact asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `removeContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_contact(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`contactPubkey`),
        _status)
}
        }
    
    
    
    /**
     * Remove a payment endpoint asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `removePaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_payment_endpoint(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`methodId`),
        _status)
}
        }
    
    
    

    
    companion object
    
}

public object FfiConverterTypeDirectoryOperationsAsync: FfiConverter<DirectoryOperationsAsync, Pointer> {

    override fun lower(value: DirectoryOperationsAsync): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): DirectoryOperationsAsync {
        return DirectoryOperationsAsync(value)
    }

    override fun read(buf: ByteBuffer): DirectoryOperationsAsync {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: DirectoryOperationsAsync) = 8

    override fun write(value: DirectoryOperationsAsync, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}





/**
 * Main Paykit client for mobile applications.
 */
public interface PaykitClientInterface {
    
    /**
     * Add a contact to the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to add
     */
    fun `addContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: String)
    
    /**
     * Calculate proration for a subscription modification.
     */
    fun `calculateProration`(`currentAmountSats`: Long, `newAmountSats`: Long, `periodStart`: Long, `periodEnd`: Long, `changeDate`: Long): ProrationResult
    
    /**
     * Check health of all payment methods.
     */
    fun `checkHealth`(): List<HealthCheckResult>
    
    /**
     * Create an error message for Noise channel.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error description
     */
    fun `createNoiseErrorMessage`(`code`: String, `message`: String): NoisePaymentMessage
    
    /**
     * Create a payment request.
     */
    fun `createPaymentRequest`(`fromPubkey`: String, `toPubkey`: String, `amountSats`: Long, `currency`: String, `methodId`: String, `description`: String, `expiresInSecs`: ULong?): PaymentRequest
    
    /**
     * Create a new receipt.
     */
    fun `createReceipt`(`payer`: String, `payee`: String, `methodId`: String, `amount`: String?, `currency`: String?): Receipt
    
    /**
     * Create a receipt confirmation message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - The receipt ID being confirmed
     * * `payer_pubkey` - Payer's public key
     * * `payee_pubkey` - Payee's public key
     * * `method_id` - Payment method used
     * * `amount` - Payment amount
     * * `currency` - Currency code
     * * `signature` - Optional signature from payee
     */
    fun `createReceiptConfirmationMessage`(`receiptId`: String, `payerPubkey`: String, `payeePubkey`: String, `methodId`: String, `amount`: String?, `currency`: String?, `signature`: String?): NoisePaymentMessage
    
    /**
     * Create a receipt request message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - Unique identifier for this receipt
     * * `payer_pubkey` - Payer's public key (z-base32)
     * * `payee_pubkey` - Payee's public key (z-base32)
     * * `method_id` - Payment method identifier
     * * `amount` - Optional payment amount
     * * `currency` - Optional currency code
     */
    fun `createReceiptRequestMessage`(`receiptId`: String, `payerPubkey`: String, `payeePubkey`: String, `methodId`: String, `amount`: String?, `currency`: String?): NoisePaymentMessage
    
    /**
     * Create a new subscription.
     */
    fun `createSubscription`(`subscriber`: String, `provider`: String, `terms`: SubscriptionTerms): Subscription
    
    /**
     * Get days remaining in current billing period.
     */
    fun `daysRemainingInPeriod`(`periodEnd`: Long): UInt
    
    /**
     * Discover a Noise endpoint for a recipient.
     *
     * Queries the recipient's public directory for their Noise server information.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The noise endpoint info if found, None otherwise.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * if let Some(endpoint) = client.discover_noise_endpoint(transport, "8pinxxgqs41...")? {
     * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
     * }
     * ```
     */
    fun `discoverNoiseEndpoint`(`transport`: UnauthenticatedTransportFfi, `recipientPubkey`: String): NoiseEndpointInfo?
    
    /**
     * Extract public key from scanned QR code.
     */
    fun `extractKeyFromQr`(`scannedData`: String): String?
    
    /**
     * Extract payment method from scanned QR code.
     */
    fun `extractMethodFromQr`(`scannedData`: String): String?
    
    /**
     * Fetch known contacts for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     *
     * # Returns
     *
     * List of contact public keys.
     */
    fun `fetchKnownContacts`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String): List<String>
    
    /**
     * Fetch a specific payment endpoint for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     * * `method_id` - The payment method to fetch
     *
     * # Returns
     *
     * The endpoint data if found, None otherwise.
     */
    fun `fetchPaymentEndpoint`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String, `methodId`: String): String?
    
    /**
     * Fetch all supported payment methods for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query (z-base32 encoded)
     *
     * # Returns
     *
     * List of payment methods with their endpoints.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * let methods = client.fetch_supported_payments(transport, "8pinxxgqs41...")?;
     * for method in methods {
     * println!("{}: {}", method.method_id, method.endpoint);
     * }
     * ```
     */
    fun `fetchSupportedPayments`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String): List<PaymentMethod>
    
    /**
     * Get health status of a specific method.
     */
    fun `getHealthStatus`(`methodId`: String): HealthStatus?
    
    /**
     * Get all in-progress payments.
     */
    fun `getInProgressPayments`(): List<PaymentStatusInfo>
    
    /**
     * Get payment status for a receipt.
     */
    fun `getPaymentStatus`(`receiptId`: String): PaymentStatusInfo?
    
    /**
     * Check if a method is usable (healthy or degraded).
     */
    fun `isMethodUsable`(`methodId`: String): Boolean
    
    /**
     * Check if scanned data looks like a Paykit URI.
     */
    fun `isPaykitQr`(`scannedData`: String): Boolean
    
    /**
     * List all contacts.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     *
     * # Returns
     *
     * List of contact public keys.
     */
    fun `listContacts`(`transport`: AuthenticatedTransportFfi): List<String>
    
    /**
     * Get the list of registered payment methods.
     */
    fun `listMethods`(): List<String>
    
    /**
     * Parse a payment message from JSON.
     *
     * # Arguments
     *
     * * `json` - The JSON string to parse
     */
    fun `parseNoisePaymentMessage`(`json`: String): NoisePaymentMessage
    
    /**
     * Parse receipt metadata as JSON.
     */
    fun `parseReceiptMetadata`(`metadataJson`: String): String
    
    /**
     * Parse scanned QR code data as a Paykit URI.
     */
    fun `parseScannedQr`(`scannedData`: String): ScannedUri
    
    /**
     * Publish a Noise endpoint to the directory.
     *
     * Makes this device discoverable for receiving payments via Noise protocol.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     * * `host` - Host address where the Noise server is listening
     * * `port` - Port number where the Noise server is listening
     * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
     * * `metadata` - Optional metadata about the endpoint
     */
    fun `publishNoiseEndpoint`(`transport`: AuthenticatedTransportFfi, `host`: String, `port`: UShort, `noisePubkey`: String, `metadata`: String?)
    
    /**
     * Publish a payment endpoint to the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint_data` - The endpoint data to publish
     *
     * # Example
     *
     * ```ignore
     * let transport = AuthenticatedTransportFFI::from_session_json(session, pubkey)?;
     * client.publish_payment_endpoint(transport, "lightning", "lnbc1...")?;
     * ```
     */
    fun `publishPaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: String, `endpointData`: String)
    
    /**
     * Remove a contact from the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to remove
     */
    fun `removeContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: String)
    
    /**
     * Remove the Noise endpoint from the directory.
     *
     * Makes this device no longer discoverable for Noise payments.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     */
    fun `removeNoiseEndpoint`(`transport`: AuthenticatedTransportFfi)
    
    /**
     * Remove a payment endpoint from the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier to remove
     */
    fun `removePaymentEndpointFromDirectory`(`transport`: AuthenticatedTransportFfi, `methodId`: String)
    
    /**
     * Select the best payment method from supported options.
     */
    fun `selectMethod`(`supportedMethods`: List<PaymentMethod>, `amountSats`: ULong, `preferences`: SelectionPreferences?): SelectionResult
    
    /**
     * Validate an endpoint for a specific method.
     */
    fun `validateEndpoint`(`methodId`: String, `endpoint`: String): Boolean
    
    companion object
}

/**
 * Main Paykit client for mobile applications.
 */
open class PaykitClient : FFIObject, PaykitClientInterface {

    constructor(pointer: Pointer): super(pointer)

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    constructor(noPointer: NoPointer): super(noPointer)
    /**
     * Create a new Paykit client.
     */
    constructor() :
        this(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_paykitclient_new(_status)
})

    override val cleanable: UniffiCleaner.Cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_paykitclient(ptr, status)
                }
            }
        }
    }

    override fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_paykitclient(pointer!!, status)
        }
    }

    
    /**
     * Add a contact to the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to add
     */
    @Throws(PaykitMobileException::class)override fun `addContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_add_contact(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`contactPubkey`),
        _status)
}
        }
    
    
    
    /**
     * Calculate proration for a subscription modification.
     */
    @Throws(PaykitMobileException::class)override fun `calculateProration`(`currentAmountSats`: Long, `newAmountSats`: Long, `periodStart`: Long, `periodEnd`: Long, `changeDate`: Long): ProrationResult =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_calculate_proration(it,
        FfiConverterLong.lower(`currentAmountSats`),FfiConverterLong.lower(`newAmountSats`),FfiConverterLong.lower(`periodStart`),FfiConverterLong.lower(`periodEnd`),FfiConverterLong.lower(`changeDate`),
        _status)
}
        }.let {
            FfiConverterTypeProrationResult.lift(it)
        }
    
    
    /**
     * Check health of all payment methods.
     */override fun `checkHealth`(): List<HealthCheckResult> =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_check_health(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeHealthCheckResult.lift(it)
        }
    
    
    /**
     * Create an error message for Noise channel.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error description
     */
    @Throws(PaykitMobileException::class)override fun `createNoiseErrorMessage`(`code`: String, `message`: String): NoisePaymentMessage =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_noise_error_message(it,
        FfiConverterString.lower(`code`),FfiConverterString.lower(`message`),
        _status)
}
        }.let {
            FfiConverterTypeNoisePaymentMessage.lift(it)
        }
    
    
    /**
     * Create a payment request.
     */
    @Throws(PaykitMobileException::class)override fun `createPaymentRequest`(`fromPubkey`: String, `toPubkey`: String, `amountSats`: Long, `currency`: String, `methodId`: String, `description`: String, `expiresInSecs`: ULong?): PaymentRequest =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_payment_request(it,
        FfiConverterString.lower(`fromPubkey`),FfiConverterString.lower(`toPubkey`),FfiConverterLong.lower(`amountSats`),FfiConverterString.lower(`currency`),FfiConverterString.lower(`methodId`),FfiConverterString.lower(`description`),FfiConverterOptionalULong.lower(`expiresInSecs`),
        _status)
}
        }.let {
            FfiConverterTypePaymentRequest.lift(it)
        }
    
    
    /**
     * Create a new receipt.
     */
    @Throws(PaykitMobileException::class)override fun `createReceipt`(`payer`: String, `payee`: String, `methodId`: String, `amount`: String?, `currency`: String?): Receipt =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_receipt(it,
        FfiConverterString.lower(`payer`),FfiConverterString.lower(`payee`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),
        _status)
}
        }.let {
            FfiConverterTypeReceipt.lift(it)
        }
    
    
    /**
     * Create a receipt confirmation message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - The receipt ID being confirmed
     * * `payer_pubkey` - Payer's public key
     * * `payee_pubkey` - Payee's public key
     * * `method_id` - Payment method used
     * * `amount` - Payment amount
     * * `currency` - Currency code
     * * `signature` - Optional signature from payee
     */
    @Throws(PaykitMobileException::class)override fun `createReceiptConfirmationMessage`(`receiptId`: String, `payerPubkey`: String, `payeePubkey`: String, `methodId`: String, `amount`: String?, `currency`: String?, `signature`: String?): NoisePaymentMessage =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_confirmation_message(it,
        FfiConverterString.lower(`receiptId`),FfiConverterString.lower(`payerPubkey`),FfiConverterString.lower(`payeePubkey`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),FfiConverterOptionalString.lower(`signature`),
        _status)
}
        }.let {
            FfiConverterTypeNoisePaymentMessage.lift(it)
        }
    
    
    /**
     * Create a receipt request message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - Unique identifier for this receipt
     * * `payer_pubkey` - Payer's public key (z-base32)
     * * `payee_pubkey` - Payee's public key (z-base32)
     * * `method_id` - Payment method identifier
     * * `amount` - Optional payment amount
     * * `currency` - Optional currency code
     */
    @Throws(PaykitMobileException::class)override fun `createReceiptRequestMessage`(`receiptId`: String, `payerPubkey`: String, `payeePubkey`: String, `methodId`: String, `amount`: String?, `currency`: String?): NoisePaymentMessage =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_request_message(it,
        FfiConverterString.lower(`receiptId`),FfiConverterString.lower(`payerPubkey`),FfiConverterString.lower(`payeePubkey`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),
        _status)
}
        }.let {
            FfiConverterTypeNoisePaymentMessage.lift(it)
        }
    
    
    /**
     * Create a new subscription.
     */
    @Throws(PaykitMobileException::class)override fun `createSubscription`(`subscriber`: String, `provider`: String, `terms`: SubscriptionTerms): Subscription =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_subscription(it,
        FfiConverterString.lower(`subscriber`),FfiConverterString.lower(`provider`),FfiConverterTypeSubscriptionTerms.lower(`terms`),
        _status)
}
        }.let {
            FfiConverterTypeSubscription.lift(it)
        }
    
    
    /**
     * Get days remaining in current billing period.
     */override fun `daysRemainingInPeriod`(`periodEnd`: Long): UInt =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_days_remaining_in_period(it,
        FfiConverterLong.lower(`periodEnd`),
        _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    
    
    /**
     * Discover a Noise endpoint for a recipient.
     *
     * Queries the recipient's public directory for their Noise server information.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The noise endpoint info if found, None otherwise.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * if let Some(endpoint) = client.discover_noise_endpoint(transport, "8pinxxgqs41...")? {
     * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
     * }
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `discoverNoiseEndpoint`(`transport`: UnauthenticatedTransportFfi, `recipientPubkey`: String): NoiseEndpointInfo? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_discover_noise_endpoint(it,
        FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`recipientPubkey`),
        _status)
}
        }.let {
            FfiConverterOptionalTypeNoiseEndpointInfo.lift(it)
        }
    
    
    /**
     * Extract public key from scanned QR code.
     */override fun `extractKeyFromQr`(`scannedData`: String): String? =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_extract_key_from_qr(it,
        FfiConverterString.lower(`scannedData`),
        _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    
    
    /**
     * Extract payment method from scanned QR code.
     */override fun `extractMethodFromQr`(`scannedData`: String): String? =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_extract_method_from_qr(it,
        FfiConverterString.lower(`scannedData`),
        _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    
    
    /**
     * Fetch known contacts for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     *
     * # Returns
     *
     * List of contact public keys.
     */
    @Throws(PaykitMobileException::class)override fun `fetchKnownContacts`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String): List<String> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_fetch_known_contacts(it,
        FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),
        _status)
}
        }.let {
            FfiConverterSequenceString.lift(it)
        }
    
    
    /**
     * Fetch a specific payment endpoint for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     * * `method_id` - The payment method to fetch
     *
     * # Returns
     *
     * The endpoint data if found, None otherwise.
     */
    @Throws(PaykitMobileException::class)override fun `fetchPaymentEndpoint`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String, `methodId`: String): String? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_fetch_payment_endpoint(it,
        FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),FfiConverterString.lower(`methodId`),
        _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    
    
    /**
     * Fetch all supported payment methods for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query (z-base32 encoded)
     *
     * # Returns
     *
     * List of payment methods with their endpoints.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * let methods = client.fetch_supported_payments(transport, "8pinxxgqs41...")?;
     * for method in methods {
     * println!("{}: {}", method.method_id, method.endpoint);
     * }
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `fetchSupportedPayments`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: String): List<PaymentMethod> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_fetch_supported_payments(it,
        FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),
        _status)
}
        }.let {
            FfiConverterSequenceTypePaymentMethod.lift(it)
        }
    
    
    /**
     * Get health status of a specific method.
     */override fun `getHealthStatus`(`methodId`: String): HealthStatus? =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_get_health_status(it,
        FfiConverterString.lower(`methodId`),
        _status)
}
        }.let {
            FfiConverterOptionalTypeHealthStatus.lift(it)
        }
    
    
    /**
     * Get all in-progress payments.
     */override fun `getInProgressPayments`(): List<PaymentStatusInfo> =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_get_in_progress_payments(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypePaymentStatusInfo.lift(it)
        }
    
    
    /**
     * Get payment status for a receipt.
     */override fun `getPaymentStatus`(`receiptId`: String): PaymentStatusInfo? =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_get_payment_status(it,
        FfiConverterString.lower(`receiptId`),
        _status)
}
        }.let {
            FfiConverterOptionalTypePaymentStatusInfo.lift(it)
        }
    
    
    /**
     * Check if a method is usable (healthy or degraded).
     */override fun `isMethodUsable`(`methodId`: String): Boolean =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_is_method_usable(it,
        FfiConverterString.lower(`methodId`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    
    /**
     * Check if scanned data looks like a Paykit URI.
     */override fun `isPaykitQr`(`scannedData`: String): Boolean =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_is_paykit_qr(it,
        FfiConverterString.lower(`scannedData`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    
    /**
     * List all contacts.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     *
     * # Returns
     *
     * List of contact public keys.
     */
    @Throws(PaykitMobileException::class)override fun `listContacts`(`transport`: AuthenticatedTransportFfi): List<String> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_list_contacts(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),
        _status)
}
        }.let {
            FfiConverterSequenceString.lift(it)
        }
    
    
    /**
     * Get the list of registered payment methods.
     */override fun `listMethods`(): List<String> =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_list_methods(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceString.lift(it)
        }
    
    
    /**
     * Parse a payment message from JSON.
     *
     * # Arguments
     *
     * * `json` - The JSON string to parse
     */
    @Throws(PaykitMobileException::class)override fun `parseNoisePaymentMessage`(`json`: String): NoisePaymentMessage =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_parse_noise_payment_message(it,
        FfiConverterString.lower(`json`),
        _status)
}
        }.let {
            FfiConverterTypeNoisePaymentMessage.lift(it)
        }
    
    
    /**
     * Parse receipt metadata as JSON.
     */
    @Throws(PaykitMobileException::class)override fun `parseReceiptMetadata`(`metadataJson`: String): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_parse_receipt_metadata(it,
        FfiConverterString.lower(`metadataJson`),
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Parse scanned QR code data as a Paykit URI.
     */
    @Throws(PaykitMobileException::class)override fun `parseScannedQr`(`scannedData`: String): ScannedUri =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_parse_scanned_qr(it,
        FfiConverterString.lower(`scannedData`),
        _status)
}
        }.let {
            FfiConverterTypeScannedUri.lift(it)
        }
    
    
    /**
     * Publish a Noise endpoint to the directory.
     *
     * Makes this device discoverable for receiving payments via Noise protocol.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     * * `host` - Host address where the Noise server is listening
     * * `port` - Port number where the Noise server is listening
     * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
     * * `metadata` - Optional metadata about the endpoint
     */
    @Throws(PaykitMobileException::class)override fun `publishNoiseEndpoint`(`transport`: AuthenticatedTransportFfi, `host`: String, `port`: UShort, `noisePubkey`: String, `metadata`: String?) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_publish_noise_endpoint(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`host`),FfiConverterUShort.lower(`port`),FfiConverterString.lower(`noisePubkey`),FfiConverterOptionalString.lower(`metadata`),
        _status)
}
        }
    
    
    
    /**
     * Publish a payment endpoint to the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint_data` - The endpoint data to publish
     *
     * # Example
     *
     * ```ignore
     * let transport = AuthenticatedTransportFFI::from_session_json(session, pubkey)?;
     * client.publish_payment_endpoint(transport, "lightning", "lnbc1...")?;
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `publishPaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: String, `endpointData`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_publish_payment_endpoint(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpointData`),
        _status)
}
        }
    
    
    
    /**
     * Remove a contact from the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to remove
     */
    @Throws(PaykitMobileException::class)override fun `removeContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_remove_contact(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`contactPubkey`),
        _status)
}
        }
    
    
    
    /**
     * Remove the Noise endpoint from the directory.
     *
     * Makes this device no longer discoverable for Noise payments.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     */
    @Throws(PaykitMobileException::class)override fun `removeNoiseEndpoint`(`transport`: AuthenticatedTransportFfi) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_remove_noise_endpoint(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),
        _status)
}
        }
    
    
    
    /**
     * Remove a payment endpoint from the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier to remove
     */
    @Throws(PaykitMobileException::class)override fun `removePaymentEndpointFromDirectory`(`transport`: AuthenticatedTransportFfi, `methodId`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_remove_payment_endpoint_from_directory(it,
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`methodId`),
        _status)
}
        }
    
    
    
    /**
     * Select the best payment method from supported options.
     */
    @Throws(PaykitMobileException::class)override fun `selectMethod`(`supportedMethods`: List<PaymentMethod>, `amountSats`: ULong, `preferences`: SelectionPreferences?): SelectionResult =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_select_method(it,
        FfiConverterSequenceTypePaymentMethod.lower(`supportedMethods`),FfiConverterULong.lower(`amountSats`),FfiConverterOptionalTypeSelectionPreferences.lower(`preferences`),
        _status)
}
        }.let {
            FfiConverterTypeSelectionResult.lift(it)
        }
    
    
    /**
     * Validate an endpoint for a specific method.
     */
    @Throws(PaykitMobileException::class)override fun `validateEndpoint`(`methodId`: String, `endpoint`: String): Boolean =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_validate_endpoint(it,
        FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    

    
    companion object
    
}

public object FfiConverterTypePaykitClient: FfiConverter<PaykitClient, Pointer> {

    override fun lower(value: PaykitClient): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PaykitClient {
        return PaykitClient(value)
    }

    override fun read(buf: ByteBuffer): PaykitClient {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PaykitClient) = 8

    override fun write(value: PaykitClient, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}





/**
 * FFI wrapper for PaykitInteractiveManager.
 *
 * This provides a high-level interface for managing interactive payment flows
 * over Noise channels. Mobile apps use this to:
 *
 * 1. Process incoming messages and generate responses
 * 2. Initiate payment flows
 * 3. Manage receipts and private endpoints
 *
 * # Thread Safety
 *
 * This type is thread-safe and can be used from multiple threads.
 */
public interface PaykitInteractiveManagerFfiInterface {
    
    /**
     * Create a private endpoint offer message.
     *
     * Use this to offer a private payment endpoint to a peer.
     *
     * # Arguments
     *
     * * `method_id` - Payment method (e.g., "lightning")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice)
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    fun `createEndpointOffer`(`methodId`: String, `endpoint`: String): String
    
    /**
     * Create a payment request message to initiate a payment flow.
     *
     * Use this to create the initial message for requesting payment from a peer.
     *
     * # Arguments
     *
     * * `payer` - Your public key (the one paying)
     * * `payee` - The recipient's public key
     * * `method_id` - Payment method (e.g., "lightning", "onchain")
     * * `amount` - Optional amount (as string, e.g., "1000")
     * * `currency` - Optional currency code (e.g., "SAT")
     * * `metadata_json` - Optional JSON metadata
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    fun `createPaymentRequest`(`payer`: String, `payee`: String, `methodId`: String, `amount`: String?, `currency`: String?, `metadataJson`: String?): String
    
    /**
     * Get a private endpoint for a peer.
     */
    fun `getPrivateEndpoint`(`peer`: String, `methodId`: String): PrivateEndpointOffer?
    
    /**
     * Get a receipt by ID.
     */
    fun `getReceipt`(`receiptId`: String): ReceiptRequest?
    
    /**
     * Get the receipt store.
     */
    fun `getStore`(): ReceiptStore
    
    /**
     * Handle an incoming message from a peer.
     *
     * This processes a JSON message received over a Noise channel and returns
     * an optional response to send back.
     *
     * # Arguments
     *
     * * `message_json` - The JSON-encoded message from the Noise channel
     * * `peer_pubkey` - The public key of the peer who sent the message
     * * `my_pubkey` - Your own public key
     *
     * # Returns
     *
     * Optional JSON response to send back over the Noise channel.
     * Returns `None` for messages that don't require a response (e.g., Ack).
     *
     * # Example
     *
     * ```ignore
     * // In Swift/Kotlin
     * let response = manager.handleMessage(messageJson, peerPubkey, myPubkey)
     * if let responseJson = response {
     * noiseChannel.send(responseJson)
     * }
     * ```
     */
    fun `handleMessage`(`messageJson`: String, `peerPubkey`: String, `myPubkey`: String): String?
    
    /**
     * Handle a payment confirmation response.
     *
     * Call this when you receive a response to your payment request.
     * It validates the response and saves the confirmed receipt.
     *
     * # Arguments
     *
     * * `response_json` - The JSON response from the Noise channel
     * * `original_receipt_id` - The receipt ID from your original request
     *
     * # Returns
     *
     * The confirmed receipt if successful, or an error.
     */
    fun `handlePaymentResponse`(`responseJson`: String, `originalReceiptId`: String): ReceiptRequest
    
    /**
     * List all private endpoints for a peer.
     */
    fun `listPrivateEndpoints`(`peer`: String): List<PrivateEndpointOffer>
    
    /**
     * List all receipts.
     */
    fun `listReceipts`(): List<ReceiptRequest>
    
    /**
     * Set the receipt generator callback.
     *
     * This must be called before handling receipt requests.
     *
     * # Arguments
     *
     * * `generator` - Callback for generating receipts (implement in Swift/Kotlin)
     *
     * # Errors
     *
     * Returns an error if the internal lock is poisoned.
     */
    fun `setGenerator`(`generator`: ReceiptGeneratorCallback)
    
    companion object
}

/**
 * FFI wrapper for PaykitInteractiveManager.
 *
 * This provides a high-level interface for managing interactive payment flows
 * over Noise channels. Mobile apps use this to:
 *
 * 1. Process incoming messages and generate responses
 * 2. Initiate payment flows
 * 3. Manage receipts and private endpoints
 *
 * # Thread Safety
 *
 * This type is thread-safe and can be used from multiple threads.
 */
open class PaykitInteractiveManagerFfi : FFIObject, PaykitInteractiveManagerFfiInterface {

    constructor(pointer: Pointer): super(pointer)

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    constructor(noPointer: NoPointer): super(noPointer)
    /**
     * Create a new interactive manager without a generator.
     *
     * Use `set_generator` to set the receipt generator callback.
     *
     * # Arguments
     *
     * * `store` - Receipt store for persistence
     */
    constructor(`store`: ReceiptStore) :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_paykitinteractivemanagerffi_new(FfiConverterTypeReceiptStore.lower(`store`),_status)
})

    override val cleanable: UniffiCleaner.Cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_paykitinteractivemanagerffi(ptr, status)
                }
            }
        }
    }

    override fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_paykitinteractivemanagerffi(pointer!!, status)
        }
    }

    
    /**
     * Create a private endpoint offer message.
     *
     * Use this to offer a private payment endpoint to a peer.
     *
     * # Arguments
     *
     * * `method_id` - Payment method (e.g., "lightning")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice)
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createEndpointOffer`(`methodId`: String, `endpoint`: String): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_endpoint_offer(it,
        FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Create a payment request message to initiate a payment flow.
     *
     * Use this to create the initial message for requesting payment from a peer.
     *
     * # Arguments
     *
     * * `payer` - Your public key (the one paying)
     * * `payee` - The recipient's public key
     * * `method_id` - Payment method (e.g., "lightning", "onchain")
     * * `amount` - Optional amount (as string, e.g., "1000")
     * * `currency` - Optional currency code (e.g., "SAT")
     * * `metadata_json` - Optional JSON metadata
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createPaymentRequest`(`payer`: String, `payee`: String, `methodId`: String, `amount`: String?, `currency`: String?, `metadataJson`: String?): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_payment_request(it,
        FfiConverterString.lower(`payer`),FfiConverterString.lower(`payee`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),FfiConverterOptionalString.lower(`metadataJson`),
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Get a private endpoint for a peer.
     */
    @Throws(PaykitMobileException::class)override fun `getPrivateEndpoint`(`peer`: String, `methodId`: String): PrivateEndpointOffer? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_private_endpoint(it,
        FfiConverterString.lower(`peer`),FfiConverterString.lower(`methodId`),
        _status)
}
        }.let {
            FfiConverterOptionalTypePrivateEndpointOffer.lift(it)
        }
    
    
    /**
     * Get a receipt by ID.
     */
    @Throws(PaykitMobileException::class)override fun `getReceipt`(`receiptId`: String): ReceiptRequest? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_receipt(it,
        FfiConverterString.lower(`receiptId`),
        _status)
}
        }.let {
            FfiConverterOptionalTypeReceiptRequest.lift(it)
        }
    
    
    /**
     * Get the receipt store.
     */override fun `getStore`(): ReceiptStore =
        callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_store(it,
        
        _status)
}
        }.let {
            FfiConverterTypeReceiptStore.lift(it)
        }
    
    
    /**
     * Handle an incoming message from a peer.
     *
     * This processes a JSON message received over a Noise channel and returns
     * an optional response to send back.
     *
     * # Arguments
     *
     * * `message_json` - The JSON-encoded message from the Noise channel
     * * `peer_pubkey` - The public key of the peer who sent the message
     * * `my_pubkey` - Your own public key
     *
     * # Returns
     *
     * Optional JSON response to send back over the Noise channel.
     * Returns `None` for messages that don't require a response (e.g., Ack).
     *
     * # Example
     *
     * ```ignore
     * // In Swift/Kotlin
     * let response = manager.handleMessage(messageJson, peerPubkey, myPubkey)
     * if let responseJson = response {
     * noiseChannel.send(responseJson)
     * }
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `handleMessage`(`messageJson`: String, `peerPubkey`: String, `myPubkey`: String): String? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_message(it,
        FfiConverterString.lower(`messageJson`),FfiConverterString.lower(`peerPubkey`),FfiConverterString.lower(`myPubkey`),
        _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    
    
    /**
     * Handle a payment confirmation response.
     *
     * Call this when you receive a response to your payment request.
     * It validates the response and saves the confirmed receipt.
     *
     * # Arguments
     *
     * * `response_json` - The JSON response from the Noise channel
     * * `original_receipt_id` - The receipt ID from your original request
     *
     * # Returns
     *
     * The confirmed receipt if successful, or an error.
     */
    @Throws(PaykitMobileException::class)override fun `handlePaymentResponse`(`responseJson`: String, `originalReceiptId`: String): ReceiptRequest =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_payment_response(it,
        FfiConverterString.lower(`responseJson`),FfiConverterString.lower(`originalReceiptId`),
        _status)
}
        }.let {
            FfiConverterTypeReceiptRequest.lift(it)
        }
    
    
    /**
     * List all private endpoints for a peer.
     */
    @Throws(PaykitMobileException::class)override fun `listPrivateEndpoints`(`peer`: String): List<PrivateEndpointOffer> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_private_endpoints(it,
        FfiConverterString.lower(`peer`),
        _status)
}
        }.let {
            FfiConverterSequenceTypePrivateEndpointOffer.lift(it)
        }
    
    
    /**
     * List all receipts.
     */
    @Throws(PaykitMobileException::class)override fun `listReceipts`(): List<ReceiptRequest> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_receipts(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeReceiptRequest.lift(it)
        }
    
    
    /**
     * Set the receipt generator callback.
     *
     * This must be called before handling receipt requests.
     *
     * # Arguments
     *
     * * `generator` - Callback for generating receipts (implement in Swift/Kotlin)
     *
     * # Errors
     *
     * Returns an error if the internal lock is poisoned.
     */
    @Throws(PaykitMobileException::class)override fun `setGenerator`(`generator`: ReceiptGeneratorCallback) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_set_generator(it,
        FfiConverterTypeReceiptGeneratorCallback.lower(`generator`),
        _status)
}
        }
    
    
    

    
    companion object
    
}

public object FfiConverterTypePaykitInteractiveManagerFFI: FfiConverter<PaykitInteractiveManagerFfi, Pointer> {

    override fun lower(value: PaykitInteractiveManagerFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PaykitInteractiveManagerFfi {
        return PaykitInteractiveManagerFfi(value)
    }

    override fun read(buf: ByteBuffer): PaykitInteractiveManagerFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PaykitInteractiveManagerFfi) = 8

    override fun write(value: PaykitInteractiveManagerFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}





/**
 * Builder for creating Paykit protocol messages.
 *
 * Use this to create JSON messages for sending over Noise channels.
 */
public interface PaykitMessageBuilderInterface {
    
    /**
     * Create an acknowledgment message.
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createAck`(): String
    
    /**
     * Create an endpoint offer message.
     *
     * # Arguments
     *
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice, Bitcoin address)
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createEndpointOffer`(`methodId`: String, `endpoint`: String): String
    
    /**
     * Create an error message.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error message
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createError`(`code`: String, `message`: String): String
    
    /**
     * Create a receipt confirmation message.
     *
     * # Arguments
     *
     * * `receipt` - The confirmed receipt details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createReceiptConfirm`(`receipt`: ReceiptRequest): String
    
    /**
     * Create a receipt request message.
     *
     * # Arguments
     *
     * * `request` - The receipt request details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createReceiptRequest`(`request`: ReceiptRequest): String
    
    /**
     * Get the message type from a JSON message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message
     *
     * # Returns
     *
     * The message type.
     */
    fun `getMessageType`(`messageJson`: String): PaykitMessageType
    
    /**
     * Parse a received message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message from Noise channel
     *
     * # Returns
     *
     * Parsed message for processing.
     */
    fun `parseMessage`(`messageJson`: String): ParsedMessage
    
    companion object
}

/**
 * Builder for creating Paykit protocol messages.
 *
 * Use this to create JSON messages for sending over Noise channels.
 */
open class PaykitMessageBuilder : FFIObject, PaykitMessageBuilderInterface {

    constructor(pointer: Pointer): super(pointer)

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    constructor(noPointer: NoPointer): super(noPointer)
    /**
     * Create a new message builder.
     */
    constructor() :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_paykitmessagebuilder_new(_status)
})

    override val cleanable: UniffiCleaner.Cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_paykitmessagebuilder(ptr, status)
                }
            }
        }
    }

    override fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_paykitmessagebuilder(pointer!!, status)
        }
    }

    
    /**
     * Create an acknowledgment message.
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createAck`(): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_ack(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Create an endpoint offer message.
     *
     * # Arguments
     *
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice, Bitcoin address)
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createEndpointOffer`(`methodId`: String, `endpoint`: String): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_endpoint_offer(it,
        FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Create an error message.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error message
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createError`(`code`: String, `message`: String): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_error(it,
        FfiConverterString.lower(`code`),FfiConverterString.lower(`message`),
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Create a receipt confirmation message.
     *
     * # Arguments
     *
     * * `receipt` - The confirmed receipt details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createReceiptConfirm`(`receipt`: ReceiptRequest): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_confirm(it,
        FfiConverterTypeReceiptRequest.lower(`receipt`),
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Create a receipt request message.
     *
     * # Arguments
     *
     * * `request` - The receipt request details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createReceiptRequest`(`request`: ReceiptRequest): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_request(it,
        FfiConverterTypeReceiptRequest.lower(`request`),
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Get the message type from a JSON message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message
     *
     * # Returns
     *
     * The message type.
     */
    @Throws(PaykitMobileException::class)override fun `getMessageType`(`messageJson`: String): PaykitMessageType =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_get_message_type(it,
        FfiConverterString.lower(`messageJson`),
        _status)
}
        }.let {
            FfiConverterTypePaykitMessageType.lift(it)
        }
    
    
    /**
     * Parse a received message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message from Noise channel
     *
     * # Returns
     *
     * Parsed message for processing.
     */
    @Throws(PaykitMobileException::class)override fun `parseMessage`(`messageJson`: String): ParsedMessage =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_parse_message(it,
        FfiConverterString.lower(`messageJson`),
        _status)
}
        }.let {
            FfiConverterTypeParsedMessage.lift(it)
        }
    
    

    
    companion object
    
}

public object FfiConverterTypePaykitMessageBuilder: FfiConverter<PaykitMessageBuilder, Pointer> {

    override fun lower(value: PaykitMessageBuilder): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PaykitMessageBuilder {
        return PaykitMessageBuilder(value)
    }

    override fun read(buf: ByteBuffer): PaykitMessageBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PaykitMessageBuilder) = 8

    override fun write(value: PaykitMessageBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}





/**
 * In-memory receipt storage for mobile.
 *
 * Stores receipts during a session. For persistence, mobile apps should
 * save receipts to their own storage (Keychain/SharedPreferences).
 */
public interface ReceiptStoreInterface {
    
    /**
     * Clear all stored data.
     */
    fun `clear`()
    
    /**
     * Delete a receipt.
     */
    fun `deleteReceipt`(`receiptId`: String)
    
    /**
     * Export all receipts as JSON.
     */
    fun `exportReceiptsJson`(): String
    
    /**
     * Get a private endpoint.
     */
    fun `getPrivateEndpoint`(`peer`: String, `methodId`: String): PrivateEndpointOffer?
    
    /**
     * Get a receipt by ID.
     */
    fun `getReceipt`(`receiptId`: String): ReceiptRequest?
    
    /**
     * Import receipts from JSON.
     */
    fun `importReceiptsJson`(`json`: String): UInt
    
    /**
     * List all private endpoints for a peer.
     */
    fun `listPrivateEndpoints`(`peer`: String): List<PrivateEndpointOffer>
    
    /**
     * List all receipts.
     */
    fun `listReceipts`(): List<ReceiptRequest>
    
    /**
     * Save a private endpoint.
     */
    fun `savePrivateEndpoint`(`peer`: String, `offer`: PrivateEndpointOffer)
    
    /**
     * Save a receipt.
     */
    fun `saveReceipt`(`receipt`: ReceiptRequest)
    
    companion object
}

/**
 * In-memory receipt storage for mobile.
 *
 * Stores receipts during a session. For persistence, mobile apps should
 * save receipts to their own storage (Keychain/SharedPreferences).
 */
open class ReceiptStore : FFIObject, ReceiptStoreInterface {

    constructor(pointer: Pointer): super(pointer)

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    constructor(noPointer: NoPointer): super(noPointer)
    /**
     * Create a new receipt store.
     */
    constructor() :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_receiptstore_new(_status)
})

    override val cleanable: UniffiCleaner.Cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_receiptstore(ptr, status)
                }
            }
        }
    }

    override fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_receiptstore(pointer!!, status)
        }
    }

    
    /**
     * Clear all stored data.
     */
    @Throws(PaykitMobileException::class)override fun `clear`() =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_clear(it,
        
        _status)
}
        }
    
    
    
    /**
     * Delete a receipt.
     */
    @Throws(PaykitMobileException::class)override fun `deleteReceipt`(`receiptId`: String) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_delete_receipt(it,
        FfiConverterString.lower(`receiptId`),
        _status)
}
        }
    
    
    
    /**
     * Export all receipts as JSON.
     */
    @Throws(PaykitMobileException::class)override fun `exportReceiptsJson`(): String =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_export_receipts_json(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    /**
     * Get a private endpoint.
     */
    @Throws(PaykitMobileException::class)override fun `getPrivateEndpoint`(`peer`: String, `methodId`: String): PrivateEndpointOffer? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_get_private_endpoint(it,
        FfiConverterString.lower(`peer`),FfiConverterString.lower(`methodId`),
        _status)
}
        }.let {
            FfiConverterOptionalTypePrivateEndpointOffer.lift(it)
        }
    
    
    /**
     * Get a receipt by ID.
     */
    @Throws(PaykitMobileException::class)override fun `getReceipt`(`receiptId`: String): ReceiptRequest? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_get_receipt(it,
        FfiConverterString.lower(`receiptId`),
        _status)
}
        }.let {
            FfiConverterOptionalTypeReceiptRequest.lift(it)
        }
    
    
    /**
     * Import receipts from JSON.
     */
    @Throws(PaykitMobileException::class)override fun `importReceiptsJson`(`json`: String): UInt =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_import_receipts_json(it,
        FfiConverterString.lower(`json`),
        _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    
    
    /**
     * List all private endpoints for a peer.
     */
    @Throws(PaykitMobileException::class)override fun `listPrivateEndpoints`(`peer`: String): List<PrivateEndpointOffer> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_list_private_endpoints(it,
        FfiConverterString.lower(`peer`),
        _status)
}
        }.let {
            FfiConverterSequenceTypePrivateEndpointOffer.lift(it)
        }
    
    
    /**
     * List all receipts.
     */
    @Throws(PaykitMobileException::class)override fun `listReceipts`(): List<ReceiptRequest> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_list_receipts(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeReceiptRequest.lift(it)
        }
    
    
    /**
     * Save a private endpoint.
     */
    @Throws(PaykitMobileException::class)override fun `savePrivateEndpoint`(`peer`: String, `offer`: PrivateEndpointOffer) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_save_private_endpoint(it,
        FfiConverterString.lower(`peer`),FfiConverterTypePrivateEndpointOffer.lower(`offer`),
        _status)
}
        }
    
    
    
    /**
     * Save a receipt.
     */
    @Throws(PaykitMobileException::class)override fun `saveReceipt`(`receipt`: ReceiptRequest) =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_save_receipt(it,
        FfiConverterTypeReceiptRequest.lower(`receipt`),
        _status)
}
        }
    
    
    

    
    companion object
    
}

public object FfiConverterTypeReceiptStore: FfiConverter<ReceiptStore, Pointer> {

    override fun lower(value: ReceiptStore): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ReceiptStore {
        return ReceiptStore(value)
    }

    override fun read(buf: ByteBuffer): ReceiptStore {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ReceiptStore) = 8

    override fun write(value: ReceiptStore, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}





/**
 * FFI wrapper for unauthenticated (read-only) transport operations.
 *
 * This wraps read-only access to public Pubky storage.
 * Mobile apps can use this to discover payment methods for other users.
 *
 * # Creating in Production
 *
 * Implement `PubkyUnauthenticatedStorageCallback` in Swift/Kotlin:
 *
 * ```swift
 * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
 * func get(ownerPubkey: String, path: String) -> StorageGetResult {
 * // Use Pubky SDK to read from public storage
 * let url = "pubky://\(ownerPubkey)\(path)"
 * if let content = try? pubkyClient.get(url) {
 * return StorageGetResult.ok(content: content)
 * }
 * return StorageGetResult.ok(content: nil) // Not found
 * }
 *
 * func list(ownerPubkey: String, prefix: String) -> StorageListResult {
 * // ... implement using Pubky SDK
 * }
 * }
 *
 * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
 * ```
 */
public interface UnauthenticatedTransportFfiInterface {
    
    /**
     * Get a file at the given path from a public key's storage.
     */
    fun `get`(`ownerPubkey`: String, `path`: String): String?
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    fun `isMock`(): Boolean
    
    /**
     * List files with a given prefix from a public key's storage.
     */
    fun `list`(`ownerPubkey`: String, `prefix`: String): List<String>
    
    companion object
}

/**
 * FFI wrapper for unauthenticated (read-only) transport operations.
 *
 * This wraps read-only access to public Pubky storage.
 * Mobile apps can use this to discover payment methods for other users.
 *
 * # Creating in Production
 *
 * Implement `PubkyUnauthenticatedStorageCallback` in Swift/Kotlin:
 *
 * ```swift
 * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
 * func get(ownerPubkey: String, path: String) -> StorageGetResult {
 * // Use Pubky SDK to read from public storage
 * let url = "pubky://\(ownerPubkey)\(path)"
 * if let content = try? pubkyClient.get(url) {
 * return StorageGetResult.ok(content: content)
 * }
 * return StorageGetResult.ok(content: nil) // Not found
 * }
 *
 * func list(ownerPubkey: String, prefix: String) -> StorageListResult {
 * // ... implement using Pubky SDK
 * }
 * }
 *
 * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
 * ```
 */
open class UnauthenticatedTransportFfi : FFIObject, UnauthenticatedTransportFfiInterface {

    constructor(pointer: Pointer): super(pointer)

    /**
     * This constructor can be used to instantiate a fake object.
     *
     * **WARNING: Any object instantiated with this constructor cannot be passed to an actual Rust-backed object.**
     * Since there isn't a backing [Pointer] the FFI lower functions will crash.
     * @param noPointer Placeholder value so we can have a constructor separate from the default empty one that may be
     *   implemented for classes extending [FFIObject].
     */
    constructor(noPointer: NoPointer): super(noPointer)

    override val cleanable: UniffiCleaner.Cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_unauthenticatedtransportffi(ptr, status)
                }
            }
        }
    }

    override fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_unauthenticatedtransportffi(pointer!!, status)
        }
    }

    
    /**
     * Get a file at the given path from a public key's storage.
     */
    @Throws(PaykitMobileException::class)override fun `get`(`ownerPubkey`: String, `path`: String): String? =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_get(it,
        FfiConverterString.lower(`ownerPubkey`),FfiConverterString.lower(`path`),
        _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    @Throws(PaykitMobileException::class)override fun `isMock`(): Boolean =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_is_mock(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    
    /**
     * List files with a given prefix from a public key's storage.
     */
    @Throws(PaykitMobileException::class)override fun `list`(`ownerPubkey`: String, `prefix`: String): List<String> =
        callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_list(it,
        FfiConverterString.lower(`ownerPubkey`),FfiConverterString.lower(`prefix`),
        _status)
}
        }.let {
            FfiConverterSequenceString.lift(it)
        }
    
    

    companion object {
        
    /**
     * Create unauthenticated transport that shares mock storage with an authenticated transport.
     *
     * Useful for testing when you want reads to see writes from the same session.
     *
     * # Note
     *
     * This only works with mock transports. For callback-based transports,
     * create a new `UnauthenticatedTransportFFI::from_callback()` that shares
     * the underlying Pubky client.
     */
        fun `fromAuthenticated`(`auth`: AuthenticatedTransportFfi): UnauthenticatedTransportFfi =
            UnauthenticatedTransportFfi(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_authenticated(FfiConverterTypeAuthenticatedTransportFFI.lower(`auth`),_status)
})
        
    /**
     * Create unauthenticated transport from a storage callback.
     *
     * # Arguments
     *
     * * `callback` - Storage callback implementing PubkyUnauthenticatedStorageCallback
     *
     * # Example (Swift)
     *
     * ```swift
     * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
     * func get(ownerPubkey: String, path: String) -> StorageGetResult {
     * // Use Pubky SDK to read from public storage
     * // ...
     * }
     * }
     *
     * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
     * ```
     */
        fun `fromCallback`(`callback`: PubkyUnauthenticatedStorageCallback): UnauthenticatedTransportFfi =
            UnauthenticatedTransportFfi(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_callback(FfiConverterTypePubkyUnauthenticatedStorageCallback.lower(`callback`),_status)
})
        
    /**
     * Create unauthenticated transport from Pubky SDK configuration.
     *
     * # Deprecated
     *
     * This method creates a mock transport. Use `from_callback()` for production.
     *
     * # Arguments
     *
     * * `config_json` - JSON configuration (validated but not used)
     */
        fun `fromConfigJson`(`configJson`: String): UnauthenticatedTransportFfi =
            UnauthenticatedTransportFfi(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_config_json(FfiConverterString.lower(`configJson`),_status)
})
        
    /**
     * Create a new unauthenticated transport for testing/development.
     *
     * Uses in-memory storage - no network calls are made.
     */
        fun `newMock`(): UnauthenticatedTransportFfi =
            UnauthenticatedTransportFfi(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_new_mock(_status)
})
        
    }
    
}

public object FfiConverterTypeUnauthenticatedTransportFFI: FfiConverter<UnauthenticatedTransportFfi, Pointer> {

    override fun lower(value: UnauthenticatedTransportFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): UnauthenticatedTransportFfi {
        return UnauthenticatedTransportFfi(value)
    }

    override fun read(buf: ByteBuffer): UnauthenticatedTransportFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: UnauthenticatedTransportFfi) = 8

    override fun write(value: UnauthenticatedTransportFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}



/**
 * Payment amount.
 */
data class Amount (
    var `value`: String, 
    var `currency`: String
) {
    
    companion object
}

public object FfiConverterTypeAmount: FfiConverterRustBuffer<Amount> {
    override fun read(buf: ByteBuffer): Amount {
        return Amount(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Amount) = (
            FfiConverterString.allocationSize(value.`value`) +
            FfiConverterString.allocationSize(value.`currency`)
    )

    override fun write(value: Amount, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
            FfiConverterString.write(value.`currency`, buf)
    }
}



/**
 * FFI-safe cached contact.
 */
data class CachedContactFfi (
    var `pubkey`: String, 
    var `name`: String?, 
    var `addedAt`: Long, 
    var `lastSyncedAt`: Long?
) {
    
    companion object
}

public object FfiConverterTypeCachedContactFFI: FfiConverterRustBuffer<CachedContactFfi> {
    override fun read(buf: ByteBuffer): CachedContactFfi {
        return CachedContactFfi(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalLong.read(buf),
        )
    }

    override fun allocationSize(value: CachedContactFfi) = (
            FfiConverterString.allocationSize(value.`pubkey`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterLong.allocationSize(value.`addedAt`) +
            FfiConverterOptionalLong.allocationSize(value.`lastSyncedAt`)
    )

    override fun write(value: CachedContactFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`pubkey`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterLong.write(value.`addedAt`, buf)
            FfiConverterOptionalLong.write(value.`lastSyncedAt`, buf)
    }
}



/**
 * Generated Ed25519 keypair for identity.
 */
data class Ed25519Keypair (
    /**
     * Secret key (seed) - 32 bytes, hex encoded.
     * SENSITIVE: Store securely, this is the root identity secret.
     */
    var `secretKeyHex`: String, 
    /**
     * Public key - 32 bytes, hex encoded.
     */
    var `publicKeyHex`: String, 
    /**
     * Public key in z-base32 format (pkarr format).
     */
    var `publicKeyZ32`: String
) {
    
    companion object
}

public object FfiConverterTypeEd25519Keypair: FfiConverterRustBuffer<Ed25519Keypair> {
    override fun read(buf: ByteBuffer): Ed25519Keypair {
        return Ed25519Keypair(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Ed25519Keypair) = (
            FfiConverterString.allocationSize(value.`secretKeyHex`) +
            FfiConverterString.allocationSize(value.`publicKeyHex`) +
            FfiConverterString.allocationSize(value.`publicKeyZ32`)
    )

    override fun write(value: Ed25519Keypair, buf: ByteBuffer) {
            FfiConverterString.write(value.`secretKeyHex`, buf)
            FfiConverterString.write(value.`publicKeyHex`, buf)
            FfiConverterString.write(value.`publicKeyZ32`, buf)
    }
}



/**
 * Endpoint data for a payment method.
 */
data class EndpointData (
    var `value`: String
) {
    
    companion object
}

public object FfiConverterTypeEndpointData: FfiConverterRustBuffer<EndpointData> {
    override fun read(buf: ByteBuffer): EndpointData {
        return EndpointData(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: EndpointData) = (
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: EndpointData, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
    }
}



/**
 * FFI-safe error message.
 */
data class ErrorMessage (
    var `code`: String, 
    var `message`: String
) {
    
    companion object
}

public object FfiConverterTypeErrorMessage: FfiConverterRustBuffer<ErrorMessage> {
    override fun read(buf: ByteBuffer): ErrorMessage {
        return ErrorMessage(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ErrorMessage) = (
            FfiConverterString.allocationSize(value.`code`) +
            FfiConverterString.allocationSize(value.`message`)
    )

    override fun write(value: ErrorMessage, buf: ByteBuffer) {
            FfiConverterString.write(value.`code`, buf)
            FfiConverterString.write(value.`message`, buf)
    }
}



/**
 * Health check result.
 */
data class HealthCheckResult (
    var `methodId`: String, 
    var `status`: HealthStatus, 
    var `checkedAt`: Long, 
    var `latencyMs`: ULong?, 
    var `error`: String?
) {
    
    companion object
}

public object FfiConverterTypeHealthCheckResult: FfiConverterRustBuffer<HealthCheckResult> {
    override fun read(buf: ByteBuffer): HealthCheckResult {
        return HealthCheckResult(
            FfiConverterString.read(buf),
            FfiConverterTypeHealthStatus.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: HealthCheckResult) = (
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterTypeHealthStatus.allocationSize(value.`status`) +
            FfiConverterLong.allocationSize(value.`checkedAt`) +
            FfiConverterOptionalULong.allocationSize(value.`latencyMs`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: HealthCheckResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterTypeHealthStatus.write(value.`status`, buf)
            FfiConverterLong.write(value.`checkedAt`, buf)
            FfiConverterOptionalULong.write(value.`latencyMs`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Encrypted key backup for export/import.
 */
data class KeyBackup (
    /**
     * Version of the backup format.
     */
    var `version`: UInt, 
    /**
     * Encrypted secret key (AES-GCM).
     */
    var `encryptedDataHex`: String, 
    /**
     * Salt for key derivation from password.
     */
    var `saltHex`: String, 
    /**
     * Nonce for AES-GCM.
     */
    var `nonceHex`: String, 
    /**
     * Public key (not encrypted, for identification).
     */
    var `publicKeyZ32`: String
) {
    
    companion object
}

public object FfiConverterTypeKeyBackup: FfiConverterRustBuffer<KeyBackup> {
    override fun read(buf: ByteBuffer): KeyBackup {
        return KeyBackup(
            FfiConverterUInt.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: KeyBackup) = (
            FfiConverterUInt.allocationSize(value.`version`) +
            FfiConverterString.allocationSize(value.`encryptedDataHex`) +
            FfiConverterString.allocationSize(value.`saltHex`) +
            FfiConverterString.allocationSize(value.`nonceHex`) +
            FfiConverterString.allocationSize(value.`publicKeyZ32`)
    )

    override fun write(value: KeyBackup, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`version`, buf)
            FfiConverterString.write(value.`encryptedDataHex`, buf)
            FfiConverterString.write(value.`saltHex`, buf)
            FfiConverterString.write(value.`nonceHex`, buf)
            FfiConverterString.write(value.`publicKeyZ32`, buf)
    }
}



/**
 * A payment method identifier.
 */
data class MethodId (
    var `value`: String
) {
    
    companion object
}

public object FfiConverterTypeMethodId: FfiConverterRustBuffer<MethodId> {
    override fun read(buf: ByteBuffer): MethodId {
        return MethodId(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: MethodId) = (
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: MethodId, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
    }
}



/**
 * Information about a Noise protocol endpoint for receiving payments.
 *
 * This is discovered from a recipient's public directory and contains
 * the connection information needed to establish a Noise session.
 */
data class NoiseEndpointInfo (
    /**
     * The recipient's public key (z-base32 encoded).
     */
    var `recipientPubkey`: String, 
    /**
     * Host address of the Noise server (IP or hostname).
     */
    var `host`: String, 
    /**
     * Port number of the Noise server.
     */
    var `port`: UShort, 
    /**
     * The server's Noise public key (X25519, hex encoded).
     * This is needed to verify the server during handshake.
     */
    var `serverNoisePubkey`: String, 
    /**
     * Optional metadata about the endpoint.
     */
    var `metadata`: String?
) {
    
    companion object
}

public object FfiConverterTypeNoiseEndpointInfo: FfiConverterRustBuffer<NoiseEndpointInfo> {
    override fun read(buf: ByteBuffer): NoiseEndpointInfo {
        return NoiseEndpointInfo(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUShort.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: NoiseEndpointInfo) = (
            FfiConverterString.allocationSize(value.`recipientPubkey`) +
            FfiConverterString.allocationSize(value.`host`) +
            FfiConverterUShort.allocationSize(value.`port`) +
            FfiConverterString.allocationSize(value.`serverNoisePubkey`) +
            FfiConverterOptionalString.allocationSize(value.`metadata`)
    )

    override fun write(value: NoiseEndpointInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`recipientPubkey`, buf)
            FfiConverterString.write(value.`host`, buf)
            FfiConverterUShort.write(value.`port`, buf)
            FfiConverterString.write(value.`serverNoisePubkey`, buf)
            FfiConverterOptionalString.write(value.`metadata`, buf)
    }
}



/**
 * Result of a Noise handshake operation.
 */
data class NoiseHandshakeResult (
    /**
     * Whether the handshake succeeded.
     */
    var `success`: Boolean, 
    /**
     * Session ID for this connection (if successful).
     */
    var `sessionId`: String?, 
    /**
     * Remote peer's public key (z-base32 encoded, if successful).
     */
    var `remotePubkey`: String?, 
    /**
     * Error message (if failed).
     */
    var `error`: String?
) {
    
    companion object
}

public object FfiConverterTypeNoiseHandshakeResult: FfiConverterRustBuffer<NoiseHandshakeResult> {
    override fun read(buf: ByteBuffer): NoiseHandshakeResult {
        return NoiseHandshakeResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: NoiseHandshakeResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalString.allocationSize(value.`sessionId`) +
            FfiConverterOptionalString.allocationSize(value.`remotePubkey`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: NoiseHandshakeResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalString.write(value.`sessionId`, buf)
            FfiConverterOptionalString.write(value.`remotePubkey`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * A payment message to send over Noise channel.
 */
data class NoisePaymentMessage (
    /**
     * Type of the message.
     */
    var `messageType`: NoisePaymentMessageType, 
    /**
     * JSON payload of the message.
     */
    var `payloadJson`: String
) {
    
    companion object
}

public object FfiConverterTypeNoisePaymentMessage: FfiConverterRustBuffer<NoisePaymentMessage> {
    override fun read(buf: ByteBuffer): NoisePaymentMessage {
        return NoisePaymentMessage(
            FfiConverterTypeNoisePaymentMessageType.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: NoisePaymentMessage) = (
            FfiConverterTypeNoisePaymentMessageType.allocationSize(value.`messageType`) +
            FfiConverterString.allocationSize(value.`payloadJson`)
    )

    override fun write(value: NoisePaymentMessage, buf: ByteBuffer) {
            FfiConverterTypeNoisePaymentMessageType.write(value.`messageType`, buf)
            FfiConverterString.write(value.`payloadJson`, buf)
    }
}



/**
 * Configuration for a Noise server (receiving payments).
 */
data class NoiseServerConfig (
    /**
     * The port to listen on (0 for auto-assign).
     */
    var `port`: UShort, 
    /**
     * Maximum number of concurrent connections.
     */
    var `maxConnections`: UInt, 
    /**
     * Connection timeout in seconds.
     */
    var `connectionTimeoutSecs`: UInt, 
    /**
     * Whether to automatically publish endpoint to directory.
     */
    var `autoPublish`: Boolean
) {
    
    companion object
}

public object FfiConverterTypeNoiseServerConfig: FfiConverterRustBuffer<NoiseServerConfig> {
    override fun read(buf: ByteBuffer): NoiseServerConfig {
        return NoiseServerConfig(
            FfiConverterUShort.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: NoiseServerConfig) = (
            FfiConverterUShort.allocationSize(value.`port`) +
            FfiConverterUInt.allocationSize(value.`maxConnections`) +
            FfiConverterUInt.allocationSize(value.`connectionTimeoutSecs`) +
            FfiConverterBoolean.allocationSize(value.`autoPublish`)
    )

    override fun write(value: NoiseServerConfig, buf: ByteBuffer) {
            FfiConverterUShort.write(value.`port`, buf)
            FfiConverterUInt.write(value.`maxConnections`, buf)
            FfiConverterUInt.write(value.`connectionTimeoutSecs`, buf)
            FfiConverterBoolean.write(value.`autoPublish`, buf)
    }
}



/**
 * Status of the Noise server.
 */
data class NoiseServerStatus (
    /**
     * Whether the server is currently running.
     */
    var `isRunning`: Boolean, 
    /**
     * The port the server is listening on (if running).
     */
    var `port`: UShort?, 
    /**
     * The server's Noise public key (X25519, hex encoded).
     */
    var `noisePubkey`: String, 
    /**
     * Number of active sessions.
     */
    var `activeSessions`: UInt, 
    /**
     * Total connections handled since start.
     */
    var `totalConnections`: ULong
) {
    
    companion object
}

public object FfiConverterTypeNoiseServerStatus: FfiConverterRustBuffer<NoiseServerStatus> {
    override fun read(buf: ByteBuffer): NoiseServerStatus {
        return NoiseServerStatus(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalUShort.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: NoiseServerStatus) = (
            FfiConverterBoolean.allocationSize(value.`isRunning`) +
            FfiConverterOptionalUShort.allocationSize(value.`port`) +
            FfiConverterString.allocationSize(value.`noisePubkey`) +
            FfiConverterUInt.allocationSize(value.`activeSessions`) +
            FfiConverterULong.allocationSize(value.`totalConnections`)
    )

    override fun write(value: NoiseServerStatus, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`isRunning`, buf)
            FfiConverterOptionalUShort.write(value.`port`, buf)
            FfiConverterString.write(value.`noisePubkey`, buf)
            FfiConverterUInt.write(value.`activeSessions`, buf)
            FfiConverterULong.write(value.`totalConnections`, buf)
    }
}



/**
 * Information about an active Noise session.
 */
data class NoiseSessionInfo (
    /**
     * Unique session identifier.
     */
    var `sessionId`: String, 
    /**
     * Remote peer's public key (z-base32 encoded).
     */
    var `remotePubkey`: String, 
    /**
     * When the session was established (unix timestamp).
     */
    var `establishedAt`: Long, 
    /**
     * Whether this is an incoming (server) or outgoing (client) session.
     */
    var `isIncoming`: Boolean, 
    /**
     * Number of messages sent in this session.
     */
    var `messagesSent`: ULong, 
    /**
     * Number of messages received in this session.
     */
    var `messagesReceived`: ULong
) {
    
    companion object
}

public object FfiConverterTypeNoiseSessionInfo: FfiConverterRustBuffer<NoiseSessionInfo> {
    override fun read(buf: ByteBuffer): NoiseSessionInfo {
        return NoiseSessionInfo(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: NoiseSessionInfo) = (
            FfiConverterString.allocationSize(value.`sessionId`) +
            FfiConverterString.allocationSize(value.`remotePubkey`) +
            FfiConverterLong.allocationSize(value.`establishedAt`) +
            FfiConverterBoolean.allocationSize(value.`isIncoming`) +
            FfiConverterULong.allocationSize(value.`messagesSent`) +
            FfiConverterULong.allocationSize(value.`messagesReceived`)
    )

    override fun write(value: NoiseSessionInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`sessionId`, buf)
            FfiConverterString.write(value.`remotePubkey`, buf)
            FfiConverterLong.write(value.`establishedAt`, buf)
            FfiConverterBoolean.write(value.`isIncoming`, buf)
            FfiConverterULong.write(value.`messagesSent`, buf)
            FfiConverterULong.write(value.`messagesReceived`, buf)
    }
}



/**
 * A supported payment method with its endpoint.
 */
data class PaymentMethod (
    var `methodId`: String, 
    var `endpoint`: String
) {
    
    companion object
}

public object FfiConverterTypePaymentMethod: FfiConverterRustBuffer<PaymentMethod> {
    override fun read(buf: ByteBuffer): PaymentMethod {
        return PaymentMethod(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentMethod) = (
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`)
    )

    override fun write(value: PaymentMethod, buf: ByteBuffer) {
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
    }
}



/**
 * Payment request.
 */
data class PaymentRequest (
    var `requestId`: String, 
    var `fromPubkey`: String, 
    var `toPubkey`: String, 
    var `amountSats`: Long, 
    var `currency`: String, 
    var `methodId`: String, 
    var `description`: String, 
    var `createdAt`: Long, 
    var `expiresAt`: Long?
) {
    
    companion object
}

public object FfiConverterTypePaymentRequest: FfiConverterRustBuffer<PaymentRequest> {
    override fun read(buf: ByteBuffer): PaymentRequest {
        return PaymentRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalLong.read(buf),
        )
    }

    override fun allocationSize(value: PaymentRequest) = (
            FfiConverterString.allocationSize(value.`requestId`) +
            FfiConverterString.allocationSize(value.`fromPubkey`) +
            FfiConverterString.allocationSize(value.`toPubkey`) +
            FfiConverterLong.allocationSize(value.`amountSats`) +
            FfiConverterString.allocationSize(value.`currency`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterLong.allocationSize(value.`createdAt`) +
            FfiConverterOptionalLong.allocationSize(value.`expiresAt`)
    )

    override fun write(value: PaymentRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`requestId`, buf)
            FfiConverterString.write(value.`fromPubkey`, buf)
            FfiConverterString.write(value.`toPubkey`, buf)
            FfiConverterLong.write(value.`amountSats`, buf)
            FfiConverterString.write(value.`currency`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`description`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
            FfiConverterOptionalLong.write(value.`expiresAt`, buf)
    }
}



/**
 * Payment status information.
 */
data class PaymentStatusInfo (
    var `status`: PaymentStatus, 
    var `receiptId`: String, 
    var `methodId`: String, 
    var `updatedAt`: Long, 
    var `confirmations`: ULong?, 
    var `requiredConfirmations`: ULong?, 
    var `error`: String?
) {
    
    companion object
}

public object FfiConverterTypePaymentStatusInfo: FfiConverterRustBuffer<PaymentStatusInfo> {
    override fun read(buf: ByteBuffer): PaymentStatusInfo {
        return PaymentStatusInfo(
            FfiConverterTypePaymentStatus.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentStatusInfo) = (
            FfiConverterTypePaymentStatus.allocationSize(value.`status`) +
            FfiConverterString.allocationSize(value.`receiptId`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterLong.allocationSize(value.`updatedAt`) +
            FfiConverterOptionalULong.allocationSize(value.`confirmations`) +
            FfiConverterOptionalULong.allocationSize(value.`requiredConfirmations`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: PaymentStatusInfo, buf: ByteBuffer) {
            FfiConverterTypePaymentStatus.write(value.`status`, buf)
            FfiConverterString.write(value.`receiptId`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterLong.write(value.`updatedAt`, buf)
            FfiConverterOptionalULong.write(value.`confirmations`, buf)
            FfiConverterOptionalULong.write(value.`requiredConfirmations`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Private endpoint information.
 */
data class PrivateEndpoint (
    var `peer`: String, 
    var `methodId`: String, 
    var `endpoint`: String, 
    var `createdAt`: Long, 
    var `expiresAt`: Long?
) {
    
    companion object
}

public object FfiConverterTypePrivateEndpoint: FfiConverterRustBuffer<PrivateEndpoint> {
    override fun read(buf: ByteBuffer): PrivateEndpoint {
        return PrivateEndpoint(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalLong.read(buf),
        )
    }

    override fun allocationSize(value: PrivateEndpoint) = (
            FfiConverterString.allocationSize(value.`peer`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`) +
            FfiConverterLong.allocationSize(value.`createdAt`) +
            FfiConverterOptionalLong.allocationSize(value.`expiresAt`)
    )

    override fun write(value: PrivateEndpoint, buf: ByteBuffer) {
            FfiConverterString.write(value.`peer`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
            FfiConverterOptionalLong.write(value.`expiresAt`, buf)
    }
}



/**
 * FFI-safe private endpoint offer.
 */
data class PrivateEndpointOffer (
    var `methodId`: String, 
    var `endpoint`: String
) {
    
    companion object
}

public object FfiConverterTypePrivateEndpointOffer: FfiConverterRustBuffer<PrivateEndpointOffer> {
    override fun read(buf: ByteBuffer): PrivateEndpointOffer {
        return PrivateEndpointOffer(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PrivateEndpointOffer) = (
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`)
    )

    override fun write(value: PrivateEndpointOffer, buf: ByteBuffer) {
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
    }
}



/**
 * Proration result.
 */
data class ProrationResult (
    var `creditSats`: Long, 
    var `chargeSats`: Long, 
    var `netSats`: Long, 
    var `isRefund`: Boolean
) {
    
    companion object
}

public object FfiConverterTypeProrationResult: FfiConverterRustBuffer<ProrationResult> {
    override fun read(buf: ByteBuffer): ProrationResult {
        return ProrationResult(
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ProrationResult) = (
            FfiConverterLong.allocationSize(value.`creditSats`) +
            FfiConverterLong.allocationSize(value.`chargeSats`) +
            FfiConverterLong.allocationSize(value.`netSats`) +
            FfiConverterBoolean.allocationSize(value.`isRefund`)
    )

    override fun write(value: ProrationResult, buf: ByteBuffer) {
            FfiConverterLong.write(value.`creditSats`, buf)
            FfiConverterLong.write(value.`chargeSats`, buf)
            FfiConverterLong.write(value.`netSats`, buf)
            FfiConverterBoolean.write(value.`isRefund`, buf)
    }
}



/**
 * Payment receipt.
 */
data class Receipt (
    var `receiptId`: String, 
    var `payer`: String, 
    var `payee`: String, 
    var `methodId`: String, 
    var `amount`: String?, 
    var `currency`: String?, 
    var `createdAt`: Long, 
    var `metadataJson`: String
) {
    
    companion object
}

public object FfiConverterTypeReceipt: FfiConverterRustBuffer<Receipt> {
    override fun read(buf: ByteBuffer): Receipt {
        return Receipt(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Receipt) = (
            FfiConverterString.allocationSize(value.`receiptId`) +
            FfiConverterString.allocationSize(value.`payer`) +
            FfiConverterString.allocationSize(value.`payee`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterOptionalString.allocationSize(value.`amount`) +
            FfiConverterOptionalString.allocationSize(value.`currency`) +
            FfiConverterLong.allocationSize(value.`createdAt`) +
            FfiConverterString.allocationSize(value.`metadataJson`)
    )

    override fun write(value: Receipt, buf: ByteBuffer) {
            FfiConverterString.write(value.`receiptId`, buf)
            FfiConverterString.write(value.`payer`, buf)
            FfiConverterString.write(value.`payee`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterOptionalString.write(value.`amount`, buf)
            FfiConverterOptionalString.write(value.`currency`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
            FfiConverterString.write(value.`metadataJson`, buf)
    }
}



/**
 * Result type for receipt generation.
 *
 * Used to communicate success/failure from mobile callbacks.
 */
data class ReceiptGenerationResult (
    /**
     * Whether generation succeeded
     */
    var `success`: Boolean, 
    /**
     * The generated receipt (if successful)
     */
    var `receipt`: ReceiptRequest?, 
    /**
     * Error message (if failed)
     */
    var `error`: String?
) {
    
    companion object
}

public object FfiConverterTypeReceiptGenerationResult: FfiConverterRustBuffer<ReceiptGenerationResult> {
    override fun read(buf: ByteBuffer): ReceiptGenerationResult {
        return ReceiptGenerationResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypeReceiptRequest.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ReceiptGenerationResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalTypeReceiptRequest.allocationSize(value.`receipt`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: ReceiptGenerationResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalTypeReceiptRequest.write(value.`receipt`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * FFI-safe receipt request.
 */
data class ReceiptRequest (
    var `receiptId`: String, 
    var `payer`: String, 
    var `payee`: String, 
    var `methodId`: String, 
    var `amount`: String?, 
    var `currency`: String?, 
    var `metadataJson`: String
) {
    
    companion object
}

public object FfiConverterTypeReceiptRequest: FfiConverterRustBuffer<ReceiptRequest> {
    override fun read(buf: ByteBuffer): ReceiptRequest {
        return ReceiptRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ReceiptRequest) = (
            FfiConverterString.allocationSize(value.`receiptId`) +
            FfiConverterString.allocationSize(value.`payer`) +
            FfiConverterString.allocationSize(value.`payee`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterOptionalString.allocationSize(value.`amount`) +
            FfiConverterOptionalString.allocationSize(value.`currency`) +
            FfiConverterString.allocationSize(value.`metadataJson`)
    )

    override fun write(value: ReceiptRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`receiptId`, buf)
            FfiConverterString.write(value.`payer`, buf)
            FfiConverterString.write(value.`payee`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterOptionalString.write(value.`amount`, buf)
            FfiConverterOptionalString.write(value.`currency`, buf)
            FfiConverterString.write(value.`metadataJson`, buf)
    }
}



/**
 * Result of scanning a QR code.
 */
data class ScannedUri (
    /**
     * The type of URI that was scanned.
     */
    var `uriType`: UriType, 
    /**
     * The public key if this is a Pubky URI.
     */
    var `publicKey`: String?, 
    /**
     * The payment method if this is an Invoice URI.
     */
    var `methodId`: String?, 
    /**
     * The invoice/endpoint data.
     */
    var `data`: String?, 
    /**
     * The payment request ID if this is a PaymentRequest URI.
     */
    var `requestId`: String?, 
    /**
     * The requester's public key if this is a PaymentRequest URI.
     */
    var `requester`: String?
) {
    
    companion object
}

public object FfiConverterTypeScannedUri: FfiConverterRustBuffer<ScannedUri> {
    override fun read(buf: ByteBuffer): ScannedUri {
        return ScannedUri(
            FfiConverterTypeUriType.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ScannedUri) = (
            FfiConverterTypeUriType.allocationSize(value.`uriType`) +
            FfiConverterOptionalString.allocationSize(value.`publicKey`) +
            FfiConverterOptionalString.allocationSize(value.`methodId`) +
            FfiConverterOptionalString.allocationSize(value.`data`) +
            FfiConverterOptionalString.allocationSize(value.`requestId`) +
            FfiConverterOptionalString.allocationSize(value.`requester`)
    )

    override fun write(value: ScannedUri, buf: ByteBuffer) {
            FfiConverterTypeUriType.write(value.`uriType`, buf)
            FfiConverterOptionalString.write(value.`publicKey`, buf)
            FfiConverterOptionalString.write(value.`methodId`, buf)
            FfiConverterOptionalString.write(value.`data`, buf)
            FfiConverterOptionalString.write(value.`requestId`, buf)
            FfiConverterOptionalString.write(value.`requester`, buf)
    }
}



/**
 * Selection preferences.
 */
data class SelectionPreferences (
    var `strategy`: SelectionStrategy, 
    var `excludedMethods`: List<String>, 
    var `maxFeeSats`: ULong?, 
    var `maxConfirmationTimeSecs`: ULong?
) {
    
    companion object
}

public object FfiConverterTypeSelectionPreferences: FfiConverterRustBuffer<SelectionPreferences> {
    override fun read(buf: ByteBuffer): SelectionPreferences {
        return SelectionPreferences(
            FfiConverterTypeSelectionStrategy.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: SelectionPreferences) = (
            FfiConverterTypeSelectionStrategy.allocationSize(value.`strategy`) +
            FfiConverterSequenceString.allocationSize(value.`excludedMethods`) +
            FfiConverterOptionalULong.allocationSize(value.`maxFeeSats`) +
            FfiConverterOptionalULong.allocationSize(value.`maxConfirmationTimeSecs`)
    )

    override fun write(value: SelectionPreferences, buf: ByteBuffer) {
            FfiConverterTypeSelectionStrategy.write(value.`strategy`, buf)
            FfiConverterSequenceString.write(value.`excludedMethods`, buf)
            FfiConverterOptionalULong.write(value.`maxFeeSats`, buf)
            FfiConverterOptionalULong.write(value.`maxConfirmationTimeSecs`, buf)
    }
}



/**
 * Result of payment method selection.
 */
data class SelectionResult (
    var `primaryMethod`: String, 
    var `fallbackMethods`: List<String>, 
    var `reason`: String
) {
    
    companion object
}

public object FfiConverterTypeSelectionResult: FfiConverterRustBuffer<SelectionResult> {
    override fun read(buf: ByteBuffer): SelectionResult {
        return SelectionResult(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SelectionResult) = (
            FfiConverterString.allocationSize(value.`primaryMethod`) +
            FfiConverterSequenceString.allocationSize(value.`fallbackMethods`) +
            FfiConverterString.allocationSize(value.`reason`)
    )

    override fun write(value: SelectionResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`primaryMethod`, buf)
            FfiConverterSequenceString.write(value.`fallbackMethods`, buf)
            FfiConverterString.write(value.`reason`, buf)
    }
}



/**
 * Result type for storage get operations.
 */
data class StorageGetResult (
    /**
     * Whether the operation succeeded
     */
    var `success`: Boolean, 
    /**
     * The content if found (None if not found but successful)
     */
    var `content`: String?, 
    /**
     * Error message if failed
     */
    var `error`: String?
) {
    
    companion object
}

public object FfiConverterTypeStorageGetResult: FfiConverterRustBuffer<StorageGetResult> {
    override fun read(buf: ByteBuffer): StorageGetResult {
        return StorageGetResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: StorageGetResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalString.allocationSize(value.`content`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: StorageGetResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalString.write(value.`content`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Result type for storage list operations.
 */
data class StorageListResult (
    /**
     * Whether the operation succeeded
     */
    var `success`: Boolean, 
    /**
     * List of file names/paths
     */
    var `entries`: List<String>, 
    /**
     * Error message if failed
     */
    var `error`: String?
) {
    
    companion object
}

public object FfiConverterTypeStorageListResult: FfiConverterRustBuffer<StorageListResult> {
    override fun read(buf: ByteBuffer): StorageListResult {
        return StorageListResult(
            FfiConverterBoolean.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: StorageListResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterSequenceString.allocationSize(value.`entries`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: StorageListResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterSequenceString.write(value.`entries`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Result type for storage operations.
 */
data class StorageOperationResult (
    /**
     * Whether the operation succeeded
     */
    var `success`: Boolean, 
    /**
     * Error message if failed
     */
    var `error`: String?
) {
    
    companion object
}

public object FfiConverterTypeStorageOperationResult: FfiConverterRustBuffer<StorageOperationResult> {
    override fun read(buf: ByteBuffer): StorageOperationResult {
        return StorageOperationResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: StorageOperationResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: StorageOperationResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Subscription information.
 */
data class Subscription (
    var `subscriptionId`: String, 
    var `subscriber`: String, 
    var `provider`: String, 
    var `terms`: SubscriptionTerms, 
    var `createdAt`: Long, 
    var `startsAt`: Long, 
    var `endsAt`: Long?, 
    var `isActive`: Boolean
) {
    
    companion object
}

public object FfiConverterTypeSubscription: FfiConverterRustBuffer<Subscription> {
    override fun read(buf: ByteBuffer): Subscription {
        return Subscription(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeSubscriptionTerms.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalLong.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: Subscription) = (
            FfiConverterString.allocationSize(value.`subscriptionId`) +
            FfiConverterString.allocationSize(value.`subscriber`) +
            FfiConverterString.allocationSize(value.`provider`) +
            FfiConverterTypeSubscriptionTerms.allocationSize(value.`terms`) +
            FfiConverterLong.allocationSize(value.`createdAt`) +
            FfiConverterLong.allocationSize(value.`startsAt`) +
            FfiConverterOptionalLong.allocationSize(value.`endsAt`) +
            FfiConverterBoolean.allocationSize(value.`isActive`)
    )

    override fun write(value: Subscription, buf: ByteBuffer) {
            FfiConverterString.write(value.`subscriptionId`, buf)
            FfiConverterString.write(value.`subscriber`, buf)
            FfiConverterString.write(value.`provider`, buf)
            FfiConverterTypeSubscriptionTerms.write(value.`terms`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
            FfiConverterLong.write(value.`startsAt`, buf)
            FfiConverterOptionalLong.write(value.`endsAt`, buf)
            FfiConverterBoolean.write(value.`isActive`, buf)
    }
}



/**
 * Subscription terms.
 */
data class SubscriptionTerms (
    var `amountSats`: Long, 
    var `currency`: String, 
    var `frequency`: PaymentFrequency, 
    var `methodId`: String, 
    var `description`: String
) {
    
    companion object
}

public object FfiConverterTypeSubscriptionTerms: FfiConverterRustBuffer<SubscriptionTerms> {
    override fun read(buf: ByteBuffer): SubscriptionTerms {
        return SubscriptionTerms(
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypePaymentFrequency.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SubscriptionTerms) = (
            FfiConverterLong.allocationSize(value.`amountSats`) +
            FfiConverterString.allocationSize(value.`currency`) +
            FfiConverterTypePaymentFrequency.allocationSize(value.`frequency`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`description`)
    )

    override fun write(value: SubscriptionTerms, buf: ByteBuffer) {
            FfiConverterLong.write(value.`amountSats`, buf)
            FfiConverterString.write(value.`currency`, buf)
            FfiConverterTypePaymentFrequency.write(value.`frequency`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`description`, buf)
    }
}



/**
 * FFI-safe sync result.
 */
data class SyncResultFfi (
    var `total`: UInt, 
    var `added`: UInt, 
    var `removed`: UInt, 
    var `syncedAt`: Long
) {
    
    companion object
}

public object FfiConverterTypeSyncResultFFI: FfiConverterRustBuffer<SyncResultFfi> {
    override fun read(buf: ByteBuffer): SyncResultFfi {
        return SyncResultFfi(
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: SyncResultFfi) = (
            FfiConverterUInt.allocationSize(value.`total`) +
            FfiConverterUInt.allocationSize(value.`added`) +
            FfiConverterUInt.allocationSize(value.`removed`) +
            FfiConverterLong.allocationSize(value.`syncedAt`)
    )

    override fun write(value: SyncResultFfi, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`total`, buf)
            FfiConverterUInt.write(value.`added`, buf)
            FfiConverterUInt.write(value.`removed`, buf)
            FfiConverterLong.write(value.`syncedAt`, buf)
    }
}



/**
 * Derived X25519 keypair for Noise protocol.
 */
data class X25519Keypair (
    /**
     * Secret key - 32 bytes, hex encoded.
     */
    var `secretKeyHex`: String, 
    /**
     * Public key - 32 bytes, hex encoded.
     */
    var `publicKeyHex`: String, 
    /**
     * Device ID used for derivation.
     */
    var `deviceId`: String, 
    /**
     * Epoch used for derivation.
     */
    var `epoch`: UInt
) {
    
    companion object
}

public object FfiConverterTypeX25519Keypair: FfiConverterRustBuffer<X25519Keypair> {
    override fun read(buf: ByteBuffer): X25519Keypair {
        return X25519Keypair(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: X25519Keypair) = (
            FfiConverterString.allocationSize(value.`secretKeyHex`) +
            FfiConverterString.allocationSize(value.`publicKeyHex`) +
            FfiConverterString.allocationSize(value.`deviceId`) +
            FfiConverterUInt.allocationSize(value.`epoch`)
    )

    override fun write(value: X25519Keypair, buf: ByteBuffer) {
            FfiConverterString.write(value.`secretKeyHex`, buf)
            FfiConverterString.write(value.`publicKeyHex`, buf)
            FfiConverterString.write(value.`deviceId`, buf)
            FfiConverterUInt.write(value.`epoch`, buf)
    }
}



/**
 * Health status of a payment method.
 */
enum class HealthStatus {
    
    HEALTHY,
    DEGRADED,
    UNAVAILABLE,
    UNKNOWN;
    companion object
}

public object FfiConverterTypeHealthStatus: FfiConverterRustBuffer<HealthStatus> {
    override fun read(buf: ByteBuffer) = try {
        HealthStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: HealthStatus) = 4

    override fun write(value: HealthStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Modification type for subscriptions.
 */
sealed class ModificationType {
    
    data class Upgrade(
        
        val `newAmountSats`: Long, 
        
        val `effectiveDate`: Long
        ) : ModificationType() {
        companion object
    }
    
    data class Downgrade(
        
        val `newAmountSats`: Long, 
        
        val `effectiveDate`: Long
        ) : ModificationType() {
        companion object
    }
    
    data class ChangeMethod(
        
        val `newMethodId`: String
        ) : ModificationType() {
        companion object
    }
    
    data class ChangeBillingDate(
        
        val `newDay`: UByte
        ) : ModificationType() {
        companion object
    }
    
    data class Cancel(
        
        val `effectiveDate`: Long, 
        
        val `reason`: String?
        ) : ModificationType() {
        companion object
    }
    
    data class Pause(
        
        val `resumeDate`: Long
        ) : ModificationType() {
        companion object
    }
    
    object Resume : ModificationType()
    
    

    
    companion object
}

public object FfiConverterTypeModificationType : FfiConverterRustBuffer<ModificationType>{
    override fun read(buf: ByteBuffer): ModificationType {
        return when(buf.getInt()) {
            1 -> ModificationType.Upgrade(
                FfiConverterLong.read(buf),
                FfiConverterLong.read(buf),
                )
            2 -> ModificationType.Downgrade(
                FfiConverterLong.read(buf),
                FfiConverterLong.read(buf),
                )
            3 -> ModificationType.ChangeMethod(
                FfiConverterString.read(buf),
                )
            4 -> ModificationType.ChangeBillingDate(
                FfiConverterUByte.read(buf),
                )
            5 -> ModificationType.Cancel(
                FfiConverterLong.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            6 -> ModificationType.Pause(
                FfiConverterLong.read(buf),
                )
            7 -> ModificationType.Resume
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ModificationType) = when(value) {
        is ModificationType.Upgrade -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterLong.allocationSize(value.`newAmountSats`)
                + FfiConverterLong.allocationSize(value.`effectiveDate`)
            )
        }
        is ModificationType.Downgrade -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterLong.allocationSize(value.`newAmountSats`)
                + FfiConverterLong.allocationSize(value.`effectiveDate`)
            )
        }
        is ModificationType.ChangeMethod -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`newMethodId`)
            )
        }
        is ModificationType.ChangeBillingDate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`newDay`)
            )
        }
        is ModificationType.Cancel -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterLong.allocationSize(value.`effectiveDate`)
                + FfiConverterOptionalString.allocationSize(value.`reason`)
            )
        }
        is ModificationType.Pause -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterLong.allocationSize(value.`resumeDate`)
            )
        }
        is ModificationType.Resume -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
    }

    override fun write(value: ModificationType, buf: ByteBuffer) {
        when(value) {
            is ModificationType.Upgrade -> {
                buf.putInt(1)
                FfiConverterLong.write(value.`newAmountSats`, buf)
                FfiConverterLong.write(value.`effectiveDate`, buf)
                Unit
            }
            is ModificationType.Downgrade -> {
                buf.putInt(2)
                FfiConverterLong.write(value.`newAmountSats`, buf)
                FfiConverterLong.write(value.`effectiveDate`, buf)
                Unit
            }
            is ModificationType.ChangeMethod -> {
                buf.putInt(3)
                FfiConverterString.write(value.`newMethodId`, buf)
                Unit
            }
            is ModificationType.ChangeBillingDate -> {
                buf.putInt(4)
                FfiConverterUByte.write(value.`newDay`, buf)
                Unit
            }
            is ModificationType.Cancel -> {
                buf.putInt(5)
                FfiConverterLong.write(value.`effectiveDate`, buf)
                FfiConverterOptionalString.write(value.`reason`, buf)
                Unit
            }
            is ModificationType.Pause -> {
                buf.putInt(6)
                FfiConverterLong.write(value.`resumeDate`, buf)
                Unit
            }
            is ModificationType.Resume -> {
                buf.putInt(7)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Status of a Noise connection.
 */
enum class NoiseConnectionStatus {
    
    /**
     * Not connected.
     */
    DISCONNECTED,
    /**
     * Connecting to server.
     */
    CONNECTING,
    /**
     * Handshake in progress.
     */
    HANDSHAKING,
    /**
     * Connected and ready for communication.
     */
    CONNECTED,
    /**
     * Connection failed.
     */
    FAILED;
    companion object
}

public object FfiConverterTypeNoiseConnectionStatus: FfiConverterRustBuffer<NoiseConnectionStatus> {
    override fun read(buf: ByteBuffer) = try {
        NoiseConnectionStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: NoiseConnectionStatus) = 4

    override fun write(value: NoiseConnectionStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Type of payment message exchanged over Noise channel.
 */
enum class NoisePaymentMessageType {
    
    /**
     * Request a receipt for a payment.
     */
    RECEIPT_REQUEST,
    /**
     * Confirm receipt of payment.
     */
    RECEIPT_CONFIRMATION,
    /**
     * Offer a private endpoint.
     */
    PRIVATE_ENDPOINT_OFFER,
    /**
     * Error response.
     */
    ERROR,
    /**
     * Ping for connection keep-alive.
     */
    PING,
    /**
     * Pong response to ping.
     */
    PONG;
    companion object
}

public object FfiConverterTypeNoisePaymentMessageType: FfiConverterRustBuffer<NoisePaymentMessageType> {
    override fun read(buf: ByteBuffer) = try {
        NoisePaymentMessageType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: NoisePaymentMessageType) = 4

    override fun write(value: NoisePaymentMessageType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Parsed Paykit message.
 */
sealed class ParsedMessage {
    
    data class OfferPrivateEndpoint(
        
        val `offer`: PrivateEndpointOffer
        ) : ParsedMessage() {
        companion object
    }
    
    data class RequestReceipt(
        
        val `request`: ReceiptRequest
        ) : ParsedMessage() {
        companion object
    }
    
    data class ConfirmReceipt(
        
        val `receipt`: ReceiptRequest
        ) : ParsedMessage() {
        companion object
    }
    
    object Ack : ParsedMessage()
    
    
    data class Error(
        
        val `error`: ErrorMessage
        ) : ParsedMessage() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeParsedMessage : FfiConverterRustBuffer<ParsedMessage>{
    override fun read(buf: ByteBuffer): ParsedMessage {
        return when(buf.getInt()) {
            1 -> ParsedMessage.OfferPrivateEndpoint(
                FfiConverterTypePrivateEndpointOffer.read(buf),
                )
            2 -> ParsedMessage.RequestReceipt(
                FfiConverterTypeReceiptRequest.read(buf),
                )
            3 -> ParsedMessage.ConfirmReceipt(
                FfiConverterTypeReceiptRequest.read(buf),
                )
            4 -> ParsedMessage.Ack
            5 -> ParsedMessage.Error(
                FfiConverterTypeErrorMessage.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ParsedMessage) = when(value) {
        is ParsedMessage.OfferPrivateEndpoint -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypePrivateEndpointOffer.allocationSize(value.`offer`)
            )
        }
        is ParsedMessage.RequestReceipt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeReceiptRequest.allocationSize(value.`request`)
            )
        }
        is ParsedMessage.ConfirmReceipt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeReceiptRequest.allocationSize(value.`receipt`)
            )
        }
        is ParsedMessage.Ack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is ParsedMessage.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeErrorMessage.allocationSize(value.`error`)
            )
        }
    }

    override fun write(value: ParsedMessage, buf: ByteBuffer) {
        when(value) {
            is ParsedMessage.OfferPrivateEndpoint -> {
                buf.putInt(1)
                FfiConverterTypePrivateEndpointOffer.write(value.`offer`, buf)
                Unit
            }
            is ParsedMessage.RequestReceipt -> {
                buf.putInt(2)
                FfiConverterTypeReceiptRequest.write(value.`request`, buf)
                Unit
            }
            is ParsedMessage.ConfirmReceipt -> {
                buf.putInt(3)
                FfiConverterTypeReceiptRequest.write(value.`receipt`, buf)
                Unit
            }
            is ParsedMessage.Ack -> {
                buf.putInt(4)
                Unit
            }
            is ParsedMessage.Error -> {
                buf.putInt(5)
                FfiConverterTypeErrorMessage.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * FFI-safe Paykit message type.
 */
enum class PaykitMessageType {
    
    /**
     * Offer a private endpoint.
     */
    OFFER_PRIVATE_ENDPOINT,
    /**
     * Request a receipt.
     */
    REQUEST_RECEIPT,
    /**
     * Confirm a receipt.
     */
    CONFIRM_RECEIPT,
    /**
     * Acknowledgment.
     */
    ACK,
    /**
     * Error message.
     */
    ERROR;
    companion object
}

public object FfiConverterTypePaykitMessageType: FfiConverterRustBuffer<PaykitMessageType> {
    override fun read(buf: ByteBuffer) = try {
        PaykitMessageType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaykitMessageType) = 4

    override fun write(value: PaykitMessageType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * Mobile-friendly error type.
 */
sealed class PaykitMobileException: Exception() {
    
    /**
     * Transport layer error (network, I/O).
     */
    class Transport(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Validation error (invalid input, format).
     */
    class Validation(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Resource not found.
     */
    class NotFound(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Serialization/deserialization error.
     */
    class Serialization(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Internal error (unexpected state).
     */
    class Internal(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Network timeout error.
     */
    class NetworkTimeout(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Connection refused or failed.
     */
    class ConnectionException(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Authentication failed.
     */
    class AuthenticationException(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Session expired or invalid.
     */
    class SessionException(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Rate limit exceeded.
     */
    class RateLimitException(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    /**
     * Permission denied.
     */
    class PermissionDenied(
        
        val `message`: String
        ) : PaykitMobileException() {
        override val message
            get() = "message=${ `message` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PaykitMobileException> {
        override fun lift(error_buf: RustBuffer.ByValue): PaykitMobileException = FfiConverterTypePaykitMobileError.lift(error_buf)
    }

    
}

public object FfiConverterTypePaykitMobileError : FfiConverterRustBuffer<PaykitMobileException> {
    override fun read(buf: ByteBuffer): PaykitMobileException {
        

        return when(buf.getInt()) {
            1 -> PaykitMobileException.Transport(
                FfiConverterString.read(buf),
                )
            2 -> PaykitMobileException.Validation(
                FfiConverterString.read(buf),
                )
            3 -> PaykitMobileException.NotFound(
                FfiConverterString.read(buf),
                )
            4 -> PaykitMobileException.Serialization(
                FfiConverterString.read(buf),
                )
            5 -> PaykitMobileException.Internal(
                FfiConverterString.read(buf),
                )
            6 -> PaykitMobileException.NetworkTimeout(
                FfiConverterString.read(buf),
                )
            7 -> PaykitMobileException.ConnectionException(
                FfiConverterString.read(buf),
                )
            8 -> PaykitMobileException.AuthenticationException(
                FfiConverterString.read(buf),
                )
            9 -> PaykitMobileException.SessionException(
                FfiConverterString.read(buf),
                )
            10 -> PaykitMobileException.RateLimitException(
                FfiConverterString.read(buf),
                )
            11 -> PaykitMobileException.PermissionDenied(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PaykitMobileException): Int {
        return when(value) {
            is PaykitMobileException.Transport -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.Validation -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.NotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.Serialization -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.NetworkTimeout -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.ConnectionException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.AuthenticationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.SessionException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.RateLimitException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is PaykitMobileException.PermissionDenied -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
        }
    }

    override fun write(value: PaykitMobileException, buf: ByteBuffer) {
        when(value) {
            is PaykitMobileException.Transport -> {
                buf.putInt(1)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.Validation -> {
                buf.putInt(2)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.NotFound -> {
                buf.putInt(3)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.Serialization -> {
                buf.putInt(4)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.Internal -> {
                buf.putInt(5)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.NetworkTimeout -> {
                buf.putInt(6)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.ConnectionException -> {
                buf.putInt(7)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.AuthenticationException -> {
                buf.putInt(8)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.SessionException -> {
                buf.putInt(9)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.RateLimitException -> {
                buf.putInt(10)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is PaykitMobileException.PermissionDenied -> {
                buf.putInt(11)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * Payment frequency for subscriptions.
 */
sealed class PaymentFrequency {
    
    object Daily : PaymentFrequency()
    
    
    object Weekly : PaymentFrequency()
    
    
    data class Monthly(
        
        val `dayOfMonth`: UByte
        ) : PaymentFrequency() {
        companion object
    }
    
    data class Yearly(
        
        val `month`: UByte, 
        
        val `day`: UByte
        ) : PaymentFrequency() {
        companion object
    }
    
    data class Custom(
        
        val `intervalSeconds`: ULong
        ) : PaymentFrequency() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypePaymentFrequency : FfiConverterRustBuffer<PaymentFrequency>{
    override fun read(buf: ByteBuffer): PaymentFrequency {
        return when(buf.getInt()) {
            1 -> PaymentFrequency.Daily
            2 -> PaymentFrequency.Weekly
            3 -> PaymentFrequency.Monthly(
                FfiConverterUByte.read(buf),
                )
            4 -> PaymentFrequency.Yearly(
                FfiConverterUByte.read(buf),
                FfiConverterUByte.read(buf),
                )
            5 -> PaymentFrequency.Custom(
                FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PaymentFrequency) = when(value) {
        is PaymentFrequency.Daily -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is PaymentFrequency.Weekly -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is PaymentFrequency.Monthly -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`dayOfMonth`)
            )
        }
        is PaymentFrequency.Yearly -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`month`)
                + FfiConverterUByte.allocationSize(value.`day`)
            )
        }
        is PaymentFrequency.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`intervalSeconds`)
            )
        }
    }

    override fun write(value: PaymentFrequency, buf: ByteBuffer) {
        when(value) {
            is PaymentFrequency.Daily -> {
                buf.putInt(1)
                Unit
            }
            is PaymentFrequency.Weekly -> {
                buf.putInt(2)
                Unit
            }
            is PaymentFrequency.Monthly -> {
                buf.putInt(3)
                FfiConverterUByte.write(value.`dayOfMonth`, buf)
                Unit
            }
            is PaymentFrequency.Yearly -> {
                buf.putInt(4)
                FfiConverterUByte.write(value.`month`, buf)
                FfiConverterUByte.write(value.`day`, buf)
                Unit
            }
            is PaymentFrequency.Custom -> {
                buf.putInt(5)
                FfiConverterULong.write(value.`intervalSeconds`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Payment status.
 */
enum class PaymentStatus {
    
    PENDING,
    PROCESSING,
    CONFIRMED,
    FINALIZED,
    FAILED,
    CANCELLED,
    EXPIRED;
    companion object
}

public object FfiConverterTypePaymentStatus: FfiConverterRustBuffer<PaymentStatus> {
    override fun read(buf: ByteBuffer) = try {
        PaymentStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaymentStatus) = 4

    override fun write(value: PaymentStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Payment request status.
 */
enum class RequestStatus {
    
    PENDING,
    ACCEPTED,
    DECLINED,
    EXPIRED,
    PAID;
    companion object
}

public object FfiConverterTypeRequestStatus: FfiConverterRustBuffer<RequestStatus> {
    override fun read(buf: ByteBuffer) = try {
        RequestStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RequestStatus) = 4

    override fun write(value: RequestStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Selection strategy.
 */
enum class SelectionStrategy {
    
    BALANCED,
    COST_OPTIMIZED,
    SPEED_OPTIMIZED,
    PRIVACY_OPTIMIZED;
    companion object
}

public object FfiConverterTypeSelectionStrategy: FfiConverterRustBuffer<SelectionStrategy> {
    override fun read(buf: ByteBuffer) = try {
        SelectionStrategy.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SelectionStrategy) = 4

    override fun write(value: SelectionStrategy, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * FFI-safe storage error type.
 */
sealed class StorageCacheException: Exception() {
    
    class Storage(
        
        val `message`: String
        ) : StorageCacheException() {
        override val message
            get() = "message=${ `message` }"
    }
    
    class Lock(
        
        val `message`: String
        ) : StorageCacheException() {
        override val message
            get() = "message=${ `message` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StorageCacheException> {
        override fun lift(error_buf: RustBuffer.ByValue): StorageCacheException = FfiConverterTypeStorageCacheError.lift(error_buf)
    }

    
}

public object FfiConverterTypeStorageCacheError : FfiConverterRustBuffer<StorageCacheException> {
    override fun read(buf: ByteBuffer): StorageCacheException {
        

        return when(buf.getInt()) {
            1 -> StorageCacheException.Storage(
                FfiConverterString.read(buf),
                )
            2 -> StorageCacheException.Lock(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StorageCacheException): Int {
        return when(value) {
            is StorageCacheException.Storage -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
            is StorageCacheException.Lock -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`message`)
            )
        }
    }

    override fun write(value: StorageCacheException, buf: ByteBuffer) {
        when(value) {
            is StorageCacheException.Storage -> {
                buf.putInt(1)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is StorageCacheException.Lock -> {
                buf.putInt(2)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * Type of scanned URI.
 */
enum class UriType {
    
    /**
     * A Pubky public key URI.
     */
    PUBKY,
    /**
     * An invoice URI (Lightning, Bitcoin, etc.).
     */
    INVOICE,
    /**
     * A payment request URI.
     */
    PAYMENT_REQUEST,
    /**
     * Unknown or invalid format.
     */
    UNKNOWN;
    companion object
}

public object FfiConverterTypeUriType: FfiConverterRustBuffer<UriType> {
    override fun read(buf: ByteBuffer) = try {
        UriType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: UriType) = 4

    override fun write(value: UriType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * Callback interface for authenticated Pubky storage operations.
 *
 * Mobile apps implement this to wrap their Pubky SDK session.
 * All operations are performed on the owner's storage.
 *
 * # Thread Safety
 *
 * Implementations must be thread-safe (Send + Sync).
 */
public interface PubkyAuthenticatedStorageCallback {
    
    /**
     * Put (create or update) content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path (e.g., "/pub/paykit.app/v0/lightning")
     * * `content` - Content to store
     */
    fun `put`(`path`: String, `content`: String): StorageOperationResult
    
    /**
     * Get content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path to read
     *
     * # Returns
     *
     * Content if found, None if path doesn't exist.
     */
    fun `get`(`path`: String): StorageGetResult
    
    /**
     * Delete content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path to delete
     */
    fun `delete`(`path`: String): StorageOperationResult
    
    /**
     * List files with the given prefix.
     *
     * # Arguments
     *
     * * `prefix` - Path prefix to list (e.g., "/pub/paykit.app/v0/")
     */
    fun `list`(`prefix`: String): StorageListResult
    
    companion object
}



internal typealias UniffiHandle = Long
internal class ConcurrentHandleMap<T>(
    private val leftMap: MutableMap<UniffiHandle, T> = mutableMapOf(),
) {
    private val lock = java.util.concurrent.locks.ReentrantLock()
    private val currentHandle = AtomicLong(0L)
    private val stride = 1L

    fun insert(obj: T): UniffiHandle =
        lock.withLock {
            currentHandle.getAndAdd(stride)
                .also { handle ->
                    leftMap[handle] = obj
                }
            }

    fun get(handle: UniffiHandle) = lock.withLock {
        leftMap[handle] ?: throw InternalException("No callback in handlemap; this is a Uniffi bug")
    }

    fun delete(handle: UniffiHandle) {
        this.remove(handle)
    }

    fun remove(handle: UniffiHandle): T? =
        lock.withLock {
            leftMap.remove(handle)
        }
}

interface ForeignCallback : com.sun.jna.Callback {
    public fun invoke(handle: UniffiHandle, method: Int, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

public abstract class FfiConverterCallbackInterface<CallbackInterface>: FfiConverter<CallbackInterface, UniffiHandle> {
    internal val handleMap = ConcurrentHandleMap<CallbackInterface>()

    internal fun drop(handle: UniffiHandle) {
        handleMap.remove(handle)
    }

    override fun lift(value: UniffiHandle): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}

// Implement the foreign callback handler for PubkyAuthenticatedStorageCallback
internal class UniffiCallbackInterfacePubkyAuthenticatedStorageCallback : ForeignCallback {
    @Suppress("TooGenericExceptionCaught")
    override fun invoke(handle: UniffiHandle, method: Int, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val cb = FfiConverterTypePubkyAuthenticatedStorageCallback.handleMap.get(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypePubkyAuthenticatedStorageCallback.handleMap.remove(handle)

                // Successful return
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
                UNIFFI_CALLBACK_SUCCESS
            }
            1 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokePut`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            2 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeGet`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            3 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeDelete`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            4 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeList`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            
            else -> {
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
                try {
                    // Try to serialize the error into a string
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                    // If that fails, then it's time to give up and just return
                }
                UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        }
    }

    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokePut`(kotlinCallbackInterface: PubkyAuthenticatedStorageCallback, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`put`(
                FfiConverterString.read(argsBuf)
                , 
                FfiConverterString.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeStorageOperationResult.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeGet`(kotlinCallbackInterface: PubkyAuthenticatedStorageCallback, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`get`(
                FfiConverterString.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeStorageGetResult.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeDelete`(kotlinCallbackInterface: PubkyAuthenticatedStorageCallback, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`delete`(
                FfiConverterString.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeStorageOperationResult.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeList`(kotlinCallbackInterface: PubkyAuthenticatedStorageCallback, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`list`(
                FfiConverterString.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeStorageListResult.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_paykit_mobile_fn_init_callback_pubkyauthenticatedstoragecallback(this)
    }
}

internal val uniffiCallbackInterfacePubkyAuthenticatedStorageCallback = UniffiCallbackInterfacePubkyAuthenticatedStorageCallback()

// The ffiConverter which transforms the Callbacks in to UniffiHandles to pass to Rust.
public object FfiConverterTypePubkyAuthenticatedStorageCallback: FfiConverterCallbackInterface<PubkyAuthenticatedStorageCallback>()





/**
 * Callback interface for unauthenticated (read-only) Pubky storage operations.
 *
 * Mobile apps implement this to wrap their Pubky SDK public storage.
 *
 * # Thread Safety
 *
 * Implementations must be thread-safe (Send + Sync).
 */
public interface PubkyUnauthenticatedStorageCallback {
    
    /**
     * Get content at the given path from another user's public storage.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     * * `path` - Storage path to read
     */
    fun `get`(`ownerPubkey`: String, `path`: String): StorageGetResult
    
    /**
     * List files with the given prefix from another user's public storage.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     * * `prefix` - Path prefix to list
     */
    fun `list`(`ownerPubkey`: String, `prefix`: String): StorageListResult
    
    companion object
}



// Implement the foreign callback handler for PubkyUnauthenticatedStorageCallback
internal class UniffiCallbackInterfacePubkyUnauthenticatedStorageCallback : ForeignCallback {
    @Suppress("TooGenericExceptionCaught")
    override fun invoke(handle: UniffiHandle, method: Int, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val cb = FfiConverterTypePubkyUnauthenticatedStorageCallback.handleMap.get(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypePubkyUnauthenticatedStorageCallback.handleMap.remove(handle)

                // Successful return
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
                UNIFFI_CALLBACK_SUCCESS
            }
            1 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeGet`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            2 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeList`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            
            else -> {
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
                try {
                    // Try to serialize the error into a string
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                    // If that fails, then it's time to give up and just return
                }
                UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        }
    }

    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeGet`(kotlinCallbackInterface: PubkyUnauthenticatedStorageCallback, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`get`(
                FfiConverterString.read(argsBuf)
                , 
                FfiConverterString.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeStorageGetResult.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeList`(kotlinCallbackInterface: PubkyUnauthenticatedStorageCallback, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`list`(
                FfiConverterString.read(argsBuf)
                , 
                FfiConverterString.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeStorageListResult.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_paykit_mobile_fn_init_callback_pubkyunauthenticatedstoragecallback(this)
    }
}

internal val uniffiCallbackInterfacePubkyUnauthenticatedStorageCallback = UniffiCallbackInterfacePubkyUnauthenticatedStorageCallback()

// The ffiConverter which transforms the Callbacks in to UniffiHandles to pass to Rust.
public object FfiConverterTypePubkyUnauthenticatedStorageCallback: FfiConverterCallbackInterface<PubkyUnauthenticatedStorageCallback>()





/**
 * Callback interface for mobile receipt generation.
 *
 * Mobile apps implement this to generate receipts (e.g., create Lightning invoices).
 * When a payment request is received, this callback is invoked to produce
 * the final receipt with payment endpoint.
 *
 * # Example (Swift)
 *
 * ```swift
 * class MyReceiptGenerator: ReceiptGeneratorCallback {
 * func generateReceipt(request: ReceiptRequest) -> ReceiptGenerationResult {
 * // Create Lightning invoice
 * let invoice = createInvoice(amount: request.amount)
 *
 * // Update receipt with invoice in metadata
 * var receipt = request
 * receipt.metadataJson = "{\"invoice\":\"\(invoice)\"}"
 *
 * return ReceiptGenerationResult.ok(receipt: receipt)
 * }
 * }
 * ```
 */
public interface ReceiptGeneratorCallback {
    
    /**
     * Generate a receipt for a payment request.
     *
     * # Arguments
     *
     * * `request` - The provisional receipt request from the payer
     *
     * # Returns
     *
     * A `ReceiptGenerationResult` with either the finalized receipt or an error.
     */
    fun `generateReceipt`(`request`: ReceiptRequest): ReceiptGenerationResult
    
    companion object
}



// Implement the foreign callback handler for ReceiptGeneratorCallback
internal class UniffiCallbackInterfaceReceiptGeneratorCallback : ForeignCallback {
    @Suppress("TooGenericExceptionCaught")
    override fun invoke(handle: UniffiHandle, method: Int, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val cb = FfiConverterTypeReceiptGeneratorCallback.handleMap.get(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypeReceiptGeneratorCallback.handleMap.remove(handle)

                // Successful return
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
                UNIFFI_CALLBACK_SUCCESS
            }
            1 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeGenerateReceipt`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            
            else -> {
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
                try {
                    // Try to serialize the error into a string
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                    // If that fails, then it's time to give up and just return
                }
                UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        }
    }

    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeGenerateReceipt`(kotlinCallbackInterface: ReceiptGeneratorCallback, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`generateReceipt`(
                FfiConverterTypeReceiptRequest.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeReceiptGenerationResult.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_paykit_mobile_fn_init_callback_receiptgeneratorcallback(this)
    }
}

internal val uniffiCallbackInterfaceReceiptGeneratorCallback = UniffiCallbackInterfaceReceiptGeneratorCallback()

// The ffiConverter which transforms the Callbacks in to UniffiHandles to pass to Rust.
public object FfiConverterTypeReceiptGeneratorCallback: FfiConverterCallbackInterface<ReceiptGeneratorCallback>()




public object FfiConverterOptionalUShort: FfiConverterRustBuffer<UShort?> {
    override fun read(buf: ByteBuffer): UShort? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUShort.read(buf)
    }

    override fun allocationSize(value: UShort?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterUShort.allocationSize(value)
        }
    }

    override fun write(value: UShort?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUShort.write(value, buf)
        }
    }
}




public object FfiConverterOptionalULong: FfiConverterRustBuffer<ULong?> {
    override fun read(buf: ByteBuffer): ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: ULong?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




public object FfiConverterOptionalLong: FfiConverterRustBuffer<Long?> {
    override fun read(buf: ByteBuffer): Long? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterLong.read(buf)
    }

    override fun allocationSize(value: Long?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterLong.allocationSize(value)
        }
    }

    override fun write(value: Long?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterLong.write(value, buf)
        }
    }
}




public object FfiConverterOptionalString: FfiConverterRustBuffer<String?> {
    override fun read(buf: ByteBuffer): String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: String?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeCachedContactFFI: FfiConverterRustBuffer<CachedContactFfi?> {
    override fun read(buf: ByteBuffer): CachedContactFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeCachedContactFFI.read(buf)
    }

    override fun allocationSize(value: CachedContactFfi?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeCachedContactFFI.allocationSize(value)
        }
    }

    override fun write(value: CachedContactFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeCachedContactFFI.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeNoiseEndpointInfo: FfiConverterRustBuffer<NoiseEndpointInfo?> {
    override fun read(buf: ByteBuffer): NoiseEndpointInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeNoiseEndpointInfo.read(buf)
    }

    override fun allocationSize(value: NoiseEndpointInfo?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeNoiseEndpointInfo.allocationSize(value)
        }
    }

    override fun write(value: NoiseEndpointInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeNoiseEndpointInfo.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypePaymentStatusInfo: FfiConverterRustBuffer<PaymentStatusInfo?> {
    override fun read(buf: ByteBuffer): PaymentStatusInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePaymentStatusInfo.read(buf)
    }

    override fun allocationSize(value: PaymentStatusInfo?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypePaymentStatusInfo.allocationSize(value)
        }
    }

    override fun write(value: PaymentStatusInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePaymentStatusInfo.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypePrivateEndpointOffer: FfiConverterRustBuffer<PrivateEndpointOffer?> {
    override fun read(buf: ByteBuffer): PrivateEndpointOffer? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePrivateEndpointOffer.read(buf)
    }

    override fun allocationSize(value: PrivateEndpointOffer?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypePrivateEndpointOffer.allocationSize(value)
        }
    }

    override fun write(value: PrivateEndpointOffer?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePrivateEndpointOffer.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeReceiptRequest: FfiConverterRustBuffer<ReceiptRequest?> {
    override fun read(buf: ByteBuffer): ReceiptRequest? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeReceiptRequest.read(buf)
    }

    override fun allocationSize(value: ReceiptRequest?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeReceiptRequest.allocationSize(value)
        }
    }

    override fun write(value: ReceiptRequest?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeReceiptRequest.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeSelectionPreferences: FfiConverterRustBuffer<SelectionPreferences?> {
    override fun read(buf: ByteBuffer): SelectionPreferences? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSelectionPreferences.read(buf)
    }

    override fun allocationSize(value: SelectionPreferences?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeSelectionPreferences.allocationSize(value)
        }
    }

    override fun write(value: SelectionPreferences?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSelectionPreferences.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeHealthStatus: FfiConverterRustBuffer<HealthStatus?> {
    override fun read(buf: ByteBuffer): HealthStatus? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeHealthStatus.read(buf)
    }

    override fun allocationSize(value: HealthStatus?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeHealthStatus.allocationSize(value)
        }
    }

    override fun write(value: HealthStatus?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeHealthStatus.write(value, buf)
        }
    }
}




public object FfiConverterSequenceString: FfiConverterRustBuffer<List<String>> {
    override fun read(buf: ByteBuffer): List<String> {
        val len = buf.getInt()
        return List<String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<String>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeCachedContactFFI: FfiConverterRustBuffer<List<CachedContactFfi>> {
    override fun read(buf: ByteBuffer): List<CachedContactFfi> {
        val len = buf.getInt()
        return List<CachedContactFfi>(len) {
            FfiConverterTypeCachedContactFFI.read(buf)
        }
    }

    override fun allocationSize(value: List<CachedContactFfi>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeCachedContactFFI.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<CachedContactFfi>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeCachedContactFFI.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeHealthCheckResult: FfiConverterRustBuffer<List<HealthCheckResult>> {
    override fun read(buf: ByteBuffer): List<HealthCheckResult> {
        val len = buf.getInt()
        return List<HealthCheckResult>(len) {
            FfiConverterTypeHealthCheckResult.read(buf)
        }
    }

    override fun allocationSize(value: List<HealthCheckResult>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeHealthCheckResult.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<HealthCheckResult>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeHealthCheckResult.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePaymentMethod: FfiConverterRustBuffer<List<PaymentMethod>> {
    override fun read(buf: ByteBuffer): List<PaymentMethod> {
        val len = buf.getInt()
        return List<PaymentMethod>(len) {
            FfiConverterTypePaymentMethod.read(buf)
        }
    }

    override fun allocationSize(value: List<PaymentMethod>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypePaymentMethod.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PaymentMethod>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypePaymentMethod.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePaymentStatusInfo: FfiConverterRustBuffer<List<PaymentStatusInfo>> {
    override fun read(buf: ByteBuffer): List<PaymentStatusInfo> {
        val len = buf.getInt()
        return List<PaymentStatusInfo>(len) {
            FfiConverterTypePaymentStatusInfo.read(buf)
        }
    }

    override fun allocationSize(value: List<PaymentStatusInfo>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypePaymentStatusInfo.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PaymentStatusInfo>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypePaymentStatusInfo.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePrivateEndpointOffer: FfiConverterRustBuffer<List<PrivateEndpointOffer>> {
    override fun read(buf: ByteBuffer): List<PrivateEndpointOffer> {
        val len = buf.getInt()
        return List<PrivateEndpointOffer>(len) {
            FfiConverterTypePrivateEndpointOffer.read(buf)
        }
    }

    override fun allocationSize(value: List<PrivateEndpointOffer>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypePrivateEndpointOffer.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PrivateEndpointOffer>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypePrivateEndpointOffer.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeReceiptRequest: FfiConverterRustBuffer<List<ReceiptRequest>> {
    override fun read(buf: ByteBuffer): List<ReceiptRequest> {
        val len = buf.getInt()
        return List<ReceiptRequest>(len) {
            FfiConverterTypeReceiptRequest.read(buf)
        }
    }

    override fun allocationSize(value: List<ReceiptRequest>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeReceiptRequest.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ReceiptRequest>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeReceiptRequest.write(it, buf)
        }
    }
}
        /**
         * Create a new contact cache.
         */

fun `createContactCache`(): ContactCacheFfi {
    return FfiConverterTypeContactCacheFFI.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_contact_cache(_status)
})
}

        /**
         * Create a new async directory operations manager.
         */
@Throws(PaykitMobileException::class)

fun `createDirectoryOperationsAsync`(): DirectoryOperationsAsync {
    return FfiConverterTypeDirectoryOperationsAsync.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_directory_operations_async(_status)
})
}

        /**
         * Create an error message.
         *
         * # Arguments
         *
         * * `code` - Error code
         * * `message` - Error description
         */
@Throws(PaykitMobileException::class)

fun `createErrorMessage`(`code`: String, `message`: String): NoisePaymentMessage {
    return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_error_message(FfiConverterString.lower(`code`),FfiConverterString.lower(`message`),_status)
})
}

        /**
         * Create a new interactive manager.
         */

fun `createInteractiveManager`(`store`: ReceiptStore): PaykitInteractiveManagerFfi {
    return FfiConverterTypePaykitInteractiveManagerFFI.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_interactive_manager(FfiConverterTypeReceiptStore.lower(`store`),_status)
})
}

        /**
         * Create a new message builder.
         */

fun `createMessageBuilder`(): PaykitMessageBuilder {
    return FfiConverterTypePaykitMessageBuilder.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_message_builder(_status)
})
}

        /**
         * Create a default noise server configuration.
         */

fun `createNoiseServerConfig`(): NoiseServerConfig {
    return FfiConverterTypeNoiseServerConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_noise_server_config(_status)
})
}

        /**
         * Create a noise server configuration with a specific port.
         */

fun `createNoiseServerConfigWithPort`(`port`: UShort): NoiseServerConfig {
    return FfiConverterTypeNoiseServerConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_noise_server_config_with_port(FfiConverterUShort.lower(`port`),_status)
})
}

        /**
         * Create a new Paykit client.
         */
@Throws(PaykitMobileException::class)

fun `createPaykitClient`(): PaykitClient {
    return FfiConverterTypePaykitClient.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_paykit_client(_status)
})
}

        /**
         * Create a private endpoint offer message.
         *
         * # Arguments
         *
         * * `method_id` - Payment method identifier
         * * `endpoint` - The private endpoint data
         * * `expires_in_secs` - Optional expiration time in seconds
         */
@Throws(PaykitMobileException::class)

fun `createPrivateEndpointOfferMessage`(`methodId`: String, `endpoint`: String, `expiresInSecs`: ULong?): NoisePaymentMessage {
    return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_private_endpoint_offer_message(FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),FfiConverterOptionalULong.lower(`expiresInSecs`),_status)
})
}

        /**
         * Create a receipt confirmation message.
         *
         * # Arguments
         *
         * * `receipt_id` - The receipt ID being confirmed
         * * `payer_pubkey` - Payer's public key
         * * `payee_pubkey` - Payee's public key
         * * `method_id` - Payment method used
         * * `amount` - Payment amount
         * * `currency` - Currency code
         * * `signature` - Optional signature from payee
         */
@Throws(PaykitMobileException::class)

fun `createReceiptConfirmationMessage`(`receiptId`: String, `payerPubkey`: String, `payeePubkey`: String, `methodId`: String, `amount`: String?, `currency`: String?, `signature`: String?): NoisePaymentMessage {
    return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_receipt_confirmation_message(FfiConverterString.lower(`receiptId`),FfiConverterString.lower(`payerPubkey`),FfiConverterString.lower(`payeePubkey`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),FfiConverterOptionalString.lower(`signature`),_status)
})
}

        /**
         * Create a receipt request message.
         *
         * # Arguments
         *
         * * `receipt_id` - Unique identifier for this receipt
         * * `payer_pubkey` - Payer's public key (z-base32)
         * * `payee_pubkey` - Payee's public key (z-base32)
         * * `method_id` - Payment method identifier
         * * `amount` - Optional payment amount
         * * `currency` - Optional currency code
         */
@Throws(PaykitMobileException::class)

fun `createReceiptRequestMessage`(`receiptId`: String, `payerPubkey`: String, `payeePubkey`: String, `methodId`: String, `amount`: String?, `currency`: String?): NoisePaymentMessage {
    return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_receipt_request_message(FfiConverterString.lower(`receiptId`),FfiConverterString.lower(`payerPubkey`),FfiConverterString.lower(`payeePubkey`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),_status)
})
}

        /**
         * Create a new receipt store.
         */

fun `createReceiptStore`(): ReceiptStore {
    return FfiConverterTypeReceiptStore.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_receipt_store(_status)
})
}

        /**
         * Derive X25519 keypair for Noise protocol from Ed25519 seed.
         *
         * This uses the pubky-noise KDF to derive device-specific encryption keys
         * from the Ed25519 identity seed.
         *
         * # Arguments
         *
         * * `ed25519_secret_hex` - The Ed25519 secret key (seed) in hex format.
         * * `device_id` - A unique identifier for this device.
         * * `epoch` - Key rotation epoch (increment to rotate keys).
         *
         * # Returns
         *
         * The derived X25519 keypair for use with Noise protocol.
         */
@Throws(PaykitMobileException::class)

fun `deriveX25519Keypair`(`ed25519SecretHex`: String, `deviceId`: String, `epoch`: UInt): X25519Keypair {
    return FfiConverterTypeX25519Keypair.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_derive_x25519_keypair(FfiConverterString.lower(`ed25519SecretHex`),FfiConverterString.lower(`deviceId`),FfiConverterUInt.lower(`epoch`),_status)
})
}

        /**
         * Discover a Noise endpoint for a recipient.
         *
         * Queries the recipient's public directory for their Noise server information.
         *
         * # Arguments
         *
         * * `transport` - Unauthenticated transport for reading
         * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
         *
         * # Returns
         *
         * The noise endpoint info if found, None otherwise.
         *
         * # Example
         *
         * ```ignore
         * let transport = UnauthenticatedTransportFFI::new_mock();
         * if let Some(endpoint) = discover_noise_endpoint(&transport, "8pinxxgqs41...")? {
         * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
         * println!("Server pubkey: {}", endpoint.server_noise_pubkey);
         * }
         * ```
         */
@Throws(PaykitMobileException::class)

fun `discoverNoiseEndpoint`(`transport`: UnauthenticatedTransportFfi, `recipientPubkey`: String): NoiseEndpointInfo? {
    return FfiConverterOptionalTypeNoiseEndpointInfo.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_discover_noise_endpoint(FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`recipientPubkey`),_status)
})
}

        /**
         * Derive Ed25519 public key from secret key.
         *
         * # Arguments
         *
         * * `secret_key_hex` - The 32-byte secret key in hex format.
         *
         * # Returns
         *
         * The complete keypair derived from the secret.
         */
@Throws(PaykitMobileException::class)

fun `ed25519KeypairFromSecret`(`secretKeyHex`: String): Ed25519Keypair {
    return FfiConverterTypeEd25519Keypair.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_ed25519_keypair_from_secret(FfiConverterString.lower(`secretKeyHex`),_status)
})
}

        /**
         * Export keypair to encrypted backup.
         *
         * # Arguments
         *
         * * `secret_key_hex` - The secret key to backup.
         * * `password` - Password to encrypt the backup.
         *
         * # Returns
         *
         * Encrypted backup that can be stored or transferred.
         */
@Throws(PaykitMobileException::class)

fun `exportKeypairToBackup`(`secretKeyHex`: String, `password`: String): KeyBackup {
    return FfiConverterTypeKeyBackup.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_export_keypair_to_backup(FfiConverterString.lower(`secretKeyHex`),FfiConverterString.lower(`password`),_status)
})
}

        /**
         * Format public key as z-base32 (pkarr format).
         */
@Throws(PaykitMobileException::class)

fun `formatPublicKeyZ32`(`publicKeyHex`: String): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_format_public_key_z32(FfiConverterString.lower(`publicKeyHex`),_status)
})
}

        /**
         * Get the unique device ID for this device.
         *
         * This should be stored persistently and reused for consistent key derivation.
         * If not available, generates a new random device ID.
         */

fun `generateDeviceId`(): String {
    return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_generate_device_id(_status)
})
}

        /**
         * Generate a new Ed25519 keypair for identity.
         *
         * This creates a new random identity. The secret key should be stored
         * securely and backed up.
         *
         * # Returns
         *
         * A new Ed25519 keypair with the secret in hex format.
         */
@Throws(PaykitMobileException::class)

fun `generateEd25519Keypair`(): Ed25519Keypair {
    return FfiConverterTypeEd25519Keypair.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_generate_ed25519_keypair(_status)
})
}

        /**
         * Get the library version.
         */

fun `getVersion`(): String {
    return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_get_version(_status)
})
}

        /**
         * Import keypair from encrypted backup.
         *
         * # Arguments
         *
         * * `backup` - The encrypted backup.
         * * `password` - Password to decrypt the backup.
         *
         * # Returns
         *
         * The decrypted keypair.
         */
@Throws(PaykitMobileException::class)

fun `importKeypairFromBackup`(`backup`: KeyBackup, `password`: String): Ed25519Keypair {
    return FfiConverterTypeEd25519Keypair.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_import_keypair_from_backup(FfiConverterTypeKeyBackup.lower(`backup`),FfiConverterString.lower(`password`),_status)
})
}

        /**
         * Parse a payment message from JSON.
         *
         * # Arguments
         *
         * * `json` - The JSON string to parse
         */
@Throws(PaykitMobileException::class)

fun `parsePaymentMessage`(`json`: String): NoisePaymentMessage {
    return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_parse_payment_message(FfiConverterString.lower(`json`),_status)
})
}

        /**
         * Parse z-base32 public key to hex.
         */
@Throws(PaykitMobileException::class)

fun `parsePublicKeyZ32`(`publicKeyZ32`: String): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_parse_public_key_z32(FfiConverterString.lower(`publicKeyZ32`),_status)
})
}

        /**
         * Publish a Noise endpoint to the directory.
         *
         * Makes this device discoverable for receiving payments via Noise protocol.
         *
         * # Arguments
         *
         * * `transport` - Authenticated transport for writing
         * * `host` - Host address where the Noise server is listening
         * * `port` - Port number where the Noise server is listening
         * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
         * * `metadata` - Optional metadata about the endpoint
         */
@Throws(PaykitMobileException::class)

fun `publishNoiseEndpoint`(`transport`: AuthenticatedTransportFfi, `host`: String, `port`: UShort, `noisePubkey`: String, `metadata`: String?) =
    
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_publish_noise_endpoint(FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`host`),FfiConverterUShort.lower(`port`),FfiConverterString.lower(`noisePubkey`),FfiConverterOptionalString.lower(`metadata`),_status)
}


        /**
         * Remove the Noise endpoint from the directory.
         *
         * Makes this device no longer discoverable for Noise payments.
         *
         * # Arguments
         *
         * * `transport` - Authenticated transport for writing
         */
@Throws(PaykitMobileException::class)

fun `removeNoiseEndpoint`(`transport`: AuthenticatedTransportFfi) =
    
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_remove_noise_endpoint(FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),_status)
}


        /**
         * Sign a message with Ed25519 secret key.
         *
         * # Arguments
         *
         * * `secret_key_hex` - The Ed25519 secret key in hex format.
         * * `message` - The message bytes to sign.
         *
         * # Returns
         *
         * The 64-byte signature in hex format.
         */
@Throws(PaykitMobileException::class)

fun `signMessage`(`secretKeyHex`: String, `message`: ByteArray): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_sign_message(FfiConverterString.lower(`secretKeyHex`),FfiConverterByteArray.lower(`message`),_status)
})
}

        /**
         * Verify an Ed25519 signature.
         *
         * # Arguments
         *
         * * `public_key_hex` - The Ed25519 public key in hex format.
         * * `message` - The original message bytes.
         * * `signature_hex` - The 64-byte signature in hex format.
         *
         * # Returns
         *
         * True if the signature is valid, false otherwise.
         */
@Throws(PaykitMobileException::class)

fun `verifySignature`(`publicKeyHex`: String, `message`: ByteArray, `signatureHex`: String): Boolean {
    return FfiConverterBoolean.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_verify_signature(FfiConverterString.lower(`publicKeyHex`),FfiConverterByteArray.lower(`message`),FfiConverterString.lower(`signatureHex`),_status)
})
}


