// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.paykit_mobile

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_paykit_mobile_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_paykit_mobile_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter = java.util.concurrent.atomic.AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "paykit_mobile"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ): UniffiForeignFuture(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructPointer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructPointer.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructVoid.UniffiByValue,)
}
internal interface UniffiCallbackInterfaceBitcoinExecutorFfiMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`address`: RustBuffer.ByValue,`amountSats`: Long,`feeRate`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceBitcoinExecutorFfiMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`address`: RustBuffer.ByValue,`amountSats`: Long,`targetBlocks`: Int,`uniffiOutReturn`: LongByReference,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceBitcoinExecutorFfiMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`txid`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceBitcoinExecutorFfiMethod3 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`txid`: RustBuffer.ByValue,`address`: RustBuffer.ByValue,`amountSats`: Long,`uniffiOutReturn`: ByteByReference,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceLightningExecutorFfiMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`invoice`: RustBuffer.ByValue,`amountMsat`: RustBuffer.ByValue,`maxFeeMsat`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceLightningExecutorFfiMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`invoice`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceLightningExecutorFfiMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`invoice`: RustBuffer.ByValue,`uniffiOutReturn`: LongByReference,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceLightningExecutorFfiMethod3 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`paymentHash`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceLightningExecutorFfiMethod4 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`preimage`: RustBuffer.ByValue,`paymentHash`: RustBuffer.ByValue,`uniffiOutReturn`: ByteByReference,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`path`: RustBuffer.ByValue,`content`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`path`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`path`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod3 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`prefix`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePubkyUnauthenticatedStorageCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`ownerPubkey`: RustBuffer.ByValue,`path`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePubkyUnauthenticatedStorageCallbackMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`ownerPubkey`: RustBuffer.ByValue,`prefix`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceReceiptGeneratorCallbackMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`request`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
@Structure.FieldOrder("sendToAddress", "estimateFee", "getTransaction", "verifyTransaction", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceBitcoinExecutorFfi(
    @JvmField internal var `sendToAddress`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod0? = null,
    @JvmField internal var `estimateFee`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod1? = null,
    @JvmField internal var `getTransaction`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod2? = null,
    @JvmField internal var `verifyTransaction`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod3? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `sendToAddress`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod0? = null,
        `estimateFee`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod1? = null,
        `getTransaction`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod2? = null,
        `verifyTransaction`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod3? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceBitcoinExecutorFfi(`sendToAddress`,`estimateFee`,`getTransaction`,`verifyTransaction`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceBitcoinExecutorFfi) {
        `sendToAddress` = other.`sendToAddress`
        `estimateFee` = other.`estimateFee`
        `getTransaction` = other.`getTransaction`
        `verifyTransaction` = other.`verifyTransaction`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("payInvoice", "decodeInvoice", "estimateFee", "getPayment", "verifyPreimage", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceLightningExecutorFfi(
    @JvmField internal var `payInvoice`: UniffiCallbackInterfaceLightningExecutorFfiMethod0? = null,
    @JvmField internal var `decodeInvoice`: UniffiCallbackInterfaceLightningExecutorFfiMethod1? = null,
    @JvmField internal var `estimateFee`: UniffiCallbackInterfaceLightningExecutorFfiMethod2? = null,
    @JvmField internal var `getPayment`: UniffiCallbackInterfaceLightningExecutorFfiMethod3? = null,
    @JvmField internal var `verifyPreimage`: UniffiCallbackInterfaceLightningExecutorFfiMethod4? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `payInvoice`: UniffiCallbackInterfaceLightningExecutorFfiMethod0? = null,
        `decodeInvoice`: UniffiCallbackInterfaceLightningExecutorFfiMethod1? = null,
        `estimateFee`: UniffiCallbackInterfaceLightningExecutorFfiMethod2? = null,
        `getPayment`: UniffiCallbackInterfaceLightningExecutorFfiMethod3? = null,
        `verifyPreimage`: UniffiCallbackInterfaceLightningExecutorFfiMethod4? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceLightningExecutorFfi(`payInvoice`,`decodeInvoice`,`estimateFee`,`getPayment`,`verifyPreimage`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceLightningExecutorFfi) {
        `payInvoice` = other.`payInvoice`
        `decodeInvoice` = other.`decodeInvoice`
        `estimateFee` = other.`estimateFee`
        `getPayment` = other.`getPayment`
        `verifyPreimage` = other.`verifyPreimage`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("put", "get", "delete", "list", "uniffiFree")
internal open class UniffiVTableCallbackInterfacePubkyAuthenticatedStorageCallback(
    @JvmField internal var `put`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod0? = null,
    @JvmField internal var `get`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod1? = null,
    @JvmField internal var `delete`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod2? = null,
    @JvmField internal var `list`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod3? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `put`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod0? = null,
        `get`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod1? = null,
        `delete`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod2? = null,
        `list`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod3? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfacePubkyAuthenticatedStorageCallback(`put`,`get`,`delete`,`list`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfacePubkyAuthenticatedStorageCallback) {
        `put` = other.`put`
        `get` = other.`get`
        `delete` = other.`delete`
        `list` = other.`list`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("get", "list", "uniffiFree")
internal open class UniffiVTableCallbackInterfacePubkyUnauthenticatedStorageCallback(
    @JvmField internal var `get`: UniffiCallbackInterfacePubkyUnauthenticatedStorageCallbackMethod0? = null,
    @JvmField internal var `list`: UniffiCallbackInterfacePubkyUnauthenticatedStorageCallbackMethod1? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `get`: UniffiCallbackInterfacePubkyUnauthenticatedStorageCallbackMethod0? = null,
        `list`: UniffiCallbackInterfacePubkyUnauthenticatedStorageCallbackMethod1? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfacePubkyUnauthenticatedStorageCallback(`get`,`list`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfacePubkyUnauthenticatedStorageCallback) {
        `get` = other.`get`
        `list` = other.`list`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("generateReceipt", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceReceiptGeneratorCallback(
    @JvmField internal var `generateReceipt`: UniffiCallbackInterfaceReceiptGeneratorCallbackMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `generateReceipt`: UniffiCallbackInterfaceReceiptGeneratorCallbackMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceReceiptGeneratorCallback(`generateReceipt`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceReceiptGeneratorCallback) {
        `generateReceipt` = other.`generateReceipt`
        `uniffiFree` = other.`uniffiFree`
    }

}



















































































































































































































































































































































































































// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is 
// rather `InterfaceTooLargeException`, caused by too many methods 
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib 
// * IntegrityCheckingUniffiLib (this)
// we allow for ~2x as many methods in the UniffiLib interface.
// 
// The `ffi_uniffi_contract_version` method and all checksum methods are put 
// into `IntegrityCheckingUniffiLib` and these methods are called only once,
// when the library is loaded.
internal interface IntegrityCheckingUniffiLib : Library {
    // Integrity check functions only
    fun uniffi_paykit_mobile_checksum_func_create_contact_cache(
): Short
fun uniffi_paykit_mobile_checksum_func_create_directory_operations_async(
): Short
fun uniffi_paykit_mobile_checksum_func_create_error_message(
): Short
fun uniffi_paykit_mobile_checksum_func_create_executor_async_bridge(
): Short
fun uniffi_paykit_mobile_checksum_func_create_executor_async_bridge_with_timeout(
): Short
fun uniffi_paykit_mobile_checksum_func_create_interactive_manager(
): Short
fun uniffi_paykit_mobile_checksum_func_create_message_builder(
): Short
fun uniffi_paykit_mobile_checksum_func_create_noise_server_config(
): Short
fun uniffi_paykit_mobile_checksum_func_create_noise_server_config_with_port(
): Short
fun uniffi_paykit_mobile_checksum_func_create_paykit_client(
): Short
fun uniffi_paykit_mobile_checksum_func_create_private_endpoint_offer_message(
): Short
fun uniffi_paykit_mobile_checksum_func_create_receipt_confirmation_message(
): Short
fun uniffi_paykit_mobile_checksum_func_create_receipt_request_message(
): Short
fun uniffi_paykit_mobile_checksum_func_create_receipt_store(
): Short
fun uniffi_paykit_mobile_checksum_func_create_spending_manager(
): Short
fun uniffi_paykit_mobile_checksum_func_derive_x25519_keypair(
): Short
fun uniffi_paykit_mobile_checksum_func_discover_noise_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_func_ed25519_keypair_from_secret(
): Short
fun uniffi_paykit_mobile_checksum_func_export_keypair_to_backup(
): Short
fun uniffi_paykit_mobile_checksum_func_format_public_key_z32(
): Short
fun uniffi_paykit_mobile_checksum_func_generate_device_id(
): Short
fun uniffi_paykit_mobile_checksum_func_generate_ed25519_keypair(
): Short
fun uniffi_paykit_mobile_checksum_func_get_version(
): Short
fun uniffi_paykit_mobile_checksum_func_import_keypair_from_backup(
): Short
fun uniffi_paykit_mobile_checksum_func_parse_payment_message(
): Short
fun uniffi_paykit_mobile_checksum_func_parse_public_key_z32(
): Short
fun uniffi_paykit_mobile_checksum_func_publish_noise_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_func_remove_noise_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_func_sign_message(
): Short
fun uniffi_paykit_mobile_checksum_func_verify_signature(
): Short
fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_delete(
): Short
fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_get(
): Short
fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_is_mock(
): Short
fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_list(
): Short
fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_owner_pubkey(
): Short
fun uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_put(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_add(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_add_with_name(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_clear(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_contains(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_count(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_get(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_get_all(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_remove(
): Short
fun uniffi_paykit_mobile_checksum_method_contactcacheffi_sync(
): Short
fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_add_contact(
): Short
fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_known_contacts(
): Short
fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_payment_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_supported_payments(
): Short
fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_list_contacts(
): Short
fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_publish_payment_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_contact(
): Short
fun uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_payment_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_executorasyncbridge_default_timeout_ms(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_add_contact(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_bitcoin_network(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_calculate_proration(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_check_health(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_create_noise_error_message(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_create_payment_request(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_confirmation_message(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_request_message(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_create_subscription(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_days_remaining_in_period(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_discover_noise_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_execute_payment(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_execute_with_fallbacks(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_extract_key_from_qr(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_extract_method_from_qr(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_fetch_known_contacts(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_fetch_payment_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_fetch_supported_payments(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_generate_payment_proof(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_get_health_status(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_get_in_progress_payments(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_get_payment_status(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_has_bitcoin_executor(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_has_lightning_executor(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_is_method_usable(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_is_paykit_qr(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_lightning_network(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_list_contacts(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_list_methods(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_parse_noise_payment_message(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_parse_receipt_metadata(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_parse_scanned_qr(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_publish_noise_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_publish_payment_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_register_bitcoin_executor(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_register_lightning_executor(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_remove_contact(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_remove_noise_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_remove_payment_endpoint_from_directory(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_select_method(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitclient_validate_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_endpoint_offer(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_payment_request(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_private_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_receipt(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_store(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_message(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_payment_response(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_private_endpoints(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_receipts(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_set_generator(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_ack(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_endpoint_offer(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_error(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_confirm(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_request(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_get_message_type(
): Short
fun uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_parse_message(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_clear(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_delete_receipt(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_export_receipts_json(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_get_private_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_get_receipt(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_import_receipts_json(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_list_private_endpoints(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_list_receipts(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_save_private_endpoint(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptstore_save_receipt(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_active_reservations_count(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_commit_spending(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_get_peer_spending_limit(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_list_spending_limits(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_remove_peer_spending_limit(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_rollback_spending(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_set_peer_spending_limit(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_try_reserve_spending(
): Short
fun uniffi_paykit_mobile_checksum_method_spendingmanagerffi_would_exceed_spending_limit(
): Short
fun uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_get(
): Short
fun uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_is_mock(
): Short
fun uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_list(
): Short
fun uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_callback(
): Short
fun uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_session_json(
): Short
fun uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_new_mock(
): Short
fun uniffi_paykit_mobile_checksum_constructor_contactcacheffi_new(
): Short
fun uniffi_paykit_mobile_checksum_constructor_directoryoperationsasync_new(
): Short
fun uniffi_paykit_mobile_checksum_constructor_executorasyncbridge_new(
): Short
fun uniffi_paykit_mobile_checksum_constructor_executorasyncbridge_with_timeout(
): Short
fun uniffi_paykit_mobile_checksum_constructor_paykitclient_new(
): Short
fun uniffi_paykit_mobile_checksum_constructor_paykitclient_new_with_network(
): Short
fun uniffi_paykit_mobile_checksum_constructor_paykitinteractivemanagerffi_new(
): Short
fun uniffi_paykit_mobile_checksum_constructor_paykitmessagebuilder_new(
): Short
fun uniffi_paykit_mobile_checksum_constructor_receiptstore_new(
): Short
fun uniffi_paykit_mobile_checksum_constructor_spendingmanagerffi_new(
): Short
fun uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_authenticated(
): Short
fun uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_callback(
): Short
fun uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_config_json(
): Short
fun uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_new_mock(
): Short
fun uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_send_to_address(
): Short
fun uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_estimate_fee(
): Short
fun uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_get_transaction(
): Short
fun uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_verify_transaction(
): Short
fun uniffi_paykit_mobile_checksum_method_lightningexecutorffi_pay_invoice(
): Short
fun uniffi_paykit_mobile_checksum_method_lightningexecutorffi_decode_invoice(
): Short
fun uniffi_paykit_mobile_checksum_method_lightningexecutorffi_estimate_fee(
): Short
fun uniffi_paykit_mobile_checksum_method_lightningexecutorffi_get_payment(
): Short
fun uniffi_paykit_mobile_checksum_method_lightningexecutorffi_verify_preimage(
): Short
fun uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_put(
): Short
fun uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_get(
): Short
fun uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_delete(
): Short
fun uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_list(
): Short
fun uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_get(
): Short
fun uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_list(
): Short
fun uniffi_paykit_mobile_checksum_method_receiptgeneratorcallback_generate_receipt(
): Short
fun ffi_paykit_mobile_uniffi_contract_version(
): Int

}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.
internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            val componentName = "paykit_mobile"
            // For large crates we prevent `MethodTooLargeException` (see #2340)
            // N.B. the name of the extension is very misleading, since it is 
            // rather `InterfaceTooLargeException`, caused by too many methods 
            // in the interface for large crates.
            //
            // By splitting the otherwise huge interface into two parts
            // * UniffiLib (this)
            // * IntegrityCheckingUniffiLib
            // And all checksum methods are put into `IntegrityCheckingUniffiLib`
            // we allow for ~2x as many methods in the UniffiLib interface.
            // 
            // Thus we first load the library with `loadIndirect` as `IntegrityCheckingUniffiLib`
            // so that we can (optionally!) call `uniffiCheckApiChecksums`...
            loadIndirect<IntegrityCheckingUniffiLib>(componentName)
                .also { lib: IntegrityCheckingUniffiLib ->
                    uniffiCheckContractApiVersion(lib)
                    uniffiCheckApiChecksums(lib)
                }
            // ... and then we load the library as `UniffiLib`
            // N.B. we cannot use `loadIndirect` once and then try to cast it to `UniffiLib`
            // => results in `java.lang.ClassCastException: com.sun.proxy.$Proxy cannot be cast to ...`
            // error. So we must call `loadIndirect` twice. For crates large enough
            // to trigger this issue, the performance impact is negligible, running on
            // a macOS M1 machine the `loadIndirect` call takes ~50ms.
            val lib = loadIndirect<UniffiLib>(componentName)
            // No need to check the contract version and checksums, since 
            // we already did that with `IntegrityCheckingUniffiLib` above.
            uniffiCallbackInterfaceBitcoinExecutorFFI.register(lib)
            uniffiCallbackInterfaceLightningExecutorFFI.register(lib)
            uniffiCallbackInterfacePubkyAuthenticatedStorageCallback.register(lib)
            uniffiCallbackInterfacePubkyUnauthenticatedStorageCallback.register(lib)
            uniffiCallbackInterfaceReceiptGeneratorCallback.register(lib)
            // Loading of library with integrity check done.
            lib
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    // FFI functions
    fun uniffi_paykit_mobile_fn_clone_authenticatedtransportffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_authenticatedtransportffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_callback(`callback`: Long,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_session_json(`sessionJson`: RustBuffer.ByValue,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_new_mock(`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_delete(`ptr`: Pointer,`path`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_get(`ptr`: Pointer,`path`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_is_mock(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_list(`ptr`: Pointer,`prefix`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_owner_pubkey(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_authenticatedtransportffi_put(`ptr`: Pointer,`path`: RustBuffer.ByValue,`content`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_clone_contactcacheffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_contactcacheffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_contactcacheffi_new(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_contactcacheffi_add(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_contactcacheffi_add_with_name(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,`name`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_contactcacheffi_clear(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_contactcacheffi_contains(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_paykit_mobile_fn_method_contactcacheffi_count(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_paykit_mobile_fn_method_contactcacheffi_get(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_contactcacheffi_get_all(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_contactcacheffi_remove(`ptr`: Pointer,`pubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_contactcacheffi_sync(`ptr`: Pointer,`remotePubkeys`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_clone_directoryoperationsasync(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_directoryoperationsasync(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_directoryoperationsasync_new(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_add_contact(`ptr`: Pointer,`transport`: Pointer,`contactPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_known_contacts(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_supported_payments(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_list_contacts(`ptr`: Pointer,`transport`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_publish_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`methodId`: RustBuffer.ByValue,`endpointData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_contact(`ptr`: Pointer,`transport`: Pointer,`contactPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_clone_executorasyncbridge(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_executorasyncbridge(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_executorasyncbridge_new(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_constructor_executorasyncbridge_with_timeout(`timeoutMs`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_executorasyncbridge_default_timeout_ms(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_paykit_mobile_fn_clone_paykitclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_paykitclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_paykitclient_new(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_constructor_paykitclient_new_with_network(`bitcoinNetwork`: RustBuffer.ByValue,`lightningNetwork`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_paykitclient_add_contact(`ptr`: Pointer,`transport`: Pointer,`contactPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_paykitclient_bitcoin_network(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_calculate_proration(`ptr`: Pointer,`currentAmountSats`: Long,`newAmountSats`: Long,`periodStart`: Long,`periodEnd`: Long,`changeDate`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_check_health(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_create_noise_error_message(`ptr`: Pointer,`code`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_create_payment_request(`ptr`: Pointer,`fromPubkey`: RustBuffer.ByValue,`toPubkey`: RustBuffer.ByValue,`amountSats`: Long,`currency`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`description`: RustBuffer.ByValue,`expiresInSecs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_create_receipt(`ptr`: Pointer,`payer`: RustBuffer.ByValue,`payee`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_confirmation_message(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,`payerPubkey`: RustBuffer.ByValue,`payeePubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,`signature`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_request_message(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,`payerPubkey`: RustBuffer.ByValue,`payeePubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_create_subscription(`ptr`: Pointer,`subscriber`: RustBuffer.ByValue,`provider`: RustBuffer.ByValue,`terms`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_days_remaining_in_period(`ptr`: Pointer,`periodEnd`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_paykit_mobile_fn_method_paykitclient_discover_noise_endpoint(`ptr`: Pointer,`transport`: Pointer,`recipientPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_execute_payment(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,`amountSats`: Long,`metadataJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_execute_with_fallbacks(`ptr`: Pointer,`candidates`: RustBuffer.ByValue,`amountSats`: Long,`metadataJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_extract_key_from_qr(`ptr`: Pointer,`scannedData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_extract_method_from_qr(`ptr`: Pointer,`scannedData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_fetch_known_contacts(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_fetch_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_fetch_supported_payments(`ptr`: Pointer,`transport`: Pointer,`ownerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_generate_payment_proof(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,`executionDataJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_get_health_status(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_get_in_progress_payments(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_get_payment_status(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_has_bitcoin_executor(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_paykit_mobile_fn_method_paykitclient_has_lightning_executor(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_paykit_mobile_fn_method_paykitclient_is_method_usable(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_paykit_mobile_fn_method_paykitclient_is_paykit_qr(`ptr`: Pointer,`scannedData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_paykit_mobile_fn_method_paykitclient_lightning_network(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_list_contacts(`ptr`: Pointer,`transport`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_list_methods(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_parse_noise_payment_message(`ptr`: Pointer,`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_parse_receipt_metadata(`ptr`: Pointer,`metadataJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_parse_scanned_qr(`ptr`: Pointer,`scannedData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_publish_noise_endpoint(`ptr`: Pointer,`transport`: Pointer,`host`: RustBuffer.ByValue,`port`: Short,`noisePubkey`: RustBuffer.ByValue,`metadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_paykitclient_publish_payment_endpoint(`ptr`: Pointer,`transport`: Pointer,`methodId`: RustBuffer.ByValue,`endpointData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_paykitclient_register_bitcoin_executor(`ptr`: Pointer,`executor`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_paykitclient_register_lightning_executor(`ptr`: Pointer,`executor`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_paykitclient_remove_contact(`ptr`: Pointer,`transport`: Pointer,`contactPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_paykitclient_remove_noise_endpoint(`ptr`: Pointer,`transport`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_paykitclient_remove_payment_endpoint_from_directory(`ptr`: Pointer,`transport`: Pointer,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_paykitclient_select_method(`ptr`: Pointer,`supportedMethods`: RustBuffer.ByValue,`amountSats`: Long,`preferences`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitclient_validate_endpoint(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_paykit_mobile_fn_clone_paykitinteractivemanagerffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_paykitinteractivemanagerffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_paykitinteractivemanagerffi_new(`store`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_endpoint_offer(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_payment_request(`ptr`: Pointer,`payer`: RustBuffer.ByValue,`payee`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,`metadataJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_private_endpoint(`ptr`: Pointer,`peer`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_receipt(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_store(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_message(`ptr`: Pointer,`messageJson`: RustBuffer.ByValue,`peerPubkey`: RustBuffer.ByValue,`myPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_payment_response(`ptr`: Pointer,`responseJson`: RustBuffer.ByValue,`originalReceiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_private_endpoints(`ptr`: Pointer,`peer`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_receipts(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_set_generator(`ptr`: Pointer,`generator`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_clone_paykitmessagebuilder(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_paykitmessagebuilder(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_paykitmessagebuilder_new(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_ack(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_endpoint_offer(`ptr`: Pointer,`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_error(`ptr`: Pointer,`code`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_confirm(`ptr`: Pointer,`receipt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_request(`ptr`: Pointer,`request`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_get_message_type(`ptr`: Pointer,`messageJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_paykitmessagebuilder_parse_message(`ptr`: Pointer,`messageJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_clone_receiptstore(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_receiptstore(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_receiptstore_new(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_receiptstore_clear(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_receiptstore_delete_receipt(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_receiptstore_export_receipts_json(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_receiptstore_get_private_endpoint(`ptr`: Pointer,`peer`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_receiptstore_get_receipt(`ptr`: Pointer,`receiptId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_receiptstore_import_receipts_json(`ptr`: Pointer,`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_paykit_mobile_fn_method_receiptstore_list_private_endpoints(`ptr`: Pointer,`peer`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_receiptstore_list_receipts(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_receiptstore_save_private_endpoint(`ptr`: Pointer,`peer`: RustBuffer.ByValue,`offer`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_receiptstore_save_receipt(`ptr`: Pointer,`receipt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_clone_spendingmanagerffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_spendingmanagerffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_spendingmanagerffi_new(`storagePath`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_active_reservations_count(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_commit_spending(`ptr`: Pointer,`reservationId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_get_peer_spending_limit(`ptr`: Pointer,`peerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_list_spending_limits(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_remove_peer_spending_limit(`ptr`: Pointer,`peerPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_rollback_spending(`ptr`: Pointer,`reservationId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_set_peer_spending_limit(`ptr`: Pointer,`peerPubkey`: RustBuffer.ByValue,`limitSats`: Long,`period`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_try_reserve_spending(`ptr`: Pointer,`peerPubkey`: RustBuffer.ByValue,`amountSats`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_spendingmanagerffi_would_exceed_spending_limit(`ptr`: Pointer,`peerPubkey`: RustBuffer.ByValue,`amountSats`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_clone_unauthenticatedtransportffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_free_unauthenticatedtransportffi(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_authenticated(`auth`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_callback(`callback`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_config_json(`configJson`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_new_mock(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_get(`ptr`: Pointer,`ownerPubkey`: RustBuffer.ByValue,`path`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_is_mock(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_list(`ptr`: Pointer,`ownerPubkey`: RustBuffer.ByValue,`prefix`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_init_callback_vtable_bitcoinexecutorffi(`vtable`: UniffiVTableCallbackInterfaceBitcoinExecutorFfi,
): Unit
fun uniffi_paykit_mobile_fn_init_callback_vtable_lightningexecutorffi(`vtable`: UniffiVTableCallbackInterfaceLightningExecutorFfi,
): Unit
fun uniffi_paykit_mobile_fn_init_callback_vtable_pubkyauthenticatedstoragecallback(`vtable`: UniffiVTableCallbackInterfacePubkyAuthenticatedStorageCallback,
): Unit
fun uniffi_paykit_mobile_fn_init_callback_vtable_pubkyunauthenticatedstoragecallback(`vtable`: UniffiVTableCallbackInterfacePubkyUnauthenticatedStorageCallback,
): Unit
fun uniffi_paykit_mobile_fn_init_callback_vtable_receiptgeneratorcallback(`vtable`: UniffiVTableCallbackInterfaceReceiptGeneratorCallback,
): Unit
fun uniffi_paykit_mobile_fn_func_create_contact_cache(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_create_directory_operations_async(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_create_error_message(`code`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_create_executor_async_bridge(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_create_executor_async_bridge_with_timeout(`timeoutMs`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_create_interactive_manager(`store`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_create_message_builder(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_create_noise_server_config(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_create_noise_server_config_with_port(`port`: Short,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_create_paykit_client(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_create_private_endpoint_offer_message(`methodId`: RustBuffer.ByValue,`endpoint`: RustBuffer.ByValue,`expiresInSecs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_create_receipt_confirmation_message(`receiptId`: RustBuffer.ByValue,`payerPubkey`: RustBuffer.ByValue,`payeePubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,`signature`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_create_receipt_request_message(`receiptId`: RustBuffer.ByValue,`payerPubkey`: RustBuffer.ByValue,`payeePubkey`: RustBuffer.ByValue,`methodId`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`currency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_create_receipt_store(uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_create_spending_manager(`storagePath`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun uniffi_paykit_mobile_fn_func_derive_x25519_keypair(`ed25519SecretHex`: RustBuffer.ByValue,`deviceId`: RustBuffer.ByValue,`epoch`: Int,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_discover_noise_endpoint(`transport`: Pointer,`recipientPubkey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_ed25519_keypair_from_secret(`secretKeyHex`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_export_keypair_to_backup(`secretKeyHex`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_format_public_key_z32(`publicKeyHex`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_generate_device_id(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_generate_ed25519_keypair(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_get_version(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_import_keypair_from_backup(`backup`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_parse_payment_message(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_parse_public_key_z32(`publicKeyZ32`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_publish_noise_endpoint(`transport`: Pointer,`host`: RustBuffer.ByValue,`port`: Short,`noisePubkey`: RustBuffer.ByValue,`metadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_func_remove_noise_endpoint(`transport`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_paykit_mobile_fn_func_sign_message(`secretKeyHex`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_paykit_mobile_fn_func_verify_signature(`publicKeyHex`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,`signatureHex`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_paykit_mobile_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_paykit_mobile_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_paykit_mobile_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun ffi_paykit_mobile_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_paykit_mobile_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_u8(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_u8(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_paykit_mobile_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_i8(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_i8(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_paykit_mobile_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_u16(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_u16(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_paykit_mobile_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_i16(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_i16(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_paykit_mobile_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_u32(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_u32(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_paykit_mobile_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_i32(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_i32(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_paykit_mobile_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_u64(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_u64(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_paykit_mobile_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_i64(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_i64(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_paykit_mobile_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_f32(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_f32(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
fun ffi_paykit_mobile_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_f64(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_f64(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
fun ffi_paykit_mobile_rust_future_poll_pointer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_pointer(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_pointer(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_pointer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Pointer
fun ffi_paykit_mobile_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_rust_buffer(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_rust_buffer(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_paykit_mobile_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_cancel_void(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_free_void(`handle`: Long,
): Unit
fun ffi_paykit_mobile_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit

}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_paykit_mobile_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}
@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
    if (lib.uniffi_paykit_mobile_checksum_func_create_contact_cache() != 8922.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_directory_operations_async() != 3774.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_error_message() != 3910.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_executor_async_bridge() != 20970.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_executor_async_bridge_with_timeout() != 64108.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_interactive_manager() != 29264.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_message_builder() != 17772.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_noise_server_config() != 51894.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_noise_server_config_with_port() != 20409.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_paykit_client() != 24343.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_private_endpoint_offer_message() != 39588.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_receipt_confirmation_message() != 60309.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_receipt_request_message() != 237.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_receipt_store() != 25695.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_create_spending_manager() != 50773.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_derive_x25519_keypair() != 88.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_discover_noise_endpoint() != 25103.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_ed25519_keypair_from_secret() != 6399.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_export_keypair_to_backup() != 9110.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_format_public_key_z32() != 40068.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_generate_device_id() != 4216.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_generate_ed25519_keypair() != 1379.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_get_version() != 23495.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_import_keypair_from_backup() != 19578.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_parse_payment_message() != 29256.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_parse_public_key_z32() != 22606.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_publish_noise_endpoint() != 19637.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_remove_noise_endpoint() != 4253.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_sign_message() != 33882.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_func_verify_signature() != 15460.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_delete() != 27910.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_get() != 62854.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_is_mock() != 21711.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_list() != 35643.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_owner_pubkey() != 20095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_put() != 38814.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_add() != 92.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_add_with_name() != 4648.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_clear() != 8267.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_contains() != 34921.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_count() != 63824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_get() != 46556.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_get_all() != 31771.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_remove() != 38239.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_contactcacheffi_sync() != 18218.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_add_contact() != 64657.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_known_contacts() != 25738.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_payment_endpoint() != 33741.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_supported_payments() != 29833.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_list_contacts() != 14459.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_publish_payment_endpoint() != 28899.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_contact() != 59089.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_payment_endpoint() != 29515.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_executorasyncbridge_default_timeout_ms() != 61076.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_add_contact() != 27458.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_bitcoin_network() != 27708.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_calculate_proration() != 24209.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_check_health() != 61124.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_noise_error_message() != 18706.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_payment_request() != 15935.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt() != 56818.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_confirmation_message() != 6664.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_request_message() != 18369.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_create_subscription() != 64542.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_days_remaining_in_period() != 16529.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_discover_noise_endpoint() != 30069.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_execute_payment() != 54016.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_execute_with_fallbacks() != 32260.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_extract_key_from_qr() != 58479.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_extract_method_from_qr() != 37762.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_fetch_known_contacts() != 7044.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_fetch_payment_endpoint() != 23881.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_fetch_supported_payments() != 64176.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_generate_payment_proof() != 22627.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_get_health_status() != 18007.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_get_in_progress_payments() != 25824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_get_payment_status() != 45141.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_has_bitcoin_executor() != 26726.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_has_lightning_executor() != 9374.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_is_method_usable() != 42161.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_is_paykit_qr() != 16545.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_lightning_network() != 43080.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_list_contacts() != 10137.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_list_methods() != 42624.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_parse_noise_payment_message() != 32861.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_parse_receipt_metadata() != 40279.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_parse_scanned_qr() != 33898.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_publish_noise_endpoint() != 41601.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_publish_payment_endpoint() != 60780.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_register_bitcoin_executor() != 59174.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_register_lightning_executor() != 31839.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_remove_contact() != 19687.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_remove_noise_endpoint() != 62949.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_remove_payment_endpoint_from_directory() != 16146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_select_method() != 59923.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitclient_validate_endpoint() != 33544.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_endpoint_offer() != 7132.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_payment_request() != 40014.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_private_endpoint() != 11512.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_receipt() != 23046.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_store() != 2983.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_message() != 1743.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_payment_response() != 48896.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_private_endpoints() != 31358.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_receipts() != 20652.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_set_generator() != 13757.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_ack() != 36644.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_endpoint_offer() != 51224.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_error() != 54428.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_confirm() != 17217.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_request() != 1989.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_get_message_type() != 64569.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_parse_message() != 34318.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_clear() != 37348.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_delete_receipt() != 25391.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_export_receipts_json() != 57252.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_get_private_endpoint() != 26455.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_get_receipt() != 44214.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_import_receipts_json() != 7286.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_list_private_endpoints() != 39184.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_list_receipts() != 50608.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_save_private_endpoint() != 15942.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptstore_save_receipt() != 8333.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_active_reservations_count() != 55714.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_commit_spending() != 13846.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_get_peer_spending_limit() != 5613.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_list_spending_limits() != 65228.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_remove_peer_spending_limit() != 47647.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_rollback_spending() != 34174.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_set_peer_spending_limit() != 27818.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_try_reserve_spending() != 12692.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_spendingmanagerffi_would_exceed_spending_limit() != 55448.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_get() != 49528.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_is_mock() != 10080.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_list() != 22800.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_callback() != 43440.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_session_json() != 62420.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_new_mock() != 11731.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_contactcacheffi_new() != 57738.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_directoryoperationsasync_new() != 16025.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_executorasyncbridge_new() != 15857.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_executorasyncbridge_with_timeout() != 10677.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_paykitclient_new() != 40436.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_paykitclient_new_with_network() != 21874.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_paykitinteractivemanagerffi_new() != 49533.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_paykitmessagebuilder_new() != 35980.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_receiptstore_new() != 15932.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_spendingmanagerffi_new() != 42030.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_authenticated() != 32228.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_callback() != 39502.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_config_json() != 20872.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_new_mock() != 6380.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_send_to_address() != 10733.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_estimate_fee() != 51016.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_get_transaction() != 58497.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_verify_transaction() != 45133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_lightningexecutorffi_pay_invoice() != 31716.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_lightningexecutorffi_decode_invoice() != 42989.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_lightningexecutorffi_estimate_fee() != 11875.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_lightningexecutorffi_get_payment() != 54276.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_lightningexecutorffi_verify_preimage() != 46457.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_put() != 27074.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_get() != 45248.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_delete() != 26277.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_list() != 49068.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_get() != 47092.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_list() != 31988.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_paykit_mobile_checksum_method_receiptgeneratorcallback_generate_receipt() != 60095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
    UniffiLib.INSTANCE
}

// Async support

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            for (arg in args) {
                when (arg) {
                    is Disposable -> arg.destroy()
                    is ArrayList<*> -> {
                        for (idx in arg.indices) {
                            val element = arg[idx]
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Map<*, *> -> {
                        for (element in arg.values) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Iterable<*> -> {
                        for (element in arg) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoPointer// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

/**
 * @suppress
 */
public abstract class FfiConverterCallbackInterface<CallbackInterface: Any>: FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}
/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}


// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        //  otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * @suppress
 */
public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2UL

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8UL

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8UL

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * FFI wrapper for authenticated transport operations.
 *
 * This wraps authenticated write access to Pubky homeservers.
 * Mobile apps can use either:
 * - `new_mock()` for testing
 * - `from_callback()` for production with real Pubky SDK
 */
public interface AuthenticatedTransportFfiInterface {
    
    /**
     * Delete a file at the given path.
     */
    fun `delete`(`path`: kotlin.String)
    
    /**
     * Get a file at the given path.
     */
    fun `get`(`path`: kotlin.String): kotlin.String?
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    fun `isMock`(): kotlin.Boolean
    
    /**
     * List files with a given prefix.
     */
    fun `list`(`prefix`: kotlin.String): List<kotlin.String>
    
    /**
     * Get the owner's public key.
     */
    fun `ownerPubkey`(): kotlin.String
    
    /**
     * Put (create or update) a file at the given path.
     */
    fun `put`(`path`: kotlin.String, `content`: kotlin.String)
    
    companion object
}

/**
 * FFI wrapper for authenticated transport operations.
 *
 * This wraps authenticated write access to Pubky homeservers.
 * Mobile apps can use either:
 * - `new_mock()` for testing
 * - `from_callback()` for production with real Pubky SDK
 */
open class AuthenticatedTransportFfi: Disposable, AutoCloseable, AuthenticatedTransportFfiInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_authenticatedtransportffi(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_authenticatedtransportffi(pointer!!, status)
        }
    }

    
    /**
     * Delete a file at the given path.
     */
    @Throws(PaykitMobileException::class)override fun `delete`(`path`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_delete(
        it, FfiConverterString.lower(`path`),_status)
}
    }
    
    

    
    /**
     * Get a file at the given path.
     */
    @Throws(PaykitMobileException::class)override fun `get`(`path`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_get(
        it, FfiConverterString.lower(`path`),_status)
}
    }
    )
    }
    

    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    @Throws(PaykitMobileException::class)override fun `isMock`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_is_mock(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * List files with a given prefix.
     */
    @Throws(PaykitMobileException::class)override fun `list`(`prefix`: kotlin.String): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_list(
        it, FfiConverterString.lower(`prefix`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the owner's public key.
     */override fun `ownerPubkey`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_owner_pubkey(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Put (create or update) a file at the given path.
     */
    @Throws(PaykitMobileException::class)override fun `put`(`path`: kotlin.String, `content`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_authenticatedtransportffi_put(
        it, FfiConverterString.lower(`path`),FfiConverterString.lower(`content`),_status)
}
    }
    
    

    

    
    companion object {
        
    /**
     * Create authenticated transport from a storage callback.
     *
     * # Arguments
     *
     * * `callback` - Storage callback implementing PubkyAuthenticatedStorageCallback
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     *
     * # Example (Swift)
     *
     * ```swift
     * class MyPubkyStorage: PubkyAuthenticatedStorageCallback {
     * let session: PubkySession
     *
     * func put(path: String, content: String) -> StorageOperationResult {
     * do {
     * try session.storage.put(path, content)
     * return StorageOperationResult.ok()
     * } catch {
     * return StorageOperationResult.err(error.localizedDescription)
     * }
     * }
     * // ... implement other methods
     * }
     *
     * let transport = AuthenticatedTransportFFI.fromCallback(
     * MyPubkyStorage(session: session),
     * ownerPubkey: myPublicKey
     * )
     * ```
     */ fun `fromCallback`(`callback`: PubkyAuthenticatedStorageCallback, `ownerPubkey`: kotlin.String): AuthenticatedTransportFfi {
            return FfiConverterTypeAuthenticatedTransportFFI.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_callback(
        FfiConverterTypePubkyAuthenticatedStorageCallback.lower(`callback`),FfiConverterString.lower(`ownerPubkey`),_status)
}
    )
    }
    

        
    /**
     * Create authenticated transport from a Pubky session JSON.
     *
     * # Deprecated
     *
     * This method creates a mock transport. Use `from_callback()` for production.
     *
     * # Arguments
     *
     * * `session_json` - JSON configuration (validated but not used)
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     */
    @Throws(PaykitMobileException::class) fun `fromSessionJson`(`sessionJson`: kotlin.String, `ownerPubkey`: kotlin.String): AuthenticatedTransportFfi {
            return FfiConverterTypeAuthenticatedTransportFFI.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_session_json(
        FfiConverterString.lower(`sessionJson`),FfiConverterString.lower(`ownerPubkey`),_status)
}
    )
    }
    

        
    /**
     * Create a new authenticated transport for testing/development.
     *
     * Uses in-memory storage - data is not persisted.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     */ fun `newMock`(`ownerPubkey`: kotlin.String): AuthenticatedTransportFfi {
            return FfiConverterTypeAuthenticatedTransportFFI.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_new_mock(
        FfiConverterString.lower(`ownerPubkey`),_status)
}
    )
    }
    

        
    }
    
}

/**
 * @suppress
 */
public object FfiConverterTypeAuthenticatedTransportFFI: FfiConverter<AuthenticatedTransportFfi, Pointer> {

    override fun lower(value: AuthenticatedTransportFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): AuthenticatedTransportFfi {
        return AuthenticatedTransportFfi(value)
    }

    override fun read(buf: ByteBuffer): AuthenticatedTransportFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: AuthenticatedTransportFfi) = 8UL

    override fun write(value: AuthenticatedTransportFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * FFI-safe wrapper for local contact cache.
 */
public interface ContactCacheFfiInterface {
    
    /**
     * Add a contact by public key.
     */
    fun `add`(`pubkey`: kotlin.String)
    
    /**
     * Add a contact with a display name.
     */
    fun `addWithName`(`pubkey`: kotlin.String, `name`: kotlin.String)
    
    /**
     * Clear all cached contacts.
     */
    fun `clear`()
    
    /**
     * Check if a contact exists.
     */
    fun `contains`(`pubkey`: kotlin.String): kotlin.Boolean
    
    /**
     * Get the number of cached contacts.
     */
    fun `count`(): kotlin.UInt
    
    /**
     * Get a specific contact by public key.
     */
    fun `get`(`pubkey`: kotlin.String): CachedContactFfi?
    
    /**
     * Get all cached contacts.
     */
    fun `getAll`(): List<CachedContactFfi>
    
    /**
     * Remove a contact by public key.
     */
    fun `remove`(`pubkey`: kotlin.String)
    
    /**
     * Sync with remote contacts.
     */
    fun `sync`(`remotePubkeys`: List<kotlin.String>): SyncResultFfi
    
    companion object
}

/**
 * FFI-safe wrapper for local contact cache.
 */
open class ContactCacheFfi: Disposable, AutoCloseable, ContactCacheFfiInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a new contact cache (uses in-memory storage).
     */
    constructor() :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_contactcacheffi_new(
        _status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_contactcacheffi(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_contactcacheffi(pointer!!, status)
        }
    }

    
    /**
     * Add a contact by public key.
     */
    @Throws(StorageCacheException::class)override fun `add`(`pubkey`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_add(
        it, FfiConverterString.lower(`pubkey`),_status)
}
    }
    
    

    
    /**
     * Add a contact with a display name.
     */
    @Throws(StorageCacheException::class)override fun `addWithName`(`pubkey`: kotlin.String, `name`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_add_with_name(
        it, FfiConverterString.lower(`pubkey`),FfiConverterString.lower(`name`),_status)
}
    }
    
    

    
    /**
     * Clear all cached contacts.
     */
    @Throws(StorageCacheException::class)override fun `clear`()
        = 
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_clear(
        it, _status)
}
    }
    
    

    
    /**
     * Check if a contact exists.
     */
    @Throws(StorageCacheException::class)override fun `contains`(`pubkey`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_contains(
        it, FfiConverterString.lower(`pubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the number of cached contacts.
     */
    @Throws(StorageCacheException::class)override fun `count`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_count(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get a specific contact by public key.
     */
    @Throws(StorageCacheException::class)override fun `get`(`pubkey`: kotlin.String): CachedContactFfi? {
            return FfiConverterOptionalTypeCachedContactFFI.lift(
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_get(
        it, FfiConverterString.lower(`pubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * Get all cached contacts.
     */
    @Throws(StorageCacheException::class)override fun `getAll`(): List<CachedContactFfi> {
            return FfiConverterSequenceTypeCachedContactFFI.lift(
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_get_all(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Remove a contact by public key.
     */
    @Throws(StorageCacheException::class)override fun `remove`(`pubkey`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_remove(
        it, FfiConverterString.lower(`pubkey`),_status)
}
    }
    
    

    
    /**
     * Sync with remote contacts.
     */
    @Throws(StorageCacheException::class)override fun `sync`(`remotePubkeys`: List<kotlin.String>): SyncResultFfi {
            return FfiConverterTypeSyncResultFFI.lift(
    callWithPointer {
    uniffiRustCallWithError(StorageCacheException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_contactcacheffi_sync(
        it, FfiConverterSequenceString.lower(`remotePubkeys`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeContactCacheFFI: FfiConverter<ContactCacheFfi, Pointer> {

    override fun lower(value: ContactCacheFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ContactCacheFfi {
        return ContactCacheFfi(value)
    }

    override fun read(buf: ByteBuffer): ContactCacheFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ContactCacheFfi) = 8UL

    override fun write(value: ContactCacheFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Async directory operations manager.
 *
 * Provides non-blocking directory operations with callback support.
 */
public interface DirectoryOperationsAsyncInterface {
    
    /**
     * Add a contact asynchronously.
     */
    fun `addContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: kotlin.String)
    
    /**
     * Fetch known contacts asynchronously.
     */
    fun `fetchKnownContacts`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String): List<kotlin.String>
    
    /**
     * Fetch a specific payment endpoint asynchronously.
     */
    fun `fetchPaymentEndpoint`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String, `methodId`: kotlin.String): kotlin.String?
    
    /**
     * Fetch all supported payment methods asynchronously.
     */
    fun `fetchSupportedPayments`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String): List<PaymentMethod>
    
    /**
     * List all contacts asynchronously.
     */
    fun `listContacts`(`transport`: AuthenticatedTransportFfi): List<kotlin.String>
    
    /**
     * Publish a payment endpoint asynchronously.
     *
     * This is a blocking call that wraps the async operation.
     * For true non-blocking behavior, use the callback-based methods from mobile SDKs.
     */
    fun `publishPaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: kotlin.String, `endpointData`: kotlin.String)
    
    /**
     * Remove a contact asynchronously.
     */
    fun `removeContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: kotlin.String)
    
    /**
     * Remove a payment endpoint asynchronously.
     */
    fun `removePaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: kotlin.String)
    
    companion object
}

/**
 * Async directory operations manager.
 *
 * Provides non-blocking directory operations with callback support.
 */
open class DirectoryOperationsAsync: Disposable, AutoCloseable, DirectoryOperationsAsyncInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a new async directory operations manager.
     */
    constructor() :
        this(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_directoryoperationsasync_new(
        _status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_directoryoperationsasync(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_directoryoperationsasync(pointer!!, status)
        }
    }

    
    /**
     * Add a contact asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `addContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_add_contact(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`contactPubkey`),_status)
}
    }
    
    

    
    /**
     * Fetch known contacts asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `fetchKnownContacts`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_known_contacts(
        it, FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * Fetch a specific payment endpoint asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `fetchPaymentEndpoint`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String, `methodId`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_payment_endpoint(
        it, FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),FfiConverterString.lower(`methodId`),_status)
}
    }
    )
    }
    

    
    /**
     * Fetch all supported payment methods asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `fetchSupportedPayments`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String): List<PaymentMethod> {
            return FfiConverterSequenceTypePaymentMethod.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_supported_payments(
        it, FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * List all contacts asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `listContacts`(`transport`: AuthenticatedTransportFfi): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_list_contacts(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),_status)
}
    }
    )
    }
    

    
    /**
     * Publish a payment endpoint asynchronously.
     *
     * This is a blocking call that wraps the async operation.
     * For true non-blocking behavior, use the callback-based methods from mobile SDKs.
     */
    @Throws(PaykitMobileException::class)override fun `publishPaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: kotlin.String, `endpointData`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_publish_payment_endpoint(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpointData`),_status)
}
    }
    
    

    
    /**
     * Remove a contact asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `removeContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_contact(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`contactPubkey`),_status)
}
    }
    
    

    
    /**
     * Remove a payment endpoint asynchronously.
     */
    @Throws(PaykitMobileException::class)override fun `removePaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_payment_endpoint(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`methodId`),_status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeDirectoryOperationsAsync: FfiConverter<DirectoryOperationsAsync, Pointer> {

    override fun lower(value: DirectoryOperationsAsync): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): DirectoryOperationsAsync {
        return DirectoryOperationsAsync(value)
    }

    override fun read(buf: ByteBuffer): DirectoryOperationsAsync {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: DirectoryOperationsAsync) = 8UL

    override fun write(value: DirectoryOperationsAsync, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Async bridge for executor operations.
 *
 * Provides async wrappers for Bitcoin and Lightning executor operations
 * with timeout handling and cancellation support. This is useful when
 * you need to wrap synchronous wallet operations with timeout handling.
 *
 * # Usage
 *
 * ```ignore
 * let bridge = ExecutorAsyncBridge::new()?;
 *
 * // Execute with default 30s timeout
 * let result = bridge.execute_bitcoin_operation(|| {
 * // Your wallet operation here
 * wallet.send_to_address(address, amount)
 * }, None)?;
 *
 * // Execute with custom 60s timeout
 * let result = bridge.execute_lightning_operation(|| {
 * // Your node operation here
 * node.pay_invoice(invoice)
 * }, Some(60000))?;
 * ```
 *
 * # Timeout Handling
 *
 * If an operation exceeds the timeout, a `PaykitMobileError::Transport`
 * error is returned with message "Bitcoin/Lightning operation timed out".
 *
 * # Thread Safety
 *
 * The bridge manages its own Tokio runtime and is safe to use from any thread.
 * Operations are executed on the runtime's thread pool.
 *
 * # Cancellation
 *
 * Use `execute_with_cancellation()` to get an `AsyncHandle` that can be used
 * to cancel long-running operations.
 */
public interface ExecutorAsyncBridgeInterface {
    
    /**
     * Get the default timeout in milliseconds.
     */
    fun `defaultTimeoutMs`(): kotlin.ULong
    
    companion object
}

/**
 * Async bridge for executor operations.
 *
 * Provides async wrappers for Bitcoin and Lightning executor operations
 * with timeout handling and cancellation support. This is useful when
 * you need to wrap synchronous wallet operations with timeout handling.
 *
 * # Usage
 *
 * ```ignore
 * let bridge = ExecutorAsyncBridge::new()?;
 *
 * // Execute with default 30s timeout
 * let result = bridge.execute_bitcoin_operation(|| {
 * // Your wallet operation here
 * wallet.send_to_address(address, amount)
 * }, None)?;
 *
 * // Execute with custom 60s timeout
 * let result = bridge.execute_lightning_operation(|| {
 * // Your node operation here
 * node.pay_invoice(invoice)
 * }, Some(60000))?;
 * ```
 *
 * # Timeout Handling
 *
 * If an operation exceeds the timeout, a `PaykitMobileError::Transport`
 * error is returned with message "Bitcoin/Lightning operation timed out".
 *
 * # Thread Safety
 *
 * The bridge manages its own Tokio runtime and is safe to use from any thread.
 * Operations are executed on the runtime's thread pool.
 *
 * # Cancellation
 *
 * Use `execute_with_cancellation()` to get an `AsyncHandle` that can be used
 * to cancel long-running operations.
 */
open class ExecutorAsyncBridge: Disposable, AutoCloseable, ExecutorAsyncBridgeInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a new executor async bridge.
     */
    constructor() :
        this(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_executorasyncbridge_new(
        _status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_executorasyncbridge(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_executorasyncbridge(pointer!!, status)
        }
    }

    
    /**
     * Get the default timeout in milliseconds.
     */override fun `defaultTimeoutMs`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_executorasyncbridge_default_timeout_ms(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create with custom timeout.
     */
    @Throws(PaykitMobileException::class) fun `withTimeout`(`timeoutMs`: kotlin.ULong): ExecutorAsyncBridge {
            return FfiConverterTypeExecutorAsyncBridge.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_executorasyncbridge_with_timeout(
        FfiConverterULong.lower(`timeoutMs`),_status)
}
    )
    }
    

        
    }
    
}

/**
 * @suppress
 */
public object FfiConverterTypeExecutorAsyncBridge: FfiConverter<ExecutorAsyncBridge, Pointer> {

    override fun lower(value: ExecutorAsyncBridge): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ExecutorAsyncBridge {
        return ExecutorAsyncBridge(value)
    }

    override fun read(buf: ByteBuffer): ExecutorAsyncBridge {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ExecutorAsyncBridge) = 8UL

    override fun write(value: ExecutorAsyncBridge, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Main Paykit client for mobile applications.
 */
public interface PaykitClientInterface {
    
    /**
     * Add a contact to the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to add
     */
    fun `addContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: kotlin.String)
    
    /**
     * Get the configured Bitcoin network.
     */
    fun `bitcoinNetwork`(): BitcoinNetworkFfi
    
    /**
     * Calculate proration for a subscription modification.
     */
    fun `calculateProration`(`currentAmountSats`: kotlin.Long, `newAmountSats`: kotlin.Long, `periodStart`: kotlin.Long, `periodEnd`: kotlin.Long, `changeDate`: kotlin.Long): ProrationResult
    
    /**
     * Check health of all payment methods.
     */
    fun `checkHealth`(): List<HealthCheckResult>
    
    /**
     * Create an error message for Noise channel.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error description
     */
    fun `createNoiseErrorMessage`(`code`: kotlin.String, `message`: kotlin.String): NoisePaymentMessage
    
    /**
     * Create a payment request.
     */
    fun `createPaymentRequest`(`fromPubkey`: kotlin.String, `toPubkey`: kotlin.String, `amountSats`: kotlin.Long, `currency`: kotlin.String, `methodId`: kotlin.String, `description`: kotlin.String, `expiresInSecs`: kotlin.ULong?): PaymentRequest
    
    /**
     * Create a new receipt.
     */
    fun `createReceipt`(`payer`: kotlin.String, `payee`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?): Receipt
    
    /**
     * Create a receipt confirmation message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - The receipt ID being confirmed
     * * `payer_pubkey` - Payer's public key
     * * `payee_pubkey` - Payee's public key
     * * `method_id` - Payment method used
     * * `amount` - Payment amount
     * * `currency` - Currency code
     * * `signature` - Optional signature from payee
     */
    fun `createReceiptConfirmationMessage`(`receiptId`: kotlin.String, `payerPubkey`: kotlin.String, `payeePubkey`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?, `signature`: kotlin.String?): NoisePaymentMessage
    
    /**
     * Create a receipt request message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - Unique identifier for this receipt
     * * `payer_pubkey` - Payer's public key (z-base32)
     * * `payee_pubkey` - Payee's public key (z-base32)
     * * `method_id` - Payment method identifier
     * * `amount` - Optional payment amount
     * * `currency` - Optional currency code
     */
    fun `createReceiptRequestMessage`(`receiptId`: kotlin.String, `payerPubkey`: kotlin.String, `payeePubkey`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?): NoisePaymentMessage
    
    /**
     * Create a new subscription.
     */
    fun `createSubscription`(`subscriber`: kotlin.String, `provider`: kotlin.String, `terms`: SubscriptionTerms): Subscription
    
    /**
     * Get days remaining in current billing period.
     */
    fun `daysRemainingInPeriod`(`periodEnd`: kotlin.Long): kotlin.UInt
    
    /**
     * Discover a Noise endpoint for a recipient.
     *
     * Queries the recipient's public directory for their Noise server information.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The noise endpoint info if found, None otherwise.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * if let Some(endpoint) = client.discover_noise_endpoint(transport, "8pinxxgqs41...")? {
     * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
     * }
     * ```
     */
    fun `discoverNoiseEndpoint`(`transport`: UnauthenticatedTransportFfi, `recipientPubkey`: kotlin.String): NoiseEndpointInfo?
    
    /**
     * Execute a payment using the registered executor.
     *
     * This method executes a real payment using the wallet executor that was
     * registered via `register_bitcoin_executor` or `register_lightning_executor`.
     *
     * # Arguments
     *
     * * `method_id` - Payment method ("onchain" or "lightning")
     * * `endpoint` - Payment destination (Bitcoin address or Lightning invoice)
     * * `amount_sats` - Amount to send in satoshis
     * * `metadata_json` - Optional JSON metadata (e.g., fee rate preferences)
     *
     * # Returns
     *
     * `PaymentExecutionResult` with success/failure status and execution details.
     *
     * # Example
     *
     * ```ignore
     * // After registering executors
     * let result = client.execute_payment(
     * "lightning",
     * "lnbc1000n1...",
     * 1000,
     * None
     * )?;
     *
     * if result.success {
     * println!("Payment succeeded: {}", result.execution_id);
     * }
     * ```
     */
    fun `executePayment`(`methodId`: kotlin.String, `endpoint`: kotlin.String, `amountSats`: kotlin.ULong, `metadataJson`: kotlin.String?): PaymentExecutionResult
    
    /**
     * Execute a payment with automatic fallback to alternative methods.
     *
     * This method implements the PDF-mandated fallback behavior:
     * - Attempts the primary method first
     * - On retryable failure, tries each fallback in order
     * - Stops on success or non-retryable failure (to avoid double-spend)
     *
     * # Arguments
     *
     * * `candidates` - Ordered list of payment methods to try (primary first, then fallbacks)
     * * `amount_sats` - Amount to send in satoshis
     * * `metadata_json` - Optional metadata as JSON
     *
     * # Returns
     *
     * `FallbackExecutionResult` containing the outcome and all attempts made.
     *
     * # Example
     *
     * ```ignore
     * let candidates = vec![
     * PaymentCandidate { method_id: "lightning".into(), endpoint: "lnbc1000n1...".into() },
     * PaymentCandidate { method_id: "onchain".into(), endpoint: "bc1q...".into() },
     * ];
     * let result = client.execute_with_fallbacks(candidates, 1000, None)?;
     * if result.success {
     * println!("Paid via {}", result.successful_execution.unwrap().method_id);
     * } else {
     * println!("All methods failed: {}", result.summary);
     * }
     * ```
     */
    fun `executeWithFallbacks`(`candidates`: List<PaymentCandidate>, `amountSats`: kotlin.ULong, `metadataJson`: kotlin.String?): FallbackExecutionResult
    
    /**
     * Extract public key from scanned QR code.
     */
    fun `extractKeyFromQr`(`scannedData`: kotlin.String): kotlin.String?
    
    /**
     * Extract payment method from scanned QR code.
     */
    fun `extractMethodFromQr`(`scannedData`: kotlin.String): kotlin.String?
    
    /**
     * Fetch known contacts for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     *
     * # Returns
     *
     * List of contact public keys.
     */
    fun `fetchKnownContacts`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String): List<kotlin.String>
    
    /**
     * Fetch a specific payment endpoint for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     * * `method_id` - The payment method to fetch
     *
     * # Returns
     *
     * The endpoint data if found, None otherwise.
     */
    fun `fetchPaymentEndpoint`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String, `methodId`: kotlin.String): kotlin.String?
    
    /**
     * Fetch all supported payment methods for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query (z-base32 encoded)
     *
     * # Returns
     *
     * List of payment methods with their endpoints.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * let methods = client.fetch_supported_payments(transport, "8pinxxgqs41...")?;
     * for method in methods {
     * println!("{}: {}", method.method_id, method.endpoint);
     * }
     * ```
     */
    fun `fetchSupportedPayments`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String): List<PaymentMethod>
    
    /**
     * Generate a payment proof from an execution result.
     *
     * After a successful payment, call this to generate cryptographic proof
     * of payment (e.g., transaction ID for on-chain, preimage for Lightning).
     *
     * # Arguments
     *
     * * `method_id` - Payment method used
     * * `execution_data_json` - The execution data from `execute_payment` result
     *
     * # Returns
     *
     * `PaymentProofResult` containing the proof type and data.
     */
    fun `generatePaymentProof`(`methodId`: kotlin.String, `executionDataJson`: kotlin.String): PaymentProofResult
    
    /**
     * Get health status of a specific method.
     */
    fun `getHealthStatus`(`methodId`: kotlin.String): HealthStatus?
    
    /**
     * Get all in-progress payments.
     */
    fun `getInProgressPayments`(): List<PaymentStatusInfo>
    
    /**
     * Get payment status for a receipt.
     */
    fun `getPaymentStatus`(`receiptId`: kotlin.String): PaymentStatusInfo?
    
    /**
     * Check if a Bitcoin executor has been registered.
     *
     * Note: This checks if the onchain method is registered. After calling
     * `register_bitcoin_executor`, this will return true.
     */
    fun `hasBitcoinExecutor`(): kotlin.Boolean
    
    /**
     * Check if a Lightning executor has been registered.
     *
     * Note: This checks if the lightning method is registered. After calling
     * `register_lightning_executor`, this will return true.
     */
    fun `hasLightningExecutor`(): kotlin.Boolean
    
    /**
     * Check if a method is usable (healthy or degraded).
     */
    fun `isMethodUsable`(`methodId`: kotlin.String): kotlin.Boolean
    
    /**
     * Check if scanned data looks like a Paykit URI.
     */
    fun `isPaykitQr`(`scannedData`: kotlin.String): kotlin.Boolean
    
    /**
     * Get the configured Lightning network.
     */
    fun `lightningNetwork`(): LightningNetworkFfi
    
    /**
     * List all contacts.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     *
     * # Returns
     *
     * List of contact public keys.
     */
    fun `listContacts`(`transport`: AuthenticatedTransportFfi): List<kotlin.String>
    
    /**
     * Get the list of registered payment methods.
     */
    fun `listMethods`(): List<kotlin.String>
    
    /**
     * Parse a payment message from JSON.
     *
     * # Arguments
     *
     * * `json` - The JSON string to parse
     */
    fun `parseNoisePaymentMessage`(`json`: kotlin.String): NoisePaymentMessage
    
    /**
     * Parse receipt metadata as JSON.
     */
    fun `parseReceiptMetadata`(`metadataJson`: kotlin.String): kotlin.String
    
    /**
     * Parse scanned QR code data as a Paykit URI.
     */
    fun `parseScannedQr`(`scannedData`: kotlin.String): ScannedUri
    
    /**
     * Publish a Noise endpoint to the directory.
     *
     * Makes this device discoverable for receiving payments via Noise protocol.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     * * `host` - Host address where the Noise server is listening
     * * `port` - Port number where the Noise server is listening
     * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
     * * `metadata` - Optional metadata about the endpoint
     */
    fun `publishNoiseEndpoint`(`transport`: AuthenticatedTransportFfi, `host`: kotlin.String, `port`: kotlin.UShort, `noisePubkey`: kotlin.String, `metadata`: kotlin.String?)
    
    /**
     * Publish a payment endpoint to the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint_data` - The endpoint data to publish
     *
     * # Example
     *
     * ```ignore
     * let transport = AuthenticatedTransportFFI::from_session_json(session, pubkey)?;
     * client.publish_payment_endpoint(transport, "lightning", "lnbc1...")?;
     * ```
     */
    fun `publishPaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: kotlin.String, `endpointData`: kotlin.String)
    
    /**
     * Register a Bitcoin executor for on-chain payments.
     *
     * This allows Bitkit or other wallets to provide their wallet implementation
     * as the executor for on-chain Bitcoin payments. The executor handles:
     * - Sending payments to addresses
     * - Estimating fees
     * - Verifying transactions
     *
     * # Arguments
     *
     * * `executor` - Implementation of `BitcoinExecutorFFI` from the wallet
     *
     * # Example (Swift)
     *
     * ```swift
     * class BitkitBitcoinExecutor: BitcoinExecutorFFI {
     * func sendToAddress(address: String, amountSats: UInt64, feeRate: Double?) throws -> BitcoinTxResultFFI {
     * // Implement using Bitkit wallet
     * }
     * // ... other methods
     * }
     *
     * let client = PaykitClient.newWithNetwork(
     * bitcoinNetwork: .mainnet,
     * lightningNetwork: .mainnet
     * )
     * try client.registerBitcoinExecutor(executor: BitkitBitcoinExecutor())
     * ```
     */
    fun `registerBitcoinExecutor`(`executor`: BitcoinExecutorFfi)
    
    /**
     * Register a Lightning executor for Lightning Network payments.
     *
     * This allows Bitkit or other wallets to provide their Lightning node
     * implementation as the executor for Lightning payments. The executor handles:
     * - Paying BOLT11 invoices
     * - Decoding invoices
     * - Estimating routing fees
     * - Verifying payments via preimage
     *
     * # Arguments
     *
     * * `executor` - Implementation of `LightningExecutorFFI` from the wallet
     *
     * # Example (Swift)
     *
     * ```swift
     * class BitkitLightningExecutor: LightningExecutorFFI {
     * func payInvoice(invoice: String, amountMsat: UInt64?, maxFeeMsat: UInt64?) throws -> LightningPaymentResultFFI {
     * // Implement using Bitkit Lightning node
     * }
     * // ... other methods
     * }
     *
     * try client.registerLightningExecutor(executor: BitkitLightningExecutor())
     * ```
     */
    fun `registerLightningExecutor`(`executor`: LightningExecutorFfi)
    
    /**
     * Remove a contact from the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to remove
     */
    fun `removeContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: kotlin.String)
    
    /**
     * Remove the Noise endpoint from the directory.
     *
     * Makes this device no longer discoverable for Noise payments.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     */
    fun `removeNoiseEndpoint`(`transport`: AuthenticatedTransportFfi)
    
    /**
     * Remove a payment endpoint from the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier to remove
     */
    fun `removePaymentEndpointFromDirectory`(`transport`: AuthenticatedTransportFfi, `methodId`: kotlin.String)
    
    /**
     * Select the best payment method from supported options.
     */
    fun `selectMethod`(`supportedMethods`: List<PaymentMethod>, `amountSats`: kotlin.ULong, `preferences`: SelectionPreferences?): SelectionResult
    
    /**
     * Validate an endpoint for a specific method.
     */
    fun `validateEndpoint`(`methodId`: kotlin.String, `endpoint`: kotlin.String): kotlin.Boolean
    
    companion object
}

/**
 * Main Paykit client for mobile applications.
 */
open class PaykitClient: Disposable, AutoCloseable, PaykitClientInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a new Paykit client with default (mainnet) network configuration.
     */
    constructor() :
        this(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_paykitclient_new(
        _status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_paykitclient(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_paykitclient(pointer!!, status)
        }
    }

    
    /**
     * Add a contact to the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to add
     */
    @Throws(PaykitMobileException::class)override fun `addContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_add_contact(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`contactPubkey`),_status)
}
    }
    
    

    
    /**
     * Get the configured Bitcoin network.
     */override fun `bitcoinNetwork`(): BitcoinNetworkFfi {
            return FfiConverterTypeBitcoinNetworkFFI.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_bitcoin_network(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Calculate proration for a subscription modification.
     */
    @Throws(PaykitMobileException::class)override fun `calculateProration`(`currentAmountSats`: kotlin.Long, `newAmountSats`: kotlin.Long, `periodStart`: kotlin.Long, `periodEnd`: kotlin.Long, `changeDate`: kotlin.Long): ProrationResult {
            return FfiConverterTypeProrationResult.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_calculate_proration(
        it, FfiConverterLong.lower(`currentAmountSats`),FfiConverterLong.lower(`newAmountSats`),FfiConverterLong.lower(`periodStart`),FfiConverterLong.lower(`periodEnd`),FfiConverterLong.lower(`changeDate`),_status)
}
    }
    )
    }
    

    
    /**
     * Check health of all payment methods.
     */override fun `checkHealth`(): List<HealthCheckResult> {
            return FfiConverterSequenceTypeHealthCheckResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_check_health(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Create an error message for Noise channel.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error description
     */
    @Throws(PaykitMobileException::class)override fun `createNoiseErrorMessage`(`code`: kotlin.String, `message`: kotlin.String): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_noise_error_message(
        it, FfiConverterString.lower(`code`),FfiConverterString.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a payment request.
     */
    @Throws(PaykitMobileException::class)override fun `createPaymentRequest`(`fromPubkey`: kotlin.String, `toPubkey`: kotlin.String, `amountSats`: kotlin.Long, `currency`: kotlin.String, `methodId`: kotlin.String, `description`: kotlin.String, `expiresInSecs`: kotlin.ULong?): PaymentRequest {
            return FfiConverterTypePaymentRequest.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_payment_request(
        it, FfiConverterString.lower(`fromPubkey`),FfiConverterString.lower(`toPubkey`),FfiConverterLong.lower(`amountSats`),FfiConverterString.lower(`currency`),FfiConverterString.lower(`methodId`),FfiConverterString.lower(`description`),FfiConverterOptionalULong.lower(`expiresInSecs`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a new receipt.
     */
    @Throws(PaykitMobileException::class)override fun `createReceipt`(`payer`: kotlin.String, `payee`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?): Receipt {
            return FfiConverterTypeReceipt.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_receipt(
        it, FfiConverterString.lower(`payer`),FfiConverterString.lower(`payee`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a receipt confirmation message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - The receipt ID being confirmed
     * * `payer_pubkey` - Payer's public key
     * * `payee_pubkey` - Payee's public key
     * * `method_id` - Payment method used
     * * `amount` - Payment amount
     * * `currency` - Currency code
     * * `signature` - Optional signature from payee
     */
    @Throws(PaykitMobileException::class)override fun `createReceiptConfirmationMessage`(`receiptId`: kotlin.String, `payerPubkey`: kotlin.String, `payeePubkey`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?, `signature`: kotlin.String?): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_confirmation_message(
        it, FfiConverterString.lower(`receiptId`),FfiConverterString.lower(`payerPubkey`),FfiConverterString.lower(`payeePubkey`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),FfiConverterOptionalString.lower(`signature`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a receipt request message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - Unique identifier for this receipt
     * * `payer_pubkey` - Payer's public key (z-base32)
     * * `payee_pubkey` - Payee's public key (z-base32)
     * * `method_id` - Payment method identifier
     * * `amount` - Optional payment amount
     * * `currency` - Optional currency code
     */
    @Throws(PaykitMobileException::class)override fun `createReceiptRequestMessage`(`receiptId`: kotlin.String, `payerPubkey`: kotlin.String, `payeePubkey`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_request_message(
        it, FfiConverterString.lower(`receiptId`),FfiConverterString.lower(`payerPubkey`),FfiConverterString.lower(`payeePubkey`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a new subscription.
     */
    @Throws(PaykitMobileException::class)override fun `createSubscription`(`subscriber`: kotlin.String, `provider`: kotlin.String, `terms`: SubscriptionTerms): Subscription {
            return FfiConverterTypeSubscription.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_create_subscription(
        it, FfiConverterString.lower(`subscriber`),FfiConverterString.lower(`provider`),FfiConverterTypeSubscriptionTerms.lower(`terms`),_status)
}
    }
    )
    }
    

    
    /**
     * Get days remaining in current billing period.
     */override fun `daysRemainingInPeriod`(`periodEnd`: kotlin.Long): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_days_remaining_in_period(
        it, FfiConverterLong.lower(`periodEnd`),_status)
}
    }
    )
    }
    

    
    /**
     * Discover a Noise endpoint for a recipient.
     *
     * Queries the recipient's public directory for their Noise server information.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The noise endpoint info if found, None otherwise.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * if let Some(endpoint) = client.discover_noise_endpoint(transport, "8pinxxgqs41...")? {
     * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
     * }
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `discoverNoiseEndpoint`(`transport`: UnauthenticatedTransportFfi, `recipientPubkey`: kotlin.String): NoiseEndpointInfo? {
            return FfiConverterOptionalTypeNoiseEndpointInfo.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_discover_noise_endpoint(
        it, FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`recipientPubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * Execute a payment using the registered executor.
     *
     * This method executes a real payment using the wallet executor that was
     * registered via `register_bitcoin_executor` or `register_lightning_executor`.
     *
     * # Arguments
     *
     * * `method_id` - Payment method ("onchain" or "lightning")
     * * `endpoint` - Payment destination (Bitcoin address or Lightning invoice)
     * * `amount_sats` - Amount to send in satoshis
     * * `metadata_json` - Optional JSON metadata (e.g., fee rate preferences)
     *
     * # Returns
     *
     * `PaymentExecutionResult` with success/failure status and execution details.
     *
     * # Example
     *
     * ```ignore
     * // After registering executors
     * let result = client.execute_payment(
     * "lightning",
     * "lnbc1000n1...",
     * 1000,
     * None
     * )?;
     *
     * if result.success {
     * println!("Payment succeeded: {}", result.execution_id);
     * }
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `executePayment`(`methodId`: kotlin.String, `endpoint`: kotlin.String, `amountSats`: kotlin.ULong, `metadataJson`: kotlin.String?): PaymentExecutionResult {
            return FfiConverterTypePaymentExecutionResult.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_execute_payment(
        it, FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),FfiConverterULong.lower(`amountSats`),FfiConverterOptionalString.lower(`metadataJson`),_status)
}
    }
    )
    }
    

    
    /**
     * Execute a payment with automatic fallback to alternative methods.
     *
     * This method implements the PDF-mandated fallback behavior:
     * - Attempts the primary method first
     * - On retryable failure, tries each fallback in order
     * - Stops on success or non-retryable failure (to avoid double-spend)
     *
     * # Arguments
     *
     * * `candidates` - Ordered list of payment methods to try (primary first, then fallbacks)
     * * `amount_sats` - Amount to send in satoshis
     * * `metadata_json` - Optional metadata as JSON
     *
     * # Returns
     *
     * `FallbackExecutionResult` containing the outcome and all attempts made.
     *
     * # Example
     *
     * ```ignore
     * let candidates = vec![
     * PaymentCandidate { method_id: "lightning".into(), endpoint: "lnbc1000n1...".into() },
     * PaymentCandidate { method_id: "onchain".into(), endpoint: "bc1q...".into() },
     * ];
     * let result = client.execute_with_fallbacks(candidates, 1000, None)?;
     * if result.success {
     * println!("Paid via {}", result.successful_execution.unwrap().method_id);
     * } else {
     * println!("All methods failed: {}", result.summary);
     * }
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `executeWithFallbacks`(`candidates`: List<PaymentCandidate>, `amountSats`: kotlin.ULong, `metadataJson`: kotlin.String?): FallbackExecutionResult {
            return FfiConverterTypeFallbackExecutionResult.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_execute_with_fallbacks(
        it, FfiConverterSequenceTypePaymentCandidate.lower(`candidates`),FfiConverterULong.lower(`amountSats`),FfiConverterOptionalString.lower(`metadataJson`),_status)
}
    }
    )
    }
    

    
    /**
     * Extract public key from scanned QR code.
     */override fun `extractKeyFromQr`(`scannedData`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_extract_key_from_qr(
        it, FfiConverterString.lower(`scannedData`),_status)
}
    }
    )
    }
    

    
    /**
     * Extract payment method from scanned QR code.
     */override fun `extractMethodFromQr`(`scannedData`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_extract_method_from_qr(
        it, FfiConverterString.lower(`scannedData`),_status)
}
    }
    )
    }
    

    
    /**
     * Fetch known contacts for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     *
     * # Returns
     *
     * List of contact public keys.
     */
    @Throws(PaykitMobileException::class)override fun `fetchKnownContacts`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_fetch_known_contacts(
        it, FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * Fetch a specific payment endpoint for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     * * `method_id` - The payment method to fetch
     *
     * # Returns
     *
     * The endpoint data if found, None otherwise.
     */
    @Throws(PaykitMobileException::class)override fun `fetchPaymentEndpoint`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String, `methodId`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_fetch_payment_endpoint(
        it, FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),FfiConverterString.lower(`methodId`),_status)
}
    }
    )
    }
    

    
    /**
     * Fetch all supported payment methods for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query (z-base32 encoded)
     *
     * # Returns
     *
     * List of payment methods with their endpoints.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * let methods = client.fetch_supported_payments(transport, "8pinxxgqs41...")?;
     * for method in methods {
     * println!("{}: {}", method.method_id, method.endpoint);
     * }
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `fetchSupportedPayments`(`transport`: UnauthenticatedTransportFfi, `ownerPubkey`: kotlin.String): List<PaymentMethod> {
            return FfiConverterSequenceTypePaymentMethod.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_fetch_supported_payments(
        it, FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`ownerPubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * Generate a payment proof from an execution result.
     *
     * After a successful payment, call this to generate cryptographic proof
     * of payment (e.g., transaction ID for on-chain, preimage for Lightning).
     *
     * # Arguments
     *
     * * `method_id` - Payment method used
     * * `execution_data_json` - The execution data from `execute_payment` result
     *
     * # Returns
     *
     * `PaymentProofResult` containing the proof type and data.
     */
    @Throws(PaykitMobileException::class)override fun `generatePaymentProof`(`methodId`: kotlin.String, `executionDataJson`: kotlin.String): PaymentProofResult {
            return FfiConverterTypePaymentProofResult.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_generate_payment_proof(
        it, FfiConverterString.lower(`methodId`),FfiConverterString.lower(`executionDataJson`),_status)
}
    }
    )
    }
    

    
    /**
     * Get health status of a specific method.
     */override fun `getHealthStatus`(`methodId`: kotlin.String): HealthStatus? {
            return FfiConverterOptionalTypeHealthStatus.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_get_health_status(
        it, FfiConverterString.lower(`methodId`),_status)
}
    }
    )
    }
    

    
    /**
     * Get all in-progress payments.
     */override fun `getInProgressPayments`(): List<PaymentStatusInfo> {
            return FfiConverterSequenceTypePaymentStatusInfo.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_get_in_progress_payments(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get payment status for a receipt.
     */override fun `getPaymentStatus`(`receiptId`: kotlin.String): PaymentStatusInfo? {
            return FfiConverterOptionalTypePaymentStatusInfo.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_get_payment_status(
        it, FfiConverterString.lower(`receiptId`),_status)
}
    }
    )
    }
    

    
    /**
     * Check if a Bitcoin executor has been registered.
     *
     * Note: This checks if the onchain method is registered. After calling
     * `register_bitcoin_executor`, this will return true.
     */override fun `hasBitcoinExecutor`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_has_bitcoin_executor(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Check if a Lightning executor has been registered.
     *
     * Note: This checks if the lightning method is registered. After calling
     * `register_lightning_executor`, this will return true.
     */override fun `hasLightningExecutor`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_has_lightning_executor(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Check if a method is usable (healthy or degraded).
     */override fun `isMethodUsable`(`methodId`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_is_method_usable(
        it, FfiConverterString.lower(`methodId`),_status)
}
    }
    )
    }
    

    
    /**
     * Check if scanned data looks like a Paykit URI.
     */override fun `isPaykitQr`(`scannedData`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_is_paykit_qr(
        it, FfiConverterString.lower(`scannedData`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the configured Lightning network.
     */override fun `lightningNetwork`(): LightningNetworkFfi {
            return FfiConverterTypeLightningNetworkFFI.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_lightning_network(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * List all contacts.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     *
     * # Returns
     *
     * List of contact public keys.
     */
    @Throws(PaykitMobileException::class)override fun `listContacts`(`transport`: AuthenticatedTransportFfi): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_list_contacts(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the list of registered payment methods.
     */override fun `listMethods`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_list_methods(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Parse a payment message from JSON.
     *
     * # Arguments
     *
     * * `json` - The JSON string to parse
     */
    @Throws(PaykitMobileException::class)override fun `parseNoisePaymentMessage`(`json`: kotlin.String): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_parse_noise_payment_message(
        it, FfiConverterString.lower(`json`),_status)
}
    }
    )
    }
    

    
    /**
     * Parse receipt metadata as JSON.
     */
    @Throws(PaykitMobileException::class)override fun `parseReceiptMetadata`(`metadataJson`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_parse_receipt_metadata(
        it, FfiConverterString.lower(`metadataJson`),_status)
}
    }
    )
    }
    

    
    /**
     * Parse scanned QR code data as a Paykit URI.
     */
    @Throws(PaykitMobileException::class)override fun `parseScannedQr`(`scannedData`: kotlin.String): ScannedUri {
            return FfiConverterTypeScannedUri.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_parse_scanned_qr(
        it, FfiConverterString.lower(`scannedData`),_status)
}
    }
    )
    }
    

    
    /**
     * Publish a Noise endpoint to the directory.
     *
     * Makes this device discoverable for receiving payments via Noise protocol.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     * * `host` - Host address where the Noise server is listening
     * * `port` - Port number where the Noise server is listening
     * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
     * * `metadata` - Optional metadata about the endpoint
     */
    @Throws(PaykitMobileException::class)override fun `publishNoiseEndpoint`(`transport`: AuthenticatedTransportFfi, `host`: kotlin.String, `port`: kotlin.UShort, `noisePubkey`: kotlin.String, `metadata`: kotlin.String?)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_publish_noise_endpoint(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`host`),FfiConverterUShort.lower(`port`),FfiConverterString.lower(`noisePubkey`),FfiConverterOptionalString.lower(`metadata`),_status)
}
    }
    
    

    
    /**
     * Publish a payment endpoint to the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint_data` - The endpoint data to publish
     *
     * # Example
     *
     * ```ignore
     * let transport = AuthenticatedTransportFFI::from_session_json(session, pubkey)?;
     * client.publish_payment_endpoint(transport, "lightning", "lnbc1...")?;
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `publishPaymentEndpoint`(`transport`: AuthenticatedTransportFfi, `methodId`: kotlin.String, `endpointData`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_publish_payment_endpoint(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpointData`),_status)
}
    }
    
    

    
    /**
     * Register a Bitcoin executor for on-chain payments.
     *
     * This allows Bitkit or other wallets to provide their wallet implementation
     * as the executor for on-chain Bitcoin payments. The executor handles:
     * - Sending payments to addresses
     * - Estimating fees
     * - Verifying transactions
     *
     * # Arguments
     *
     * * `executor` - Implementation of `BitcoinExecutorFFI` from the wallet
     *
     * # Example (Swift)
     *
     * ```swift
     * class BitkitBitcoinExecutor: BitcoinExecutorFFI {
     * func sendToAddress(address: String, amountSats: UInt64, feeRate: Double?) throws -> BitcoinTxResultFFI {
     * // Implement using Bitkit wallet
     * }
     * // ... other methods
     * }
     *
     * let client = PaykitClient.newWithNetwork(
     * bitcoinNetwork: .mainnet,
     * lightningNetwork: .mainnet
     * )
     * try client.registerBitcoinExecutor(executor: BitkitBitcoinExecutor())
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `registerBitcoinExecutor`(`executor`: BitcoinExecutorFfi)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_register_bitcoin_executor(
        it, FfiConverterTypeBitcoinExecutorFFI.lower(`executor`),_status)
}
    }
    
    

    
    /**
     * Register a Lightning executor for Lightning Network payments.
     *
     * This allows Bitkit or other wallets to provide their Lightning node
     * implementation as the executor for Lightning payments. The executor handles:
     * - Paying BOLT11 invoices
     * - Decoding invoices
     * - Estimating routing fees
     * - Verifying payments via preimage
     *
     * # Arguments
     *
     * * `executor` - Implementation of `LightningExecutorFFI` from the wallet
     *
     * # Example (Swift)
     *
     * ```swift
     * class BitkitLightningExecutor: LightningExecutorFFI {
     * func payInvoice(invoice: String, amountMsat: UInt64?, maxFeeMsat: UInt64?) throws -> LightningPaymentResultFFI {
     * // Implement using Bitkit Lightning node
     * }
     * // ... other methods
     * }
     *
     * try client.registerLightningExecutor(executor: BitkitLightningExecutor())
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `registerLightningExecutor`(`executor`: LightningExecutorFfi)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_register_lightning_executor(
        it, FfiConverterTypeLightningExecutorFFI.lower(`executor`),_status)
}
    }
    
    

    
    /**
     * Remove a contact from the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to remove
     */
    @Throws(PaykitMobileException::class)override fun `removeContact`(`transport`: AuthenticatedTransportFfi, `contactPubkey`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_remove_contact(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`contactPubkey`),_status)
}
    }
    
    

    
    /**
     * Remove the Noise endpoint from the directory.
     *
     * Makes this device no longer discoverable for Noise payments.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     */
    @Throws(PaykitMobileException::class)override fun `removeNoiseEndpoint`(`transport`: AuthenticatedTransportFfi)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_remove_noise_endpoint(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),_status)
}
    }
    
    

    
    /**
     * Remove a payment endpoint from the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier to remove
     */
    @Throws(PaykitMobileException::class)override fun `removePaymentEndpointFromDirectory`(`transport`: AuthenticatedTransportFfi, `methodId`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_remove_payment_endpoint_from_directory(
        it, FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`methodId`),_status)
}
    }
    
    

    
    /**
     * Select the best payment method from supported options.
     */
    @Throws(PaykitMobileException::class)override fun `selectMethod`(`supportedMethods`: List<PaymentMethod>, `amountSats`: kotlin.ULong, `preferences`: SelectionPreferences?): SelectionResult {
            return FfiConverterTypeSelectionResult.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_select_method(
        it, FfiConverterSequenceTypePaymentMethod.lower(`supportedMethods`),FfiConverterULong.lower(`amountSats`),FfiConverterOptionalTypeSelectionPreferences.lower(`preferences`),_status)
}
    }
    )
    }
    

    
    /**
     * Validate an endpoint for a specific method.
     */
    @Throws(PaykitMobileException::class)override fun `validateEndpoint`(`methodId`: kotlin.String, `endpoint`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitclient_validate_endpoint(
        it, FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),_status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a new Paykit client with specific network configuration.
     *
     * # Arguments
     *
     * * `bitcoin_network` - Bitcoin network to use (Mainnet, Testnet, or Regtest)
     * * `lightning_network` - Lightning network to use (Mainnet, Testnet, or Regtest)
     *
     * # Example
     *
     * ```ignore
     * // For testnet development
     * let client = PaykitClient::new_with_network(
     * BitcoinNetworkFFI::Testnet,
     * LightningNetworkFFI::Testnet,
     * )?;
     * ```
     */
    @Throws(PaykitMobileException::class) fun `newWithNetwork`(`bitcoinNetwork`: BitcoinNetworkFfi, `lightningNetwork`: LightningNetworkFfi): PaykitClient {
            return FfiConverterTypePaykitClient.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_paykitclient_new_with_network(
        FfiConverterTypeBitcoinNetworkFFI.lower(`bitcoinNetwork`),FfiConverterTypeLightningNetworkFFI.lower(`lightningNetwork`),_status)
}
    )
    }
    

        
    }
    
}

/**
 * @suppress
 */
public object FfiConverterTypePaykitClient: FfiConverter<PaykitClient, Pointer> {

    override fun lower(value: PaykitClient): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PaykitClient {
        return PaykitClient(value)
    }

    override fun read(buf: ByteBuffer): PaykitClient {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PaykitClient) = 8UL

    override fun write(value: PaykitClient, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * FFI wrapper for PaykitInteractiveManager.
 *
 * This provides a high-level interface for managing interactive payment flows
 * over Noise channels. Mobile apps use this to:
 *
 * 1. Process incoming messages and generate responses
 * 2. Initiate payment flows
 * 3. Manage receipts and private endpoints
 *
 * # Thread Safety
 *
 * This type is thread-safe and can be used from multiple threads.
 */
public interface PaykitInteractiveManagerFfiInterface {
    
    /**
     * Create a private endpoint offer message.
     *
     * Use this to offer a private payment endpoint to a peer.
     *
     * # Arguments
     *
     * * `method_id` - Payment method (e.g., "lightning")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice)
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    fun `createEndpointOffer`(`methodId`: kotlin.String, `endpoint`: kotlin.String): kotlin.String
    
    /**
     * Create a payment request message to initiate a payment flow.
     *
     * Use this to create the initial message for requesting payment from a peer.
     *
     * # Arguments
     *
     * * `payer` - Your public key (the one paying)
     * * `payee` - The recipient's public key
     * * `method_id` - Payment method (e.g., "lightning", "onchain")
     * * `amount` - Optional amount (as string, e.g., "1000")
     * * `currency` - Optional currency code (e.g., "SAT")
     * * `metadata_json` - Optional JSON metadata
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    fun `createPaymentRequest`(`payer`: kotlin.String, `payee`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?, `metadataJson`: kotlin.String?): kotlin.String
    
    /**
     * Get a private endpoint for a peer.
     */
    fun `getPrivateEndpoint`(`peer`: kotlin.String, `methodId`: kotlin.String): PrivateEndpointOffer?
    
    /**
     * Get a receipt by ID.
     */
    fun `getReceipt`(`receiptId`: kotlin.String): ReceiptRequest?
    
    /**
     * Get the receipt store.
     */
    fun `getStore`(): ReceiptStore
    
    /**
     * Handle an incoming message from a peer.
     *
     * This processes a JSON message received over a Noise channel and returns
     * an optional response to send back.
     *
     * # Arguments
     *
     * * `message_json` - The JSON-encoded message from the Noise channel
     * * `peer_pubkey` - The public key of the peer who sent the message
     * * `my_pubkey` - Your own public key
     *
     * # Returns
     *
     * Optional JSON response to send back over the Noise channel.
     * Returns `None` for messages that don't require a response (e.g., Ack).
     *
     * # Example
     *
     * ```ignore
     * // In Swift/Kotlin
     * let response = manager.handleMessage(messageJson, peerPubkey, myPubkey)
     * if let responseJson = response {
     * noiseChannel.send(responseJson)
     * }
     * ```
     */
    fun `handleMessage`(`messageJson`: kotlin.String, `peerPubkey`: kotlin.String, `myPubkey`: kotlin.String): kotlin.String?
    
    /**
     * Handle a payment confirmation response.
     *
     * Call this when you receive a response to your payment request.
     * It validates the response and saves the confirmed receipt.
     *
     * # Arguments
     *
     * * `response_json` - The JSON response from the Noise channel
     * * `original_receipt_id` - The receipt ID from your original request
     *
     * # Returns
     *
     * The confirmed receipt if successful, or an error.
     */
    fun `handlePaymentResponse`(`responseJson`: kotlin.String, `originalReceiptId`: kotlin.String): ReceiptRequest
    
    /**
     * List all private endpoints for a peer.
     */
    fun `listPrivateEndpoints`(`peer`: kotlin.String): List<PrivateEndpointOffer>
    
    /**
     * List all receipts.
     */
    fun `listReceipts`(): List<ReceiptRequest>
    
    /**
     * Set the receipt generator callback.
     *
     * This must be called before handling receipt requests.
     *
     * # Arguments
     *
     * * `generator` - Callback for generating receipts (implement in Swift/Kotlin)
     *
     * # Errors
     *
     * Returns an error if the internal lock is poisoned.
     */
    fun `setGenerator`(`generator`: ReceiptGeneratorCallback)
    
    companion object
}

/**
 * FFI wrapper for PaykitInteractiveManager.
 *
 * This provides a high-level interface for managing interactive payment flows
 * over Noise channels. Mobile apps use this to:
 *
 * 1. Process incoming messages and generate responses
 * 2. Initiate payment flows
 * 3. Manage receipts and private endpoints
 *
 * # Thread Safety
 *
 * This type is thread-safe and can be used from multiple threads.
 */
open class PaykitInteractiveManagerFfi: Disposable, AutoCloseable, PaykitInteractiveManagerFfiInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a new interactive manager without a generator.
     *
     * Use `set_generator` to set the receipt generator callback.
     *
     * # Arguments
     *
     * * `store` - Receipt store for persistence
     */
    constructor(`store`: ReceiptStore) :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_paykitinteractivemanagerffi_new(
        FfiConverterTypeReceiptStore.lower(`store`),_status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_paykitinteractivemanagerffi(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_paykitinteractivemanagerffi(pointer!!, status)
        }
    }

    
    /**
     * Create a private endpoint offer message.
     *
     * Use this to offer a private payment endpoint to a peer.
     *
     * # Arguments
     *
     * * `method_id` - Payment method (e.g., "lightning")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice)
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createEndpointOffer`(`methodId`: kotlin.String, `endpoint`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_endpoint_offer(
        it, FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a payment request message to initiate a payment flow.
     *
     * Use this to create the initial message for requesting payment from a peer.
     *
     * # Arguments
     *
     * * `payer` - Your public key (the one paying)
     * * `payee` - The recipient's public key
     * * `method_id` - Payment method (e.g., "lightning", "onchain")
     * * `amount` - Optional amount (as string, e.g., "1000")
     * * `currency` - Optional currency code (e.g., "SAT")
     * * `metadata_json` - Optional JSON metadata
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createPaymentRequest`(`payer`: kotlin.String, `payee`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?, `metadataJson`: kotlin.String?): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_payment_request(
        it, FfiConverterString.lower(`payer`),FfiConverterString.lower(`payee`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),FfiConverterOptionalString.lower(`metadataJson`),_status)
}
    }
    )
    }
    

    
    /**
     * Get a private endpoint for a peer.
     */
    @Throws(PaykitMobileException::class)override fun `getPrivateEndpoint`(`peer`: kotlin.String, `methodId`: kotlin.String): PrivateEndpointOffer? {
            return FfiConverterOptionalTypePrivateEndpointOffer.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_private_endpoint(
        it, FfiConverterString.lower(`peer`),FfiConverterString.lower(`methodId`),_status)
}
    }
    )
    }
    

    
    /**
     * Get a receipt by ID.
     */
    @Throws(PaykitMobileException::class)override fun `getReceipt`(`receiptId`: kotlin.String): ReceiptRequest? {
            return FfiConverterOptionalTypeReceiptRequest.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_receipt(
        it, FfiConverterString.lower(`receiptId`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the receipt store.
     */override fun `getStore`(): ReceiptStore {
            return FfiConverterTypeReceiptStore.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_store(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Handle an incoming message from a peer.
     *
     * This processes a JSON message received over a Noise channel and returns
     * an optional response to send back.
     *
     * # Arguments
     *
     * * `message_json` - The JSON-encoded message from the Noise channel
     * * `peer_pubkey` - The public key of the peer who sent the message
     * * `my_pubkey` - Your own public key
     *
     * # Returns
     *
     * Optional JSON response to send back over the Noise channel.
     * Returns `None` for messages that don't require a response (e.g., Ack).
     *
     * # Example
     *
     * ```ignore
     * // In Swift/Kotlin
     * let response = manager.handleMessage(messageJson, peerPubkey, myPubkey)
     * if let responseJson = response {
     * noiseChannel.send(responseJson)
     * }
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `handleMessage`(`messageJson`: kotlin.String, `peerPubkey`: kotlin.String, `myPubkey`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_message(
        it, FfiConverterString.lower(`messageJson`),FfiConverterString.lower(`peerPubkey`),FfiConverterString.lower(`myPubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * Handle a payment confirmation response.
     *
     * Call this when you receive a response to your payment request.
     * It validates the response and saves the confirmed receipt.
     *
     * # Arguments
     *
     * * `response_json` - The JSON response from the Noise channel
     * * `original_receipt_id` - The receipt ID from your original request
     *
     * # Returns
     *
     * The confirmed receipt if successful, or an error.
     */
    @Throws(PaykitMobileException::class)override fun `handlePaymentResponse`(`responseJson`: kotlin.String, `originalReceiptId`: kotlin.String): ReceiptRequest {
            return FfiConverterTypeReceiptRequest.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_payment_response(
        it, FfiConverterString.lower(`responseJson`),FfiConverterString.lower(`originalReceiptId`),_status)
}
    }
    )
    }
    

    
    /**
     * List all private endpoints for a peer.
     */
    @Throws(PaykitMobileException::class)override fun `listPrivateEndpoints`(`peer`: kotlin.String): List<PrivateEndpointOffer> {
            return FfiConverterSequenceTypePrivateEndpointOffer.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_private_endpoints(
        it, FfiConverterString.lower(`peer`),_status)
}
    }
    )
    }
    

    
    /**
     * List all receipts.
     */
    @Throws(PaykitMobileException::class)override fun `listReceipts`(): List<ReceiptRequest> {
            return FfiConverterSequenceTypeReceiptRequest.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_receipts(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Set the receipt generator callback.
     *
     * This must be called before handling receipt requests.
     *
     * # Arguments
     *
     * * `generator` - Callback for generating receipts (implement in Swift/Kotlin)
     *
     * # Errors
     *
     * Returns an error if the internal lock is poisoned.
     */
    @Throws(PaykitMobileException::class)override fun `setGenerator`(`generator`: ReceiptGeneratorCallback)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_set_generator(
        it, FfiConverterTypeReceiptGeneratorCallback.lower(`generator`),_status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypePaykitInteractiveManagerFFI: FfiConverter<PaykitInteractiveManagerFfi, Pointer> {

    override fun lower(value: PaykitInteractiveManagerFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PaykitInteractiveManagerFfi {
        return PaykitInteractiveManagerFfi(value)
    }

    override fun read(buf: ByteBuffer): PaykitInteractiveManagerFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PaykitInteractiveManagerFfi) = 8UL

    override fun write(value: PaykitInteractiveManagerFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Builder for creating Paykit protocol messages.
 *
 * Use this to create JSON messages for sending over Noise channels.
 */
public interface PaykitMessageBuilderInterface {
    
    /**
     * Create an acknowledgment message.
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createAck`(): kotlin.String
    
    /**
     * Create an endpoint offer message.
     *
     * # Arguments
     *
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice, Bitcoin address)
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createEndpointOffer`(`methodId`: kotlin.String, `endpoint`: kotlin.String): kotlin.String
    
    /**
     * Create an error message.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error message
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createError`(`code`: kotlin.String, `message`: kotlin.String): kotlin.String
    
    /**
     * Create a receipt confirmation message.
     *
     * # Arguments
     *
     * * `receipt` - The confirmed receipt details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createReceiptConfirm`(`receipt`: ReceiptRequest): kotlin.String
    
    /**
     * Create a receipt request message.
     *
     * # Arguments
     *
     * * `request` - The receipt request details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    fun `createReceiptRequest`(`request`: ReceiptRequest): kotlin.String
    
    /**
     * Get the message type from a JSON message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message
     *
     * # Returns
     *
     * The message type.
     */
    fun `getMessageType`(`messageJson`: kotlin.String): PaykitMessageType
    
    /**
     * Parse a received message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message from Noise channel
     *
     * # Returns
     *
     * Parsed message for processing.
     */
    fun `parseMessage`(`messageJson`: kotlin.String): ParsedMessage
    
    companion object
}

/**
 * Builder for creating Paykit protocol messages.
 *
 * Use this to create JSON messages for sending over Noise channels.
 */
open class PaykitMessageBuilder: Disposable, AutoCloseable, PaykitMessageBuilderInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a new message builder.
     */
    constructor() :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_paykitmessagebuilder_new(
        _status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_paykitmessagebuilder(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_paykitmessagebuilder(pointer!!, status)
        }
    }

    
    /**
     * Create an acknowledgment message.
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createAck`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_ack(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Create an endpoint offer message.
     *
     * # Arguments
     *
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice, Bitcoin address)
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createEndpointOffer`(`methodId`: kotlin.String, `endpoint`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_endpoint_offer(
        it, FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),_status)
}
    }
    )
    }
    

    
    /**
     * Create an error message.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error message
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createError`(`code`: kotlin.String, `message`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_error(
        it, FfiConverterString.lower(`code`),FfiConverterString.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a receipt confirmation message.
     *
     * # Arguments
     *
     * * `receipt` - The confirmed receipt details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createReceiptConfirm`(`receipt`: ReceiptRequest): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_confirm(
        it, FfiConverterTypeReceiptRequest.lower(`receipt`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a receipt request message.
     *
     * # Arguments
     *
     * * `request` - The receipt request details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    @Throws(PaykitMobileException::class)override fun `createReceiptRequest`(`request`: ReceiptRequest): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_request(
        it, FfiConverterTypeReceiptRequest.lower(`request`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the message type from a JSON message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message
     *
     * # Returns
     *
     * The message type.
     */
    @Throws(PaykitMobileException::class)override fun `getMessageType`(`messageJson`: kotlin.String): PaykitMessageType {
            return FfiConverterTypePaykitMessageType.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_get_message_type(
        it, FfiConverterString.lower(`messageJson`),_status)
}
    }
    )
    }
    

    
    /**
     * Parse a received message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message from Noise channel
     *
     * # Returns
     *
     * Parsed message for processing.
     */
    @Throws(PaykitMobileException::class)override fun `parseMessage`(`messageJson`: kotlin.String): ParsedMessage {
            return FfiConverterTypeParsedMessage.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_paykitmessagebuilder_parse_message(
        it, FfiConverterString.lower(`messageJson`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypePaykitMessageBuilder: FfiConverter<PaykitMessageBuilder, Pointer> {

    override fun lower(value: PaykitMessageBuilder): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): PaykitMessageBuilder {
        return PaykitMessageBuilder(value)
    }

    override fun read(buf: ByteBuffer): PaykitMessageBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PaykitMessageBuilder) = 8UL

    override fun write(value: PaykitMessageBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * In-memory receipt storage for mobile.
 *
 * Stores receipts during a session. For persistence, mobile apps should
 * save receipts to their own storage (Keychain/SharedPreferences).
 */
public interface ReceiptStoreInterface {
    
    /**
     * Clear all stored data.
     */
    fun `clear`()
    
    /**
     * Delete a receipt.
     */
    fun `deleteReceipt`(`receiptId`: kotlin.String)
    
    /**
     * Export all receipts as JSON.
     */
    fun `exportReceiptsJson`(): kotlin.String
    
    /**
     * Get a private endpoint.
     */
    fun `getPrivateEndpoint`(`peer`: kotlin.String, `methodId`: kotlin.String): PrivateEndpointOffer?
    
    /**
     * Get a receipt by ID.
     */
    fun `getReceipt`(`receiptId`: kotlin.String): ReceiptRequest?
    
    /**
     * Import receipts from JSON.
     */
    fun `importReceiptsJson`(`json`: kotlin.String): kotlin.UInt
    
    /**
     * List all private endpoints for a peer.
     */
    fun `listPrivateEndpoints`(`peer`: kotlin.String): List<PrivateEndpointOffer>
    
    /**
     * List all receipts.
     */
    fun `listReceipts`(): List<ReceiptRequest>
    
    /**
     * Save a private endpoint.
     */
    fun `savePrivateEndpoint`(`peer`: kotlin.String, `offer`: PrivateEndpointOffer)
    
    /**
     * Save a receipt.
     */
    fun `saveReceipt`(`receipt`: ReceiptRequest)
    
    companion object
}

/**
 * In-memory receipt storage for mobile.
 *
 * Stores receipts during a session. For persistence, mobile apps should
 * save receipts to their own storage (Keychain/SharedPreferences).
 */
open class ReceiptStore: Disposable, AutoCloseable, ReceiptStoreInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a new receipt store.
     */
    constructor() :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_receiptstore_new(
        _status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_receiptstore(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_receiptstore(pointer!!, status)
        }
    }

    
    /**
     * Clear all stored data.
     */
    @Throws(PaykitMobileException::class)override fun `clear`()
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_clear(
        it, _status)
}
    }
    
    

    
    /**
     * Delete a receipt.
     */
    @Throws(PaykitMobileException::class)override fun `deleteReceipt`(`receiptId`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_delete_receipt(
        it, FfiConverterString.lower(`receiptId`),_status)
}
    }
    
    

    
    /**
     * Export all receipts as JSON.
     */
    @Throws(PaykitMobileException::class)override fun `exportReceiptsJson`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_export_receipts_json(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get a private endpoint.
     */
    @Throws(PaykitMobileException::class)override fun `getPrivateEndpoint`(`peer`: kotlin.String, `methodId`: kotlin.String): PrivateEndpointOffer? {
            return FfiConverterOptionalTypePrivateEndpointOffer.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_get_private_endpoint(
        it, FfiConverterString.lower(`peer`),FfiConverterString.lower(`methodId`),_status)
}
    }
    )
    }
    

    
    /**
     * Get a receipt by ID.
     */
    @Throws(PaykitMobileException::class)override fun `getReceipt`(`receiptId`: kotlin.String): ReceiptRequest? {
            return FfiConverterOptionalTypeReceiptRequest.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_get_receipt(
        it, FfiConverterString.lower(`receiptId`),_status)
}
    }
    )
    }
    

    
    /**
     * Import receipts from JSON.
     */
    @Throws(PaykitMobileException::class)override fun `importReceiptsJson`(`json`: kotlin.String): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_import_receipts_json(
        it, FfiConverterString.lower(`json`),_status)
}
    }
    )
    }
    

    
    /**
     * List all private endpoints for a peer.
     */
    @Throws(PaykitMobileException::class)override fun `listPrivateEndpoints`(`peer`: kotlin.String): List<PrivateEndpointOffer> {
            return FfiConverterSequenceTypePrivateEndpointOffer.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_list_private_endpoints(
        it, FfiConverterString.lower(`peer`),_status)
}
    }
    )
    }
    

    
    /**
     * List all receipts.
     */
    @Throws(PaykitMobileException::class)override fun `listReceipts`(): List<ReceiptRequest> {
            return FfiConverterSequenceTypeReceiptRequest.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_list_receipts(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Save a private endpoint.
     */
    @Throws(PaykitMobileException::class)override fun `savePrivateEndpoint`(`peer`: kotlin.String, `offer`: PrivateEndpointOffer)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_save_private_endpoint(
        it, FfiConverterString.lower(`peer`),FfiConverterTypePrivateEndpointOffer.lower(`offer`),_status)
}
    }
    
    

    
    /**
     * Save a receipt.
     */
    @Throws(PaykitMobileException::class)override fun `saveReceipt`(`receipt`: ReceiptRequest)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_receiptstore_save_receipt(
        it, FfiConverterTypeReceiptRequest.lower(`receipt`),_status)
}
    }
    
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeReceiptStore: FfiConverter<ReceiptStore, Pointer> {

    override fun lower(value: ReceiptStore): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ReceiptStore {
        return ReceiptStore(value)
    }

    override fun read(buf: ByteBuffer): ReceiptStore {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ReceiptStore) = 8UL

    override fun write(value: ReceiptStore, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Manager for atomic spending limit operations.
 *
 * This manager handles the reserve-commit-rollback pattern for spending limits,
 * ensuring thread-safe atomic operations during background auto-pay.
 */
public interface SpendingManagerFfiInterface {
    
    /**
     * Get the number of active (in-flight) reservations.
     *
     * Useful for debugging and monitoring.
     */
    fun `activeReservationsCount`(): kotlin.UInt
    
    /**
     * Commit a spending reservation after successful payment.
     *
     * This finalizes the reservation - the spent amount becomes permanent.
     * This operation is idempotent.
     *
     * # Arguments
     *
     * * `reservation_id` - The reservation ID from `try_reserve_spending()`
     */
    fun `commitSpending`(`reservationId`: kotlin.String)
    
    /**
     * Get the current spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The spending limit if one exists, None otherwise.
     */
    fun `getPeerSpendingLimit`(`peerPubkey`: kotlin.String): PeerSpendingLimitFfi?
    
    /**
     * List all spending limits.
     *
     * # Returns
     *
     * List of all configured spending limits.
     */
    fun `listSpendingLimits`(): List<PeerSpendingLimitFfi>
    
    /**
     * Remove a spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     */
    fun `removePeerSpendingLimit`(`peerPubkey`: kotlin.String)
    
    /**
     * Rollback a spending reservation after failed payment.
     *
     * This releases the reserved amount back to the limit.
     * This operation is idempotent.
     *
     * # Arguments
     *
     * * `reservation_id` - The reservation ID from `try_reserve_spending()`
     */
    fun `rollbackSpending`(`reservationId`: kotlin.String)
    
    /**
     * Set a spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     * * `limit_sats` - Maximum spending limit in satoshis
     * * `period` - Reset period ("daily", "weekly", or "monthly")
     *
     * # Example
     *
     * ```ignore
     * manager.set_peer_spending_limit(
     * "8pinxxgqs41...",
     * 100000,  // 100,000 sats
     * "monthly"
     * )?;
     * ```
     */
    fun `setPeerSpendingLimit`(`peerPubkey`: kotlin.String, `limitSats`: kotlin.Long, `period`: kotlin.String): PeerSpendingLimitFfi
    
    /**
     * Try to reserve spending amount atomically.
     *
     * This method performs an atomic check-and-reserve operation:
     * 1. Acquires exclusive file lock
     * 2. Checks if amount would exceed limit
     * 3. If within limit, reserves the amount
     * 4. Returns a reservation token
     *
     * The reservation MUST be either committed or rolled back after payment.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key
     * * `amount_sats` - Amount to reserve in satoshis
     *
     * # Errors
     *
     * - `NotFound` if no spending limit is set for this peer
     * - `Validation` with "Limit exceeded" if amount would exceed limit
     *
     * # Example
     *
     * ```ignore
     * let reservation = manager.try_reserve_spending("8pinxxgqs41...", 10000)?;
     * // Execute payment...
     * manager.commit_spending(reservation.reservation_id)?;
     * ```
     */
    fun `tryReserveSpending`(`peerPubkey`: kotlin.String, `amountSats`: kotlin.Long): SpendingReservationFfi
    
    /**
     * Check if an amount would exceed the spending limit (non-blocking check).
     *
     * This is a read-only check that does not modify the spending limit.
     * For actual payment execution, use `try_reserve_spending()` instead.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key
     * * `amount_sats` - Amount to check in satoshis
     *
     * # Returns
     *
     * A result containing whether the amount would exceed the limit.
     */
    fun `wouldExceedSpendingLimit`(`peerPubkey`: kotlin.String, `amountSats`: kotlin.Long): SpendingCheckResultFfi
    
    companion object
}

/**
 * Manager for atomic spending limit operations.
 *
 * This manager handles the reserve-commit-rollback pattern for spending limits,
 * ensuring thread-safe atomic operations during background auto-pay.
 */
open class SpendingManagerFfi: Disposable, AutoCloseable, SpendingManagerFfiInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a new spending manager with the given storage path.
     *
     * # Arguments
     *
     * * `storage_path` - Path to the storage directory for spending limits
     */
    constructor(`storagePath`: kotlin.String) :
        this(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_spendingmanagerffi_new(
        FfiConverterString.lower(`storagePath`),_status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_spendingmanagerffi(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_spendingmanagerffi(pointer!!, status)
        }
    }

    
    /**
     * Get the number of active (in-flight) reservations.
     *
     * Useful for debugging and monitoring.
     */override fun `activeReservationsCount`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_active_reservations_count(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Commit a spending reservation after successful payment.
     *
     * This finalizes the reservation - the spent amount becomes permanent.
     * This operation is idempotent.
     *
     * # Arguments
     *
     * * `reservation_id` - The reservation ID from `try_reserve_spending()`
     */
    @Throws(PaykitMobileException::class)override fun `commitSpending`(`reservationId`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_commit_spending(
        it, FfiConverterString.lower(`reservationId`),_status)
}
    }
    
    

    
    /**
     * Get the current spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The spending limit if one exists, None otherwise.
     */
    @Throws(PaykitMobileException::class)override fun `getPeerSpendingLimit`(`peerPubkey`: kotlin.String): PeerSpendingLimitFfi? {
            return FfiConverterOptionalTypePeerSpendingLimitFFI.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_get_peer_spending_limit(
        it, FfiConverterString.lower(`peerPubkey`),_status)
}
    }
    )
    }
    

    
    /**
     * List all spending limits.
     *
     * # Returns
     *
     * List of all configured spending limits.
     */
    @Throws(PaykitMobileException::class)override fun `listSpendingLimits`(): List<PeerSpendingLimitFfi> {
            return FfiConverterSequenceTypePeerSpendingLimitFFI.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_list_spending_limits(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Remove a spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     */
    @Throws(PaykitMobileException::class)override fun `removePeerSpendingLimit`(`peerPubkey`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_remove_peer_spending_limit(
        it, FfiConverterString.lower(`peerPubkey`),_status)
}
    }
    
    

    
    /**
     * Rollback a spending reservation after failed payment.
     *
     * This releases the reserved amount back to the limit.
     * This operation is idempotent.
     *
     * # Arguments
     *
     * * `reservation_id` - The reservation ID from `try_reserve_spending()`
     */
    @Throws(PaykitMobileException::class)override fun `rollbackSpending`(`reservationId`: kotlin.String)
        = 
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_rollback_spending(
        it, FfiConverterString.lower(`reservationId`),_status)
}
    }
    
    

    
    /**
     * Set a spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     * * `limit_sats` - Maximum spending limit in satoshis
     * * `period` - Reset period ("daily", "weekly", or "monthly")
     *
     * # Example
     *
     * ```ignore
     * manager.set_peer_spending_limit(
     * "8pinxxgqs41...",
     * 100000,  // 100,000 sats
     * "monthly"
     * )?;
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `setPeerSpendingLimit`(`peerPubkey`: kotlin.String, `limitSats`: kotlin.Long, `period`: kotlin.String): PeerSpendingLimitFfi {
            return FfiConverterTypePeerSpendingLimitFFI.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_set_peer_spending_limit(
        it, FfiConverterString.lower(`peerPubkey`),FfiConverterLong.lower(`limitSats`),FfiConverterString.lower(`period`),_status)
}
    }
    )
    }
    

    
    /**
     * Try to reserve spending amount atomically.
     *
     * This method performs an atomic check-and-reserve operation:
     * 1. Acquires exclusive file lock
     * 2. Checks if amount would exceed limit
     * 3. If within limit, reserves the amount
     * 4. Returns a reservation token
     *
     * The reservation MUST be either committed or rolled back after payment.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key
     * * `amount_sats` - Amount to reserve in satoshis
     *
     * # Errors
     *
     * - `NotFound` if no spending limit is set for this peer
     * - `Validation` with "Limit exceeded" if amount would exceed limit
     *
     * # Example
     *
     * ```ignore
     * let reservation = manager.try_reserve_spending("8pinxxgqs41...", 10000)?;
     * // Execute payment...
     * manager.commit_spending(reservation.reservation_id)?;
     * ```
     */
    @Throws(PaykitMobileException::class)override fun `tryReserveSpending`(`peerPubkey`: kotlin.String, `amountSats`: kotlin.Long): SpendingReservationFfi {
            return FfiConverterTypeSpendingReservationFFI.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_try_reserve_spending(
        it, FfiConverterString.lower(`peerPubkey`),FfiConverterLong.lower(`amountSats`),_status)
}
    }
    )
    }
    

    
    /**
     * Check if an amount would exceed the spending limit (non-blocking check).
     *
     * This is a read-only check that does not modify the spending limit.
     * For actual payment execution, use `try_reserve_spending()` instead.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key
     * * `amount_sats` - Amount to check in satoshis
     *
     * # Returns
     *
     * A result containing whether the amount would exceed the limit.
     */
    @Throws(PaykitMobileException::class)override fun `wouldExceedSpendingLimit`(`peerPubkey`: kotlin.String, `amountSats`: kotlin.Long): SpendingCheckResultFfi {
            return FfiConverterTypeSpendingCheckResultFFI.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_spendingmanagerffi_would_exceed_spending_limit(
        it, FfiConverterString.lower(`peerPubkey`),FfiConverterLong.lower(`amountSats`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

/**
 * @suppress
 */
public object FfiConverterTypeSpendingManagerFFI: FfiConverter<SpendingManagerFfi, Pointer> {

    override fun lower(value: SpendingManagerFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SpendingManagerFfi {
        return SpendingManagerFfi(value)
    }

    override fun read(buf: ByteBuffer): SpendingManagerFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SpendingManagerFfi) = 8UL

    override fun write(value: SpendingManagerFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * FFI wrapper for unauthenticated (read-only) transport operations.
 *
 * This wraps read-only access to public Pubky storage.
 * Mobile apps can use this to discover payment methods for other users.
 *
 * # Creating in Production
 *
 * Implement `PubkyUnauthenticatedStorageCallback` in Swift/Kotlin:
 *
 * ```swift
 * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
 * func get(ownerPubkey: String, path: String) -> StorageGetResult {
 * // Use Pubky SDK to read from public storage
 * let url = "pubky://\(ownerPubkey)\(path)"
 * if let content = try? pubkyClient.get(url) {
 * return StorageGetResult.ok(content: content)
 * }
 * return StorageGetResult.ok(content: nil) // Not found
 * }
 *
 * func list(ownerPubkey: String, prefix: String) -> StorageListResult {
 * // ... implement using Pubky SDK
 * }
 * }
 *
 * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
 * ```
 */
public interface UnauthenticatedTransportFfiInterface {
    
    /**
     * Get a file at the given path from a public key's storage.
     */
    fun `get`(`ownerPubkey`: kotlin.String, `path`: kotlin.String): kotlin.String?
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    fun `isMock`(): kotlin.Boolean
    
    /**
     * List files with a given prefix from a public key's storage.
     */
    fun `list`(`ownerPubkey`: kotlin.String, `prefix`: kotlin.String): List<kotlin.String>
    
    companion object
}

/**
 * FFI wrapper for unauthenticated (read-only) transport operations.
 *
 * This wraps read-only access to public Pubky storage.
 * Mobile apps can use this to discover payment methods for other users.
 *
 * # Creating in Production
 *
 * Implement `PubkyUnauthenticatedStorageCallback` in Swift/Kotlin:
 *
 * ```swift
 * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
 * func get(ownerPubkey: String, path: String) -> StorageGetResult {
 * // Use Pubky SDK to read from public storage
 * let url = "pubky://\(ownerPubkey)\(path)"
 * if let content = try? pubkyClient.get(url) {
 * return StorageGetResult.ok(content: content)
 * }
 * return StorageGetResult.ok(content: nil) // Not found
 * }
 *
 * func list(ownerPubkey: String, prefix: String) -> StorageListResult {
 * // ... implement using Pubky SDK
 * }
 * }
 *
 * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
 * ```
 */
open class UnauthenticatedTransportFfi: Disposable, AutoCloseable, UnauthenticatedTransportFfiInterface
{

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_free_unauthenticatedtransportffi(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_clone_unauthenticatedtransportffi(pointer!!, status)
        }
    }

    
    /**
     * Get a file at the given path from a public key's storage.
     */
    @Throws(PaykitMobileException::class)override fun `get`(`ownerPubkey`: kotlin.String, `path`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_get(
        it, FfiConverterString.lower(`ownerPubkey`),FfiConverterString.lower(`path`),_status)
}
    }
    )
    }
    

    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    @Throws(PaykitMobileException::class)override fun `isMock`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_is_mock(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * List files with a given prefix from a public key's storage.
     */
    @Throws(PaykitMobileException::class)override fun `list`(`ownerPubkey`: kotlin.String, `prefix`: kotlin.String): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_list(
        it, FfiConverterString.lower(`ownerPubkey`),FfiConverterString.lower(`prefix`),_status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create unauthenticated transport that shares mock storage with an authenticated transport.
     *
     * Useful for testing when you want reads to see writes from the same session.
     *
     * # Note
     *
     * This only works with mock transports. For callback-based transports,
     * create a new `UnauthenticatedTransportFFI::from_callback()` that shares
     * the underlying Pubky client.
     */
    @Throws(PaykitMobileException::class) fun `fromAuthenticated`(`auth`: AuthenticatedTransportFfi): UnauthenticatedTransportFfi {
            return FfiConverterTypeUnauthenticatedTransportFFI.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_authenticated(
        FfiConverterTypeAuthenticatedTransportFFI.lower(`auth`),_status)
}
    )
    }
    

        
    /**
     * Create unauthenticated transport from a storage callback.
     *
     * # Arguments
     *
     * * `callback` - Storage callback implementing PubkyUnauthenticatedStorageCallback
     *
     * # Example (Swift)
     *
     * ```swift
     * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
     * func get(ownerPubkey: String, path: String) -> StorageGetResult {
     * // Use Pubky SDK to read from public storage
     * // ...
     * }
     * }
     *
     * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
     * ```
     */ fun `fromCallback`(`callback`: PubkyUnauthenticatedStorageCallback): UnauthenticatedTransportFfi {
            return FfiConverterTypeUnauthenticatedTransportFFI.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_callback(
        FfiConverterTypePubkyUnauthenticatedStorageCallback.lower(`callback`),_status)
}
    )
    }
    

        
    /**
     * Create unauthenticated transport from Pubky SDK configuration.
     *
     * # Deprecated
     *
     * This method creates a mock transport. Use `from_callback()` for production.
     *
     * # Arguments
     *
     * * `config_json` - JSON configuration (validated but not used)
     */
    @Throws(PaykitMobileException::class) fun `fromConfigJson`(`configJson`: kotlin.String): UnauthenticatedTransportFfi {
            return FfiConverterTypeUnauthenticatedTransportFFI.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_config_json(
        FfiConverterString.lower(`configJson`),_status)
}
    )
    }
    

        
    /**
     * Create a new unauthenticated transport for testing/development.
     *
     * Uses in-memory storage - no network calls are made.
     */ fun `newMock`(): UnauthenticatedTransportFfi {
            return FfiConverterTypeUnauthenticatedTransportFFI.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_new_mock(
        _status)
}
    )
    }
    

        
    }
    
}

/**
 * @suppress
 */
public object FfiConverterTypeUnauthenticatedTransportFFI: FfiConverter<UnauthenticatedTransportFfi, Pointer> {

    override fun lower(value: UnauthenticatedTransportFfi): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): UnauthenticatedTransportFfi {
        return UnauthenticatedTransportFfi(value)
    }

    override fun read(buf: ByteBuffer): UnauthenticatedTransportFfi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: UnauthenticatedTransportFfi) = 8UL

    override fun write(value: UnauthenticatedTransportFfi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}



/**
 * Payment amount.
 */
data class Amount (
    var `value`: kotlin.String, 
    var `currency`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAmount: FfiConverterRustBuffer<Amount> {
    override fun read(buf: ByteBuffer): Amount {
        return Amount(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Amount) = (
            FfiConverterString.allocationSize(value.`value`) +
            FfiConverterString.allocationSize(value.`currency`)
    )

    override fun write(value: Amount, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
            FfiConverterString.write(value.`currency`, buf)
    }
}



/**
 * Result of a Bitcoin on-chain transaction (FFI-compatible).
 *
 * This type is returned by `BitcoinExecutorFFI::sendToAddress()` after
 * successfully broadcasting a transaction.
 */
data class BitcoinTxResultFfi (
    /**
     * The transaction ID (hex-encoded, 64 characters).
     */
    var `txid`: kotlin.String, 
    /**
     * The raw transaction hex (optional, for debugging/verification).
     */
    var `rawTx`: kotlin.String?, 
    /**
     * The output index used for payment.
     */
    var `vout`: kotlin.UInt, 
    /**
     * The fee paid in satoshis.
     */
    var `feeSats`: kotlin.ULong, 
    /**
     * The fee rate in sat/vB.
     */
    var `feeRate`: kotlin.Double, 
    /**
     * Block height if confirmed (None if unconfirmed).
     */
    var `blockHeight`: kotlin.ULong?, 
    /**
     * Number of confirmations.
     */
    var `confirmations`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBitcoinTxResultFFI: FfiConverterRustBuffer<BitcoinTxResultFfi> {
    override fun read(buf: ByteBuffer): BitcoinTxResultFfi {
        return BitcoinTxResultFfi(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterDouble.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: BitcoinTxResultFfi) = (
            FfiConverterString.allocationSize(value.`txid`) +
            FfiConverterOptionalString.allocationSize(value.`rawTx`) +
            FfiConverterUInt.allocationSize(value.`vout`) +
            FfiConverterULong.allocationSize(value.`feeSats`) +
            FfiConverterDouble.allocationSize(value.`feeRate`) +
            FfiConverterOptionalULong.allocationSize(value.`blockHeight`) +
            FfiConverterULong.allocationSize(value.`confirmations`)
    )

    override fun write(value: BitcoinTxResultFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`txid`, buf)
            FfiConverterOptionalString.write(value.`rawTx`, buf)
            FfiConverterUInt.write(value.`vout`, buf)
            FfiConverterULong.write(value.`feeSats`, buf)
            FfiConverterDouble.write(value.`feeRate`, buf)
            FfiConverterOptionalULong.write(value.`blockHeight`, buf)
            FfiConverterULong.write(value.`confirmations`, buf)
    }
}



/**
 * FFI-safe cached contact.
 */
data class CachedContactFfi (
    var `pubkey`: kotlin.String, 
    var `name`: kotlin.String?, 
    var `addedAt`: kotlin.Long, 
    var `lastSyncedAt`: kotlin.Long?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCachedContactFFI: FfiConverterRustBuffer<CachedContactFfi> {
    override fun read(buf: ByteBuffer): CachedContactFfi {
        return CachedContactFfi(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalLong.read(buf),
        )
    }

    override fun allocationSize(value: CachedContactFfi) = (
            FfiConverterString.allocationSize(value.`pubkey`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterLong.allocationSize(value.`addedAt`) +
            FfiConverterOptionalLong.allocationSize(value.`lastSyncedAt`)
    )

    override fun write(value: CachedContactFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`pubkey`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterLong.write(value.`addedAt`, buf)
            FfiConverterOptionalLong.write(value.`lastSyncedAt`, buf)
    }
}



/**
 * Decoded BOLT11 invoice details (FFI-compatible).
 *
 * This type is returned by `LightningExecutorFFI::decodeInvoice()`.
 */
data class DecodedInvoiceFfi (
    /**
     * The payment hash (hex-encoded).
     */
    var `paymentHash`: kotlin.String, 
    /**
     * Amount in millisatoshis (None for zero-amount invoices).
     */
    var `amountMsat`: kotlin.ULong?, 
    /**
     * Invoice description.
     */
    var `description`: kotlin.String?, 
    /**
     * Description hash (for invoices with hashed descriptions).
     */
    var `descriptionHash`: kotlin.String?, 
    /**
     * Payee public key (hex-encoded).
     */
    var `payee`: kotlin.String, 
    /**
     * Expiry time in seconds.
     */
    var `expiry`: kotlin.ULong, 
    /**
     * Creation timestamp (Unix epoch seconds).
     */
    var `timestamp`: kotlin.ULong, 
    /**
     * Whether the invoice has expired.
     */
    var `expired`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDecodedInvoiceFFI: FfiConverterRustBuffer<DecodedInvoiceFfi> {
    override fun read(buf: ByteBuffer): DecodedInvoiceFfi {
        return DecodedInvoiceFfi(
            FfiConverterString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: DecodedInvoiceFfi) = (
            FfiConverterString.allocationSize(value.`paymentHash`) +
            FfiConverterOptionalULong.allocationSize(value.`amountMsat`) +
            FfiConverterOptionalString.allocationSize(value.`description`) +
            FfiConverterOptionalString.allocationSize(value.`descriptionHash`) +
            FfiConverterString.allocationSize(value.`payee`) +
            FfiConverterULong.allocationSize(value.`expiry`) +
            FfiConverterULong.allocationSize(value.`timestamp`) +
            FfiConverterBoolean.allocationSize(value.`expired`)
    )

    override fun write(value: DecodedInvoiceFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`paymentHash`, buf)
            FfiConverterOptionalULong.write(value.`amountMsat`, buf)
            FfiConverterOptionalString.write(value.`description`, buf)
            FfiConverterOptionalString.write(value.`descriptionHash`, buf)
            FfiConverterString.write(value.`payee`, buf)
            FfiConverterULong.write(value.`expiry`, buf)
            FfiConverterULong.write(value.`timestamp`, buf)
            FfiConverterBoolean.write(value.`expired`, buf)
    }
}



/**
 * Generated Ed25519 keypair for identity.
 */
data class Ed25519Keypair (
    /**
     * Secret key (seed) - 32 bytes, hex encoded.
     * SENSITIVE: Store securely, this is the root identity secret.
     */
    var `secretKeyHex`: kotlin.String, 
    /**
     * Public key - 32 bytes, hex encoded.
     */
    var `publicKeyHex`: kotlin.String, 
    /**
     * Public key in z-base32 format (pkarr format).
     */
    var `publicKeyZ32`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEd25519Keypair: FfiConverterRustBuffer<Ed25519Keypair> {
    override fun read(buf: ByteBuffer): Ed25519Keypair {
        return Ed25519Keypair(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Ed25519Keypair) = (
            FfiConverterString.allocationSize(value.`secretKeyHex`) +
            FfiConverterString.allocationSize(value.`publicKeyHex`) +
            FfiConverterString.allocationSize(value.`publicKeyZ32`)
    )

    override fun write(value: Ed25519Keypair, buf: ByteBuffer) {
            FfiConverterString.write(value.`secretKeyHex`, buf)
            FfiConverterString.write(value.`publicKeyHex`, buf)
            FfiConverterString.write(value.`publicKeyZ32`, buf)
    }
}



/**
 * Endpoint data for a payment method.
 */
data class EndpointData (
    var `value`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEndpointData: FfiConverterRustBuffer<EndpointData> {
    override fun read(buf: ByteBuffer): EndpointData {
        return EndpointData(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: EndpointData) = (
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: EndpointData, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
    }
}



/**
 * FFI-safe error message.
 */
data class ErrorMessage (
    var `code`: kotlin.String, 
    var `message`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeErrorMessage: FfiConverterRustBuffer<ErrorMessage> {
    override fun read(buf: ByteBuffer): ErrorMessage {
        return ErrorMessage(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ErrorMessage) = (
            FfiConverterString.allocationSize(value.`code`) +
            FfiConverterString.allocationSize(value.`message`)
    )

    override fun write(value: ErrorMessage, buf: ByteBuffer) {
            FfiConverterString.write(value.`code`, buf)
            FfiConverterString.write(value.`message`, buf)
    }
}



/**
 * Result of executing payment with fallbacks.
 *
 * Contains the successful result if any method worked,
 * or a complete list of all attempts if all failed.
 */
data class FallbackExecutionResult (
    /**
     * Whether any payment method succeeded.
     */
    var `success`: kotlin.Boolean, 
    /**
     * The successful execution result, if any.
     */
    var `successfulExecution`: PaymentExecutionResult?, 
    /**
     * All attempts made, in order.
     */
    var `attempts`: List<PaymentAttempt>, 
    /**
     * Summary message describing the outcome.
     */
    var `summary`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFallbackExecutionResult: FfiConverterRustBuffer<FallbackExecutionResult> {
    override fun read(buf: ByteBuffer): FallbackExecutionResult {
        return FallbackExecutionResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypePaymentExecutionResult.read(buf),
            FfiConverterSequenceTypePaymentAttempt.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: FallbackExecutionResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalTypePaymentExecutionResult.allocationSize(value.`successfulExecution`) +
            FfiConverterSequenceTypePaymentAttempt.allocationSize(value.`attempts`) +
            FfiConverterString.allocationSize(value.`summary`)
    )

    override fun write(value: FallbackExecutionResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalTypePaymentExecutionResult.write(value.`successfulExecution`, buf)
            FfiConverterSequenceTypePaymentAttempt.write(value.`attempts`, buf)
            FfiConverterString.write(value.`summary`, buf)
    }
}



/**
 * Health check result.
 */
data class HealthCheckResult (
    var `methodId`: kotlin.String, 
    var `status`: HealthStatus, 
    var `checkedAt`: kotlin.Long, 
    var `latencyMs`: kotlin.ULong?, 
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeHealthCheckResult: FfiConverterRustBuffer<HealthCheckResult> {
    override fun read(buf: ByteBuffer): HealthCheckResult {
        return HealthCheckResult(
            FfiConverterString.read(buf),
            FfiConverterTypeHealthStatus.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: HealthCheckResult) = (
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterTypeHealthStatus.allocationSize(value.`status`) +
            FfiConverterLong.allocationSize(value.`checkedAt`) +
            FfiConverterOptionalULong.allocationSize(value.`latencyMs`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: HealthCheckResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterTypeHealthStatus.write(value.`status`, buf)
            FfiConverterLong.write(value.`checkedAt`, buf)
            FfiConverterOptionalULong.write(value.`latencyMs`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Encrypted key backup for export/import.
 */
data class KeyBackup (
    /**
     * Version of the backup format.
     */
    var `version`: kotlin.UInt, 
    /**
     * Encrypted secret key (AES-GCM).
     */
    var `encryptedDataHex`: kotlin.String, 
    /**
     * Salt for key derivation from password.
     */
    var `saltHex`: kotlin.String, 
    /**
     * Nonce for AES-GCM.
     */
    var `nonceHex`: kotlin.String, 
    /**
     * Public key (not encrypted, for identification).
     */
    var `publicKeyZ32`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeKeyBackup: FfiConverterRustBuffer<KeyBackup> {
    override fun read(buf: ByteBuffer): KeyBackup {
        return KeyBackup(
            FfiConverterUInt.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: KeyBackup) = (
            FfiConverterUInt.allocationSize(value.`version`) +
            FfiConverterString.allocationSize(value.`encryptedDataHex`) +
            FfiConverterString.allocationSize(value.`saltHex`) +
            FfiConverterString.allocationSize(value.`nonceHex`) +
            FfiConverterString.allocationSize(value.`publicKeyZ32`)
    )

    override fun write(value: KeyBackup, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`version`, buf)
            FfiConverterString.write(value.`encryptedDataHex`, buf)
            FfiConverterString.write(value.`saltHex`, buf)
            FfiConverterString.write(value.`nonceHex`, buf)
            FfiConverterString.write(value.`publicKeyZ32`, buf)
    }
}



/**
 * Result of a Lightning payment (FFI-compatible).
 *
 * This type is returned by `LightningExecutorFFI::payInvoice()` after
 * a successful Lightning payment.
 */
data class LightningPaymentResultFfi (
    /**
     * The payment preimage (hex-encoded, 64 characters).
     * This is the cryptographic proof of payment.
     */
    var `preimage`: kotlin.String, 
    /**
     * The payment hash (hex-encoded, 64 characters).
     */
    var `paymentHash`: kotlin.String, 
    /**
     * The amount paid in millisatoshis.
     */
    var `amountMsat`: kotlin.ULong, 
    /**
     * The fee paid in millisatoshis.
     */
    var `feeMsat`: kotlin.ULong, 
    /**
     * Number of hops in the payment route.
     */
    var `hops`: kotlin.UInt, 
    /**
     * Payment status.
     */
    var `status`: LightningPaymentStatusFfi
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeLightningPaymentResultFFI: FfiConverterRustBuffer<LightningPaymentResultFfi> {
    override fun read(buf: ByteBuffer): LightningPaymentResultFfi {
        return LightningPaymentResultFfi(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterTypeLightningPaymentStatusFFI.read(buf),
        )
    }

    override fun allocationSize(value: LightningPaymentResultFfi) = (
            FfiConverterString.allocationSize(value.`preimage`) +
            FfiConverterString.allocationSize(value.`paymentHash`) +
            FfiConverterULong.allocationSize(value.`amountMsat`) +
            FfiConverterULong.allocationSize(value.`feeMsat`) +
            FfiConverterUInt.allocationSize(value.`hops`) +
            FfiConverterTypeLightningPaymentStatusFFI.allocationSize(value.`status`)
    )

    override fun write(value: LightningPaymentResultFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`preimage`, buf)
            FfiConverterString.write(value.`paymentHash`, buf)
            FfiConverterULong.write(value.`amountMsat`, buf)
            FfiConverterULong.write(value.`feeMsat`, buf)
            FfiConverterUInt.write(value.`hops`, buf)
            FfiConverterTypeLightningPaymentStatusFFI.write(value.`status`, buf)
    }
}



/**
 * A payment method identifier.
 */
data class MethodId (
    var `value`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMethodId: FfiConverterRustBuffer<MethodId> {
    override fun read(buf: ByteBuffer): MethodId {
        return MethodId(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: MethodId) = (
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: MethodId, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
    }
}



/**
 * Information about a Noise protocol endpoint for receiving payments.
 *
 * This is discovered from a recipient's public directory and contains
 * the connection information needed to establish a Noise session.
 */
data class NoiseEndpointInfo (
    /**
     * The recipient's public key (z-base32 encoded).
     */
    var `recipientPubkey`: kotlin.String, 
    /**
     * Host address of the Noise server (IP or hostname).
     */
    var `host`: kotlin.String, 
    /**
     * Port number of the Noise server.
     */
    var `port`: kotlin.UShort, 
    /**
     * The server's Noise public key (X25519, hex encoded).
     * This is needed to verify the server during handshake.
     */
    var `serverNoisePubkey`: kotlin.String, 
    /**
     * Optional metadata about the endpoint.
     */
    var `metadata`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNoiseEndpointInfo: FfiConverterRustBuffer<NoiseEndpointInfo> {
    override fun read(buf: ByteBuffer): NoiseEndpointInfo {
        return NoiseEndpointInfo(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUShort.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: NoiseEndpointInfo) = (
            FfiConverterString.allocationSize(value.`recipientPubkey`) +
            FfiConverterString.allocationSize(value.`host`) +
            FfiConverterUShort.allocationSize(value.`port`) +
            FfiConverterString.allocationSize(value.`serverNoisePubkey`) +
            FfiConverterOptionalString.allocationSize(value.`metadata`)
    )

    override fun write(value: NoiseEndpointInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`recipientPubkey`, buf)
            FfiConverterString.write(value.`host`, buf)
            FfiConverterUShort.write(value.`port`, buf)
            FfiConverterString.write(value.`serverNoisePubkey`, buf)
            FfiConverterOptionalString.write(value.`metadata`, buf)
    }
}



/**
 * Result of a Noise handshake operation.
 */
data class NoiseHandshakeResult (
    /**
     * Whether the handshake succeeded.
     */
    var `success`: kotlin.Boolean, 
    /**
     * Session ID for this connection (if successful).
     */
    var `sessionId`: kotlin.String?, 
    /**
     * Remote peer's public key (z-base32 encoded, if successful).
     */
    var `remotePubkey`: kotlin.String?, 
    /**
     * Error message (if failed).
     */
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNoiseHandshakeResult: FfiConverterRustBuffer<NoiseHandshakeResult> {
    override fun read(buf: ByteBuffer): NoiseHandshakeResult {
        return NoiseHandshakeResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: NoiseHandshakeResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalString.allocationSize(value.`sessionId`) +
            FfiConverterOptionalString.allocationSize(value.`remotePubkey`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: NoiseHandshakeResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalString.write(value.`sessionId`, buf)
            FfiConverterOptionalString.write(value.`remotePubkey`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * A payment message to send over Noise channel.
 */
data class NoisePaymentMessage (
    /**
     * Type of the message.
     */
    var `messageType`: NoisePaymentMessageType, 
    /**
     * JSON payload of the message.
     */
    var `payloadJson`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNoisePaymentMessage: FfiConverterRustBuffer<NoisePaymentMessage> {
    override fun read(buf: ByteBuffer): NoisePaymentMessage {
        return NoisePaymentMessage(
            FfiConverterTypeNoisePaymentMessageType.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: NoisePaymentMessage) = (
            FfiConverterTypeNoisePaymentMessageType.allocationSize(value.`messageType`) +
            FfiConverterString.allocationSize(value.`payloadJson`)
    )

    override fun write(value: NoisePaymentMessage, buf: ByteBuffer) {
            FfiConverterTypeNoisePaymentMessageType.write(value.`messageType`, buf)
            FfiConverterString.write(value.`payloadJson`, buf)
    }
}



/**
 * Configuration for a Noise server (receiving payments).
 */
data class NoiseServerConfig (
    /**
     * The port to listen on (0 for auto-assign).
     */
    var `port`: kotlin.UShort, 
    /**
     * Maximum number of concurrent connections.
     */
    var `maxConnections`: kotlin.UInt, 
    /**
     * Connection timeout in seconds.
     */
    var `connectionTimeoutSecs`: kotlin.UInt, 
    /**
     * Whether to automatically publish endpoint to directory.
     */
    var `autoPublish`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNoiseServerConfig: FfiConverterRustBuffer<NoiseServerConfig> {
    override fun read(buf: ByteBuffer): NoiseServerConfig {
        return NoiseServerConfig(
            FfiConverterUShort.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: NoiseServerConfig) = (
            FfiConverterUShort.allocationSize(value.`port`) +
            FfiConverterUInt.allocationSize(value.`maxConnections`) +
            FfiConverterUInt.allocationSize(value.`connectionTimeoutSecs`) +
            FfiConverterBoolean.allocationSize(value.`autoPublish`)
    )

    override fun write(value: NoiseServerConfig, buf: ByteBuffer) {
            FfiConverterUShort.write(value.`port`, buf)
            FfiConverterUInt.write(value.`maxConnections`, buf)
            FfiConverterUInt.write(value.`connectionTimeoutSecs`, buf)
            FfiConverterBoolean.write(value.`autoPublish`, buf)
    }
}



/**
 * Status of the Noise server.
 */
data class NoiseServerStatus (
    /**
     * Whether the server is currently running.
     */
    var `isRunning`: kotlin.Boolean, 
    /**
     * The port the server is listening on (if running).
     */
    var `port`: kotlin.UShort?, 
    /**
     * The server's Noise public key (X25519, hex encoded).
     */
    var `noisePubkey`: kotlin.String, 
    /**
     * Number of active sessions.
     */
    var `activeSessions`: kotlin.UInt, 
    /**
     * Total connections handled since start.
     */
    var `totalConnections`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNoiseServerStatus: FfiConverterRustBuffer<NoiseServerStatus> {
    override fun read(buf: ByteBuffer): NoiseServerStatus {
        return NoiseServerStatus(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalUShort.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: NoiseServerStatus) = (
            FfiConverterBoolean.allocationSize(value.`isRunning`) +
            FfiConverterOptionalUShort.allocationSize(value.`port`) +
            FfiConverterString.allocationSize(value.`noisePubkey`) +
            FfiConverterUInt.allocationSize(value.`activeSessions`) +
            FfiConverterULong.allocationSize(value.`totalConnections`)
    )

    override fun write(value: NoiseServerStatus, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`isRunning`, buf)
            FfiConverterOptionalUShort.write(value.`port`, buf)
            FfiConverterString.write(value.`noisePubkey`, buf)
            FfiConverterUInt.write(value.`activeSessions`, buf)
            FfiConverterULong.write(value.`totalConnections`, buf)
    }
}



/**
 * Information about an active Noise session.
 */
data class NoiseSessionInfo (
    /**
     * Unique session identifier.
     */
    var `sessionId`: kotlin.String, 
    /**
     * Remote peer's public key (z-base32 encoded).
     */
    var `remotePubkey`: kotlin.String, 
    /**
     * When the session was established (unix timestamp).
     */
    var `establishedAt`: kotlin.Long, 
    /**
     * Whether this is an incoming (server) or outgoing (client) session.
     */
    var `isIncoming`: kotlin.Boolean, 
    /**
     * Number of messages sent in this session.
     */
    var `messagesSent`: kotlin.ULong, 
    /**
     * Number of messages received in this session.
     */
    var `messagesReceived`: kotlin.ULong
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNoiseSessionInfo: FfiConverterRustBuffer<NoiseSessionInfo> {
    override fun read(buf: ByteBuffer): NoiseSessionInfo {
        return NoiseSessionInfo(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: NoiseSessionInfo) = (
            FfiConverterString.allocationSize(value.`sessionId`) +
            FfiConverterString.allocationSize(value.`remotePubkey`) +
            FfiConverterLong.allocationSize(value.`establishedAt`) +
            FfiConverterBoolean.allocationSize(value.`isIncoming`) +
            FfiConverterULong.allocationSize(value.`messagesSent`) +
            FfiConverterULong.allocationSize(value.`messagesReceived`)
    )

    override fun write(value: NoiseSessionInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`sessionId`, buf)
            FfiConverterString.write(value.`remotePubkey`, buf)
            FfiConverterLong.write(value.`establishedAt`, buf)
            FfiConverterBoolean.write(value.`isIncoming`, buf)
            FfiConverterULong.write(value.`messagesSent`, buf)
            FfiConverterULong.write(value.`messagesReceived`, buf)
    }
}



/**
 * Record of a single attempt within a fallback execution.
 */
data class PaymentAttempt (
    /**
     * Payment method attempted.
     */
    var `methodId`: kotlin.String, 
    /**
     * Endpoint attempted.
     */
    var `endpoint`: kotlin.String, 
    /**
     * Whether this attempt succeeded.
     */
    var `success`: kotlin.Boolean, 
    /**
     * Error message if failed.
     */
    var `error`: kotlin.String?, 
    /**
     * Whether this failure is retryable (e.g., network timeout).
     * Non-retryable failures (e.g., invoice already paid) stop the loop.
     */
    var `retryable`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentAttempt: FfiConverterRustBuffer<PaymentAttempt> {
    override fun read(buf: ByteBuffer): PaymentAttempt {
        return PaymentAttempt(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: PaymentAttempt) = (
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`) +
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalString.allocationSize(value.`error`) +
            FfiConverterBoolean.allocationSize(value.`retryable`)
    )

    override fun write(value: PaymentAttempt, buf: ByteBuffer) {
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
            FfiConverterBoolean.write(value.`retryable`, buf)
    }
}



/**
 * A payment method candidate for fallback execution.
 */
data class PaymentCandidate (
    /**
     * Payment method identifier.
     */
    var `methodId`: kotlin.String, 
    /**
     * Payment endpoint (address, invoice, etc.).
     */
    var `endpoint`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentCandidate: FfiConverterRustBuffer<PaymentCandidate> {
    override fun read(buf: ByteBuffer): PaymentCandidate {
        return PaymentCandidate(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentCandidate) = (
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`)
    )

    override fun write(value: PaymentCandidate, buf: ByteBuffer) {
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
    }
}



/**
 * Result of a payment execution.
 *
 * Returned by `PaykitClient::execute_payment()` after attempting to
 * send a payment via the registered wallet executor.
 */
data class PaymentExecutionResult (
    /**
     * Unique execution ID.
     */
    var `executionId`: kotlin.String, 
    /**
     * Payment method used.
     */
    var `methodId`: kotlin.String, 
    /**
     * Payment destination.
     */
    var `endpoint`: kotlin.String, 
    /**
     * Amount sent in satoshis.
     */
    var `amountSats`: kotlin.ULong, 
    /**
     * Whether the payment succeeded.
     */
    var `success`: kotlin.Boolean, 
    /**
     * Unix timestamp of execution.
     */
    var `executedAt`: kotlin.Long, 
    /**
     * Execution details as JSON (contains txid, preimage, fees, etc.).
     */
    var `executionDataJson`: kotlin.String, 
    /**
     * Error message if failed.
     */
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentExecutionResult: FfiConverterRustBuffer<PaymentExecutionResult> {
    override fun read(buf: ByteBuffer): PaymentExecutionResult {
        return PaymentExecutionResult(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentExecutionResult) = (
            FfiConverterString.allocationSize(value.`executionId`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`) +
            FfiConverterULong.allocationSize(value.`amountSats`) +
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterLong.allocationSize(value.`executedAt`) +
            FfiConverterString.allocationSize(value.`executionDataJson`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: PaymentExecutionResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`executionId`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
            FfiConverterULong.write(value.`amountSats`, buf)
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterLong.write(value.`executedAt`, buf)
            FfiConverterString.write(value.`executionDataJson`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * A supported payment method with its endpoint.
 */
data class PaymentMethod (
    var `methodId`: kotlin.String, 
    var `endpoint`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentMethod: FfiConverterRustBuffer<PaymentMethod> {
    override fun read(buf: ByteBuffer): PaymentMethod {
        return PaymentMethod(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentMethod) = (
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`)
    )

    override fun write(value: PaymentMethod, buf: ByteBuffer) {
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
    }
}



/**
 * Result of generating a payment proof.
 *
 * Returned by `PaykitClient::generate_payment_proof()` after
 * extracting proof data from a successful payment execution.
 */
data class PaymentProofResult (
    /**
     * Type of proof ("bitcoin_txid", "lightning_preimage", "custom").
     */
    var `proofType`: kotlin.String, 
    /**
     * Proof data as JSON.
     */
    var `proofDataJson`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentProofResult: FfiConverterRustBuffer<PaymentProofResult> {
    override fun read(buf: ByteBuffer): PaymentProofResult {
        return PaymentProofResult(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentProofResult) = (
            FfiConverterString.allocationSize(value.`proofType`) +
            FfiConverterString.allocationSize(value.`proofDataJson`)
    )

    override fun write(value: PaymentProofResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`proofType`, buf)
            FfiConverterString.write(value.`proofDataJson`, buf)
    }
}



/**
 * Payment request.
 */
data class PaymentRequest (
    var `requestId`: kotlin.String, 
    var `fromPubkey`: kotlin.String, 
    var `toPubkey`: kotlin.String, 
    var `amountSats`: kotlin.Long, 
    var `currency`: kotlin.String, 
    var `methodId`: kotlin.String, 
    var `description`: kotlin.String, 
    var `createdAt`: kotlin.Long, 
    var `expiresAt`: kotlin.Long?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentRequest: FfiConverterRustBuffer<PaymentRequest> {
    override fun read(buf: ByteBuffer): PaymentRequest {
        return PaymentRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalLong.read(buf),
        )
    }

    override fun allocationSize(value: PaymentRequest) = (
            FfiConverterString.allocationSize(value.`requestId`) +
            FfiConverterString.allocationSize(value.`fromPubkey`) +
            FfiConverterString.allocationSize(value.`toPubkey`) +
            FfiConverterLong.allocationSize(value.`amountSats`) +
            FfiConverterString.allocationSize(value.`currency`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`description`) +
            FfiConverterLong.allocationSize(value.`createdAt`) +
            FfiConverterOptionalLong.allocationSize(value.`expiresAt`)
    )

    override fun write(value: PaymentRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`requestId`, buf)
            FfiConverterString.write(value.`fromPubkey`, buf)
            FfiConverterString.write(value.`toPubkey`, buf)
            FfiConverterLong.write(value.`amountSats`, buf)
            FfiConverterString.write(value.`currency`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`description`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
            FfiConverterOptionalLong.write(value.`expiresAt`, buf)
    }
}



/**
 * Payment status information.
 */
data class PaymentStatusInfo (
    var `status`: PaymentStatus, 
    var `receiptId`: kotlin.String, 
    var `methodId`: kotlin.String, 
    var `updatedAt`: kotlin.Long, 
    var `confirmations`: kotlin.ULong?, 
    var `requiredConfirmations`: kotlin.ULong?, 
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentStatusInfo: FfiConverterRustBuffer<PaymentStatusInfo> {
    override fun read(buf: ByteBuffer): PaymentStatusInfo {
        return PaymentStatusInfo(
            FfiConverterTypePaymentStatus.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: PaymentStatusInfo) = (
            FfiConverterTypePaymentStatus.allocationSize(value.`status`) +
            FfiConverterString.allocationSize(value.`receiptId`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterLong.allocationSize(value.`updatedAt`) +
            FfiConverterOptionalULong.allocationSize(value.`confirmations`) +
            FfiConverterOptionalULong.allocationSize(value.`requiredConfirmations`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: PaymentStatusInfo, buf: ByteBuffer) {
            FfiConverterTypePaymentStatus.write(value.`status`, buf)
            FfiConverterString.write(value.`receiptId`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterLong.write(value.`updatedAt`, buf)
            FfiConverterOptionalULong.write(value.`confirmations`, buf)
            FfiConverterOptionalULong.write(value.`requiredConfirmations`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * FFI-safe peer spending limit information.
 */
data class PeerSpendingLimitFfi (
    /**
     * Peer public key (z-base32 encoded)
     */
    var `peerPubkey`: kotlin.String, 
    /**
     * Total spending limit in satoshis
     */
    var `totalLimitSats`: kotlin.Long, 
    /**
     * Currently spent amount in satoshis
     */
    var `currentSpentSats`: kotlin.Long, 
    /**
     * Period for limit reset ("daily", "weekly", "monthly")
     */
    var `period`: kotlin.String, 
    /**
     * Remaining limit in satoshis
     */
    var `remainingSats`: kotlin.Long, 
    /**
     * Unix timestamp of last reset
     */
    var `lastReset`: kotlin.Long
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePeerSpendingLimitFFI: FfiConverterRustBuffer<PeerSpendingLimitFfi> {
    override fun read(buf: ByteBuffer): PeerSpendingLimitFfi {
        return PeerSpendingLimitFfi(
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: PeerSpendingLimitFfi) = (
            FfiConverterString.allocationSize(value.`peerPubkey`) +
            FfiConverterLong.allocationSize(value.`totalLimitSats`) +
            FfiConverterLong.allocationSize(value.`currentSpentSats`) +
            FfiConverterString.allocationSize(value.`period`) +
            FfiConverterLong.allocationSize(value.`remainingSats`) +
            FfiConverterLong.allocationSize(value.`lastReset`)
    )

    override fun write(value: PeerSpendingLimitFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`peerPubkey`, buf)
            FfiConverterLong.write(value.`totalLimitSats`, buf)
            FfiConverterLong.write(value.`currentSpentSats`, buf)
            FfiConverterString.write(value.`period`, buf)
            FfiConverterLong.write(value.`remainingSats`, buf)
            FfiConverterLong.write(value.`lastReset`, buf)
    }
}



/**
 * Private endpoint information.
 */
data class PrivateEndpoint (
    var `peer`: kotlin.String, 
    var `methodId`: kotlin.String, 
    var `endpoint`: kotlin.String, 
    var `createdAt`: kotlin.Long, 
    var `expiresAt`: kotlin.Long?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrivateEndpoint: FfiConverterRustBuffer<PrivateEndpoint> {
    override fun read(buf: ByteBuffer): PrivateEndpoint {
        return PrivateEndpoint(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalLong.read(buf),
        )
    }

    override fun allocationSize(value: PrivateEndpoint) = (
            FfiConverterString.allocationSize(value.`peer`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`) +
            FfiConverterLong.allocationSize(value.`createdAt`) +
            FfiConverterOptionalLong.allocationSize(value.`expiresAt`)
    )

    override fun write(value: PrivateEndpoint, buf: ByteBuffer) {
            FfiConverterString.write(value.`peer`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
            FfiConverterOptionalLong.write(value.`expiresAt`, buf)
    }
}



/**
 * FFI-safe private endpoint offer.
 */
data class PrivateEndpointOffer (
    var `methodId`: kotlin.String, 
    var `endpoint`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePrivateEndpointOffer: FfiConverterRustBuffer<PrivateEndpointOffer> {
    override fun read(buf: ByteBuffer): PrivateEndpointOffer {
        return PrivateEndpointOffer(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PrivateEndpointOffer) = (
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`endpoint`)
    )

    override fun write(value: PrivateEndpointOffer, buf: ByteBuffer) {
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`endpoint`, buf)
    }
}



/**
 * Proration result.
 */
data class ProrationResult (
    var `creditSats`: kotlin.Long, 
    var `chargeSats`: kotlin.Long, 
    var `netSats`: kotlin.Long, 
    var `isRefund`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeProrationResult: FfiConverterRustBuffer<ProrationResult> {
    override fun read(buf: ByteBuffer): ProrationResult {
        return ProrationResult(
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ProrationResult) = (
            FfiConverterLong.allocationSize(value.`creditSats`) +
            FfiConverterLong.allocationSize(value.`chargeSats`) +
            FfiConverterLong.allocationSize(value.`netSats`) +
            FfiConverterBoolean.allocationSize(value.`isRefund`)
    )

    override fun write(value: ProrationResult, buf: ByteBuffer) {
            FfiConverterLong.write(value.`creditSats`, buf)
            FfiConverterLong.write(value.`chargeSats`, buf)
            FfiConverterLong.write(value.`netSats`, buf)
            FfiConverterBoolean.write(value.`isRefund`, buf)
    }
}



/**
 * Payment receipt.
 */
data class Receipt (
    var `receiptId`: kotlin.String, 
    var `payer`: kotlin.String, 
    var `payee`: kotlin.String, 
    var `methodId`: kotlin.String, 
    var `amount`: kotlin.String?, 
    var `currency`: kotlin.String?, 
    var `createdAt`: kotlin.Long, 
    var `metadataJson`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeReceipt: FfiConverterRustBuffer<Receipt> {
    override fun read(buf: ByteBuffer): Receipt {
        return Receipt(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Receipt) = (
            FfiConverterString.allocationSize(value.`receiptId`) +
            FfiConverterString.allocationSize(value.`payer`) +
            FfiConverterString.allocationSize(value.`payee`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterOptionalString.allocationSize(value.`amount`) +
            FfiConverterOptionalString.allocationSize(value.`currency`) +
            FfiConverterLong.allocationSize(value.`createdAt`) +
            FfiConverterString.allocationSize(value.`metadataJson`)
    )

    override fun write(value: Receipt, buf: ByteBuffer) {
            FfiConverterString.write(value.`receiptId`, buf)
            FfiConverterString.write(value.`payer`, buf)
            FfiConverterString.write(value.`payee`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterOptionalString.write(value.`amount`, buf)
            FfiConverterOptionalString.write(value.`currency`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
            FfiConverterString.write(value.`metadataJson`, buf)
    }
}



/**
 * Result type for receipt generation.
 *
 * Used to communicate success/failure from mobile callbacks.
 */
data class ReceiptGenerationResult (
    /**
     * Whether generation succeeded
     */
    var `success`: kotlin.Boolean, 
    /**
     * The generated receipt (if successful)
     */
    var `receipt`: ReceiptRequest?, 
    /**
     * Error message (if failed)
     */
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeReceiptGenerationResult: FfiConverterRustBuffer<ReceiptGenerationResult> {
    override fun read(buf: ByteBuffer): ReceiptGenerationResult {
        return ReceiptGenerationResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypeReceiptRequest.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ReceiptGenerationResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalTypeReceiptRequest.allocationSize(value.`receipt`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: ReceiptGenerationResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalTypeReceiptRequest.write(value.`receipt`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * FFI-safe receipt request.
 */
data class ReceiptRequest (
    var `receiptId`: kotlin.String, 
    var `payer`: kotlin.String, 
    var `payee`: kotlin.String, 
    var `methodId`: kotlin.String, 
    var `amount`: kotlin.String?, 
    var `currency`: kotlin.String?, 
    var `metadataJson`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeReceiptRequest: FfiConverterRustBuffer<ReceiptRequest> {
    override fun read(buf: ByteBuffer): ReceiptRequest {
        return ReceiptRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ReceiptRequest) = (
            FfiConverterString.allocationSize(value.`receiptId`) +
            FfiConverterString.allocationSize(value.`payer`) +
            FfiConverterString.allocationSize(value.`payee`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterOptionalString.allocationSize(value.`amount`) +
            FfiConverterOptionalString.allocationSize(value.`currency`) +
            FfiConverterString.allocationSize(value.`metadataJson`)
    )

    override fun write(value: ReceiptRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`receiptId`, buf)
            FfiConverterString.write(value.`payer`, buf)
            FfiConverterString.write(value.`payee`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterOptionalString.write(value.`amount`, buf)
            FfiConverterOptionalString.write(value.`currency`, buf)
            FfiConverterString.write(value.`metadataJson`, buf)
    }
}



/**
 * Result of scanning a QR code.
 */
data class ScannedUri (
    /**
     * The type of URI that was scanned.
     */
    var `uriType`: UriType, 
    /**
     * The public key if this is a Pubky URI.
     */
    var `publicKey`: kotlin.String?, 
    /**
     * The payment method if this is an Invoice URI.
     */
    var `methodId`: kotlin.String?, 
    /**
     * The invoice/endpoint data.
     */
    var `data`: kotlin.String?, 
    /**
     * The payment request ID if this is a PaymentRequest URI.
     */
    var `requestId`: kotlin.String?, 
    /**
     * The requester's public key if this is a PaymentRequest URI.
     */
    var `requester`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeScannedUri: FfiConverterRustBuffer<ScannedUri> {
    override fun read(buf: ByteBuffer): ScannedUri {
        return ScannedUri(
            FfiConverterTypeUriType.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ScannedUri) = (
            FfiConverterTypeUriType.allocationSize(value.`uriType`) +
            FfiConverterOptionalString.allocationSize(value.`publicKey`) +
            FfiConverterOptionalString.allocationSize(value.`methodId`) +
            FfiConverterOptionalString.allocationSize(value.`data`) +
            FfiConverterOptionalString.allocationSize(value.`requestId`) +
            FfiConverterOptionalString.allocationSize(value.`requester`)
    )

    override fun write(value: ScannedUri, buf: ByteBuffer) {
            FfiConverterTypeUriType.write(value.`uriType`, buf)
            FfiConverterOptionalString.write(value.`publicKey`, buf)
            FfiConverterOptionalString.write(value.`methodId`, buf)
            FfiConverterOptionalString.write(value.`data`, buf)
            FfiConverterOptionalString.write(value.`requestId`, buf)
            FfiConverterOptionalString.write(value.`requester`, buf)
    }
}



/**
 * Selection preferences.
 */
data class SelectionPreferences (
    var `strategy`: SelectionStrategy, 
    var `excludedMethods`: List<kotlin.String>, 
    var `maxFeeSats`: kotlin.ULong?, 
    var `maxConfirmationTimeSecs`: kotlin.ULong?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSelectionPreferences: FfiConverterRustBuffer<SelectionPreferences> {
    override fun read(buf: ByteBuffer): SelectionPreferences {
        return SelectionPreferences(
            FfiConverterTypeSelectionStrategy.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: SelectionPreferences) = (
            FfiConverterTypeSelectionStrategy.allocationSize(value.`strategy`) +
            FfiConverterSequenceString.allocationSize(value.`excludedMethods`) +
            FfiConverterOptionalULong.allocationSize(value.`maxFeeSats`) +
            FfiConverterOptionalULong.allocationSize(value.`maxConfirmationTimeSecs`)
    )

    override fun write(value: SelectionPreferences, buf: ByteBuffer) {
            FfiConverterTypeSelectionStrategy.write(value.`strategy`, buf)
            FfiConverterSequenceString.write(value.`excludedMethods`, buf)
            FfiConverterOptionalULong.write(value.`maxFeeSats`, buf)
            FfiConverterOptionalULong.write(value.`maxConfirmationTimeSecs`, buf)
    }
}



/**
 * Result of payment method selection.
 */
data class SelectionResult (
    var `primaryMethod`: kotlin.String, 
    var `fallbackMethods`: List<kotlin.String>, 
    var `reason`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSelectionResult: FfiConverterRustBuffer<SelectionResult> {
    override fun read(buf: ByteBuffer): SelectionResult {
        return SelectionResult(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SelectionResult) = (
            FfiConverterString.allocationSize(value.`primaryMethod`) +
            FfiConverterSequenceString.allocationSize(value.`fallbackMethods`) +
            FfiConverterString.allocationSize(value.`reason`)
    )

    override fun write(value: SelectionResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`primaryMethod`, buf)
            FfiConverterSequenceString.write(value.`fallbackMethods`, buf)
            FfiConverterString.write(value.`reason`, buf)
    }
}



/**
 * Result of checking if amount would exceed limit.
 */
data class SpendingCheckResultFfi (
    /**
     * Whether the amount would exceed the limit
     */
    var `wouldExceed`: kotlin.Boolean, 
    /**
     * Current spent amount in satoshis
     */
    var `currentSpentSats`: kotlin.Long, 
    /**
     * Remaining limit in satoshis
     */
    var `remainingSats`: kotlin.Long, 
    /**
     * Amount being checked in satoshis
     */
    var `checkAmountSats`: kotlin.Long
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSpendingCheckResultFFI: FfiConverterRustBuffer<SpendingCheckResultFfi> {
    override fun read(buf: ByteBuffer): SpendingCheckResultFfi {
        return SpendingCheckResultFfi(
            FfiConverterBoolean.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: SpendingCheckResultFfi) = (
            FfiConverterBoolean.allocationSize(value.`wouldExceed`) +
            FfiConverterLong.allocationSize(value.`currentSpentSats`) +
            FfiConverterLong.allocationSize(value.`remainingSats`) +
            FfiConverterLong.allocationSize(value.`checkAmountSats`)
    )

    override fun write(value: SpendingCheckResultFfi, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`wouldExceed`, buf)
            FfiConverterLong.write(value.`currentSpentSats`, buf)
            FfiConverterLong.write(value.`remainingSats`, buf)
            FfiConverterLong.write(value.`checkAmountSats`, buf)
    }
}



/**
 * FFI-safe spending reservation token.
 *
 * Returned by `try_reserve_spending()` and must be either committed
 * or rolled back after payment execution.
 */
data class SpendingReservationFfi (
    /**
     * Unique identifier for this reservation
     */
    var `reservationId`: kotlin.String, 
    /**
     * Peer public key (z-base32 encoded)
     */
    var `peerPubkey`: kotlin.String, 
    /**
     * Reserved amount in satoshis
     */
    var `amountSats`: kotlin.Long, 
    /**
     * Unix timestamp when reservation was created
     */
    var `createdAt`: kotlin.Long
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSpendingReservationFFI: FfiConverterRustBuffer<SpendingReservationFfi> {
    override fun read(buf: ByteBuffer): SpendingReservationFfi {
        return SpendingReservationFfi(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: SpendingReservationFfi) = (
            FfiConverterString.allocationSize(value.`reservationId`) +
            FfiConverterString.allocationSize(value.`peerPubkey`) +
            FfiConverterLong.allocationSize(value.`amountSats`) +
            FfiConverterLong.allocationSize(value.`createdAt`)
    )

    override fun write(value: SpendingReservationFfi, buf: ByteBuffer) {
            FfiConverterString.write(value.`reservationId`, buf)
            FfiConverterString.write(value.`peerPubkey`, buf)
            FfiConverterLong.write(value.`amountSats`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
    }
}



/**
 * Result type for storage get operations.
 */
data class StorageGetResult (
    /**
     * Whether the operation succeeded
     */
    var `success`: kotlin.Boolean, 
    /**
     * The content if found (None if not found but successful)
     */
    var `content`: kotlin.String?, 
    /**
     * Error message if failed
     */
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStorageGetResult: FfiConverterRustBuffer<StorageGetResult> {
    override fun read(buf: ByteBuffer): StorageGetResult {
        return StorageGetResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: StorageGetResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalString.allocationSize(value.`content`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: StorageGetResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalString.write(value.`content`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Result type for storage list operations.
 */
data class StorageListResult (
    /**
     * Whether the operation succeeded
     */
    var `success`: kotlin.Boolean, 
    /**
     * List of file names/paths
     */
    var `entries`: List<kotlin.String>, 
    /**
     * Error message if failed
     */
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStorageListResult: FfiConverterRustBuffer<StorageListResult> {
    override fun read(buf: ByteBuffer): StorageListResult {
        return StorageListResult(
            FfiConverterBoolean.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: StorageListResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterSequenceString.allocationSize(value.`entries`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: StorageListResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterSequenceString.write(value.`entries`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Result type for storage operations.
 */
data class StorageOperationResult (
    /**
     * Whether the operation succeeded
     */
    var `success`: kotlin.Boolean, 
    /**
     * Error message if failed
     */
    var `error`: kotlin.String?
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStorageOperationResult: FfiConverterRustBuffer<StorageOperationResult> {
    override fun read(buf: ByteBuffer): StorageOperationResult {
        return StorageOperationResult(
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: StorageOperationResult) = (
            FfiConverterBoolean.allocationSize(value.`success`) +
            FfiConverterOptionalString.allocationSize(value.`error`)
    )

    override fun write(value: StorageOperationResult, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`success`, buf)
            FfiConverterOptionalString.write(value.`error`, buf)
    }
}



/**
 * Subscription information.
 */
data class Subscription (
    var `subscriptionId`: kotlin.String, 
    var `subscriber`: kotlin.String, 
    var `provider`: kotlin.String, 
    var `terms`: SubscriptionTerms, 
    var `createdAt`: kotlin.Long, 
    var `startsAt`: kotlin.Long, 
    var `endsAt`: kotlin.Long?, 
    var `isActive`: kotlin.Boolean
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSubscription: FfiConverterRustBuffer<Subscription> {
    override fun read(buf: ByteBuffer): Subscription {
        return Subscription(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeSubscriptionTerms.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalLong.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: Subscription) = (
            FfiConverterString.allocationSize(value.`subscriptionId`) +
            FfiConverterString.allocationSize(value.`subscriber`) +
            FfiConverterString.allocationSize(value.`provider`) +
            FfiConverterTypeSubscriptionTerms.allocationSize(value.`terms`) +
            FfiConverterLong.allocationSize(value.`createdAt`) +
            FfiConverterLong.allocationSize(value.`startsAt`) +
            FfiConverterOptionalLong.allocationSize(value.`endsAt`) +
            FfiConverterBoolean.allocationSize(value.`isActive`)
    )

    override fun write(value: Subscription, buf: ByteBuffer) {
            FfiConverterString.write(value.`subscriptionId`, buf)
            FfiConverterString.write(value.`subscriber`, buf)
            FfiConverterString.write(value.`provider`, buf)
            FfiConverterTypeSubscriptionTerms.write(value.`terms`, buf)
            FfiConverterLong.write(value.`createdAt`, buf)
            FfiConverterLong.write(value.`startsAt`, buf)
            FfiConverterOptionalLong.write(value.`endsAt`, buf)
            FfiConverterBoolean.write(value.`isActive`, buf)
    }
}



/**
 * Subscription terms.
 */
data class SubscriptionTerms (
    var `amountSats`: kotlin.Long, 
    var `currency`: kotlin.String, 
    var `frequency`: PaymentFrequency, 
    var `methodId`: kotlin.String, 
    var `description`: kotlin.String
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSubscriptionTerms: FfiConverterRustBuffer<SubscriptionTerms> {
    override fun read(buf: ByteBuffer): SubscriptionTerms {
        return SubscriptionTerms(
            FfiConverterLong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypePaymentFrequency.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SubscriptionTerms) = (
            FfiConverterLong.allocationSize(value.`amountSats`) +
            FfiConverterString.allocationSize(value.`currency`) +
            FfiConverterTypePaymentFrequency.allocationSize(value.`frequency`) +
            FfiConverterString.allocationSize(value.`methodId`) +
            FfiConverterString.allocationSize(value.`description`)
    )

    override fun write(value: SubscriptionTerms, buf: ByteBuffer) {
            FfiConverterLong.write(value.`amountSats`, buf)
            FfiConverterString.write(value.`currency`, buf)
            FfiConverterTypePaymentFrequency.write(value.`frequency`, buf)
            FfiConverterString.write(value.`methodId`, buf)
            FfiConverterString.write(value.`description`, buf)
    }
}



/**
 * FFI-safe sync result.
 */
data class SyncResultFfi (
    var `total`: kotlin.UInt, 
    var `added`: kotlin.UInt, 
    var `removed`: kotlin.UInt, 
    var `syncedAt`: kotlin.Long
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSyncResultFFI: FfiConverterRustBuffer<SyncResultFfi> {
    override fun read(buf: ByteBuffer): SyncResultFfi {
        return SyncResultFfi(
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: SyncResultFfi) = (
            FfiConverterUInt.allocationSize(value.`total`) +
            FfiConverterUInt.allocationSize(value.`added`) +
            FfiConverterUInt.allocationSize(value.`removed`) +
            FfiConverterLong.allocationSize(value.`syncedAt`)
    )

    override fun write(value: SyncResultFfi, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`total`, buf)
            FfiConverterUInt.write(value.`added`, buf)
            FfiConverterUInt.write(value.`removed`, buf)
            FfiConverterLong.write(value.`syncedAt`, buf)
    }
}



/**
 * Derived X25519 keypair for Noise protocol.
 */
data class X25519Keypair (
    /**
     * Secret key - 32 bytes, hex encoded.
     */
    var `secretKeyHex`: kotlin.String, 
    /**
     * Public key - 32 bytes, hex encoded.
     */
    var `publicKeyHex`: kotlin.String, 
    /**
     * Device ID used for derivation.
     */
    var `deviceId`: kotlin.String, 
    /**
     * Epoch used for derivation.
     */
    var `epoch`: kotlin.UInt
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeX25519Keypair: FfiConverterRustBuffer<X25519Keypair> {
    override fun read(buf: ByteBuffer): X25519Keypair {
        return X25519Keypair(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: X25519Keypair) = (
            FfiConverterString.allocationSize(value.`secretKeyHex`) +
            FfiConverterString.allocationSize(value.`publicKeyHex`) +
            FfiConverterString.allocationSize(value.`deviceId`) +
            FfiConverterUInt.allocationSize(value.`epoch`)
    )

    override fun write(value: X25519Keypair, buf: ByteBuffer) {
            FfiConverterString.write(value.`secretKeyHex`, buf)
            FfiConverterString.write(value.`publicKeyHex`, buf)
            FfiConverterString.write(value.`deviceId`, buf)
            FfiConverterUInt.write(value.`epoch`, buf)
    }
}



/**
 * Bitcoin network types (FFI-compatible).
 *
 * Used to configure which Bitcoin network the wallet operates on.
 */

enum class BitcoinNetworkFfi {
    
    /**
     * Bitcoin mainnet (real money).
     */
    MAINNET,
    /**
     * Bitcoin testnet (test coins).
     */
    TESTNET,
    /**
     * Bitcoin regtest (local development).
     */
    REGTEST;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeBitcoinNetworkFFI: FfiConverterRustBuffer<BitcoinNetworkFfi> {
    override fun read(buf: ByteBuffer) = try {
        BitcoinNetworkFfi.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: BitcoinNetworkFfi) = 4UL

    override fun write(value: BitcoinNetworkFfi, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Health status of a payment method.
 */

enum class HealthStatus {
    
    HEALTHY,
    DEGRADED,
    UNAVAILABLE,
    UNKNOWN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeHealthStatus: FfiConverterRustBuffer<HealthStatus> {
    override fun read(buf: ByteBuffer) = try {
        HealthStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: HealthStatus) = 4UL

    override fun write(value: HealthStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Lightning network types (FFI-compatible).
 *
 * Used to configure which Lightning network the wallet operates on.
 */

enum class LightningNetworkFfi {
    
    /**
     * Lightning mainnet (real money).
     */
    MAINNET,
    /**
     * Lightning testnet (test coins).
     */
    TESTNET,
    /**
     * Lightning regtest (local development).
     */
    REGTEST;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeLightningNetworkFFI: FfiConverterRustBuffer<LightningNetworkFfi> {
    override fun read(buf: ByteBuffer) = try {
        LightningNetworkFfi.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: LightningNetworkFfi) = 4UL

    override fun write(value: LightningNetworkFfi, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Status of a Lightning payment (FFI-compatible).
 */

enum class LightningPaymentStatusFfi {
    
    /**
     * Payment succeeded.
     */
    SUCCEEDED,
    /**
     * Payment is pending/in-flight.
     */
    PENDING,
    /**
     * Payment failed.
     */
    FAILED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeLightningPaymentStatusFFI: FfiConverterRustBuffer<LightningPaymentStatusFfi> {
    override fun read(buf: ByteBuffer) = try {
        LightningPaymentStatusFfi.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: LightningPaymentStatusFfi) = 4UL

    override fun write(value: LightningPaymentStatusFfi, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Modification type for subscriptions.
 */
sealed class ModificationType {
    
    data class Upgrade(
        val `newAmountSats`: kotlin.Long, 
        val `effectiveDate`: kotlin.Long) : ModificationType() {
        companion object
    }
    
    data class Downgrade(
        val `newAmountSats`: kotlin.Long, 
        val `effectiveDate`: kotlin.Long) : ModificationType() {
        companion object
    }
    
    data class ChangeMethod(
        val `newMethodId`: kotlin.String) : ModificationType() {
        companion object
    }
    
    data class ChangeBillingDate(
        val `newDay`: kotlin.UByte) : ModificationType() {
        companion object
    }
    
    data class Cancel(
        val `effectiveDate`: kotlin.Long, 
        val `reason`: kotlin.String?) : ModificationType() {
        companion object
    }
    
    data class Pause(
        val `resumeDate`: kotlin.Long) : ModificationType() {
        companion object
    }
    
    object Resume : ModificationType()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeModificationType : FfiConverterRustBuffer<ModificationType>{
    override fun read(buf: ByteBuffer): ModificationType {
        return when(buf.getInt()) {
            1 -> ModificationType.Upgrade(
                FfiConverterLong.read(buf),
                FfiConverterLong.read(buf),
                )
            2 -> ModificationType.Downgrade(
                FfiConverterLong.read(buf),
                FfiConverterLong.read(buf),
                )
            3 -> ModificationType.ChangeMethod(
                FfiConverterString.read(buf),
                )
            4 -> ModificationType.ChangeBillingDate(
                FfiConverterUByte.read(buf),
                )
            5 -> ModificationType.Cancel(
                FfiConverterLong.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            6 -> ModificationType.Pause(
                FfiConverterLong.read(buf),
                )
            7 -> ModificationType.Resume
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ModificationType) = when(value) {
        is ModificationType.Upgrade -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterLong.allocationSize(value.`newAmountSats`)
                + FfiConverterLong.allocationSize(value.`effectiveDate`)
            )
        }
        is ModificationType.Downgrade -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterLong.allocationSize(value.`newAmountSats`)
                + FfiConverterLong.allocationSize(value.`effectiveDate`)
            )
        }
        is ModificationType.ChangeMethod -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`newMethodId`)
            )
        }
        is ModificationType.ChangeBillingDate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUByte.allocationSize(value.`newDay`)
            )
        }
        is ModificationType.Cancel -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterLong.allocationSize(value.`effectiveDate`)
                + FfiConverterOptionalString.allocationSize(value.`reason`)
            )
        }
        is ModificationType.Pause -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterLong.allocationSize(value.`resumeDate`)
            )
        }
        is ModificationType.Resume -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ModificationType, buf: ByteBuffer) {
        when(value) {
            is ModificationType.Upgrade -> {
                buf.putInt(1)
                FfiConverterLong.write(value.`newAmountSats`, buf)
                FfiConverterLong.write(value.`effectiveDate`, buf)
                Unit
            }
            is ModificationType.Downgrade -> {
                buf.putInt(2)
                FfiConverterLong.write(value.`newAmountSats`, buf)
                FfiConverterLong.write(value.`effectiveDate`, buf)
                Unit
            }
            is ModificationType.ChangeMethod -> {
                buf.putInt(3)
                FfiConverterString.write(value.`newMethodId`, buf)
                Unit
            }
            is ModificationType.ChangeBillingDate -> {
                buf.putInt(4)
                FfiConverterUByte.write(value.`newDay`, buf)
                Unit
            }
            is ModificationType.Cancel -> {
                buf.putInt(5)
                FfiConverterLong.write(value.`effectiveDate`, buf)
                FfiConverterOptionalString.write(value.`reason`, buf)
                Unit
            }
            is ModificationType.Pause -> {
                buf.putInt(6)
                FfiConverterLong.write(value.`resumeDate`, buf)
                Unit
            }
            is ModificationType.Resume -> {
                buf.putInt(7)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Status of a Noise connection.
 */

enum class NoiseConnectionStatus {
    
    /**
     * Not connected.
     */
    DISCONNECTED,
    /**
     * Connecting to server.
     */
    CONNECTING,
    /**
     * Handshake in progress.
     */
    HANDSHAKING,
    /**
     * Connected and ready for communication.
     */
    CONNECTED,
    /**
     * Connection failed.
     */
    FAILED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeNoiseConnectionStatus: FfiConverterRustBuffer<NoiseConnectionStatus> {
    override fun read(buf: ByteBuffer) = try {
        NoiseConnectionStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: NoiseConnectionStatus) = 4UL

    override fun write(value: NoiseConnectionStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Type of payment message exchanged over Noise channel.
 */

enum class NoisePaymentMessageType {
    
    /**
     * Request a receipt for a payment.
     */
    RECEIPT_REQUEST,
    /**
     * Confirm receipt of payment.
     */
    RECEIPT_CONFIRMATION,
    /**
     * Offer a private endpoint.
     */
    PRIVATE_ENDPOINT_OFFER,
    /**
     * Error response.
     */
    ERROR,
    /**
     * Ping for connection keep-alive.
     */
    PING,
    /**
     * Pong response to ping.
     */
    PONG;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeNoisePaymentMessageType: FfiConverterRustBuffer<NoisePaymentMessageType> {
    override fun read(buf: ByteBuffer) = try {
        NoisePaymentMessageType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: NoisePaymentMessageType) = 4UL

    override fun write(value: NoisePaymentMessageType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Parsed Paykit message.
 */
sealed class ParsedMessage {
    
    data class OfferPrivateEndpoint(
        val `offer`: PrivateEndpointOffer) : ParsedMessage() {
        companion object
    }
    
    data class RequestReceipt(
        val `request`: ReceiptRequest) : ParsedMessage() {
        companion object
    }
    
    data class ConfirmReceipt(
        val `receipt`: ReceiptRequest) : ParsedMessage() {
        companion object
    }
    
    object Ack : ParsedMessage()
    
    
    data class Error(
        val `error`: ErrorMessage) : ParsedMessage() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeParsedMessage : FfiConverterRustBuffer<ParsedMessage>{
    override fun read(buf: ByteBuffer): ParsedMessage {
        return when(buf.getInt()) {
            1 -> ParsedMessage.OfferPrivateEndpoint(
                FfiConverterTypePrivateEndpointOffer.read(buf),
                )
            2 -> ParsedMessage.RequestReceipt(
                FfiConverterTypeReceiptRequest.read(buf),
                )
            3 -> ParsedMessage.ConfirmReceipt(
                FfiConverterTypeReceiptRequest.read(buf),
                )
            4 -> ParsedMessage.Ack
            5 -> ParsedMessage.Error(
                FfiConverterTypeErrorMessage.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ParsedMessage) = when(value) {
        is ParsedMessage.OfferPrivateEndpoint -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePrivateEndpointOffer.allocationSize(value.`offer`)
            )
        }
        is ParsedMessage.RequestReceipt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeReceiptRequest.allocationSize(value.`request`)
            )
        }
        is ParsedMessage.ConfirmReceipt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeReceiptRequest.allocationSize(value.`receipt`)
            )
        }
        is ParsedMessage.Ack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ParsedMessage.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeErrorMessage.allocationSize(value.`error`)
            )
        }
    }

    override fun write(value: ParsedMessage, buf: ByteBuffer) {
        when(value) {
            is ParsedMessage.OfferPrivateEndpoint -> {
                buf.putInt(1)
                FfiConverterTypePrivateEndpointOffer.write(value.`offer`, buf)
                Unit
            }
            is ParsedMessage.RequestReceipt -> {
                buf.putInt(2)
                FfiConverterTypeReceiptRequest.write(value.`request`, buf)
                Unit
            }
            is ParsedMessage.ConfirmReceipt -> {
                buf.putInt(3)
                FfiConverterTypeReceiptRequest.write(value.`receipt`, buf)
                Unit
            }
            is ParsedMessage.Ack -> {
                buf.putInt(4)
                Unit
            }
            is ParsedMessage.Error -> {
                buf.putInt(5)
                FfiConverterTypeErrorMessage.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * FFI-safe Paykit message type.
 */

enum class PaykitMessageType {
    
    /**
     * Offer a private endpoint.
     */
    OFFER_PRIVATE_ENDPOINT,
    /**
     * Request a receipt.
     */
    REQUEST_RECEIPT,
    /**
     * Confirm a receipt.
     */
    CONFIRM_RECEIPT,
    /**
     * Acknowledgment.
     */
    ACK,
    /**
     * Error message.
     */
    ERROR;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePaykitMessageType: FfiConverterRustBuffer<PaykitMessageType> {
    override fun read(buf: ByteBuffer) = try {
        PaykitMessageType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaykitMessageType) = 4UL

    override fun write(value: PaykitMessageType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * Mobile-friendly error type.
 */
sealed class PaykitMobileException: kotlin.Exception() {
    
    /**
     * Transport layer error (network, I/O).
     */
    class Transport(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Validation error (invalid input, format).
     */
    class Validation(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Resource not found.
     */
    class NotFound(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Serialization/deserialization error.
     */
    class Serialization(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Internal error (unexpected state).
     */
    class Internal(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Network timeout error.
     */
    class NetworkTimeout(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Connection refused or failed.
     */
    class ConnectionException(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Authentication failed.
     */
    class AuthenticationException(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Session expired or invalid.
     */
    class SessionException(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Rate limit exceeded.
     */
    class RateLimitException(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Permission denied.
     */
    class PermissionDenied(
        
        val `msg`: kotlin.String
        ) : PaykitMobileException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PaykitMobileException> {
        override fun lift(error_buf: RustBuffer.ByValue): PaykitMobileException = FfiConverterTypePaykitMobileError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypePaykitMobileError : FfiConverterRustBuffer<PaykitMobileException> {
    override fun read(buf: ByteBuffer): PaykitMobileException {
        

        return when(buf.getInt()) {
            1 -> PaykitMobileException.Transport(
                FfiConverterString.read(buf),
                )
            2 -> PaykitMobileException.Validation(
                FfiConverterString.read(buf),
                )
            3 -> PaykitMobileException.NotFound(
                FfiConverterString.read(buf),
                )
            4 -> PaykitMobileException.Serialization(
                FfiConverterString.read(buf),
                )
            5 -> PaykitMobileException.Internal(
                FfiConverterString.read(buf),
                )
            6 -> PaykitMobileException.NetworkTimeout(
                FfiConverterString.read(buf),
                )
            7 -> PaykitMobileException.ConnectionException(
                FfiConverterString.read(buf),
                )
            8 -> PaykitMobileException.AuthenticationException(
                FfiConverterString.read(buf),
                )
            9 -> PaykitMobileException.SessionException(
                FfiConverterString.read(buf),
                )
            10 -> PaykitMobileException.RateLimitException(
                FfiConverterString.read(buf),
                )
            11 -> PaykitMobileException.PermissionDenied(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PaykitMobileException): ULong {
        return when(value) {
            is PaykitMobileException.Transport -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.Validation -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.NotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.Serialization -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.Internal -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.NetworkTimeout -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.ConnectionException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.AuthenticationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.SessionException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.RateLimitException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is PaykitMobileException.PermissionDenied -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
        }
    }

    override fun write(value: PaykitMobileException, buf: ByteBuffer) {
        when(value) {
            is PaykitMobileException.Transport -> {
                buf.putInt(1)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.Validation -> {
                buf.putInt(2)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.NotFound -> {
                buf.putInt(3)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.Serialization -> {
                buf.putInt(4)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.Internal -> {
                buf.putInt(5)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.NetworkTimeout -> {
                buf.putInt(6)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.ConnectionException -> {
                buf.putInt(7)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.AuthenticationException -> {
                buf.putInt(8)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.SessionException -> {
                buf.putInt(9)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.RateLimitException -> {
                buf.putInt(10)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is PaykitMobileException.PermissionDenied -> {
                buf.putInt(11)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * Payment frequency for subscriptions.
 */
sealed class PaymentFrequency {
    
    object Daily : PaymentFrequency()
    
    
    object Weekly : PaymentFrequency()
    
    
    data class Monthly(
        val `dayOfMonth`: kotlin.UByte) : PaymentFrequency() {
        companion object
    }
    
    data class Yearly(
        val `month`: kotlin.UByte, 
        val `day`: kotlin.UByte) : PaymentFrequency() {
        companion object
    }
    
    data class Custom(
        val `intervalSeconds`: kotlin.ULong) : PaymentFrequency() {
        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentFrequency : FfiConverterRustBuffer<PaymentFrequency>{
    override fun read(buf: ByteBuffer): PaymentFrequency {
        return when(buf.getInt()) {
            1 -> PaymentFrequency.Daily
            2 -> PaymentFrequency.Weekly
            3 -> PaymentFrequency.Monthly(
                FfiConverterUByte.read(buf),
                )
            4 -> PaymentFrequency.Yearly(
                FfiConverterUByte.read(buf),
                FfiConverterUByte.read(buf),
                )
            5 -> PaymentFrequency.Custom(
                FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PaymentFrequency) = when(value) {
        is PaymentFrequency.Daily -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is PaymentFrequency.Weekly -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is PaymentFrequency.Monthly -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUByte.allocationSize(value.`dayOfMonth`)
            )
        }
        is PaymentFrequency.Yearly -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUByte.allocationSize(value.`month`)
                + FfiConverterUByte.allocationSize(value.`day`)
            )
        }
        is PaymentFrequency.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.`intervalSeconds`)
            )
        }
    }

    override fun write(value: PaymentFrequency, buf: ByteBuffer) {
        when(value) {
            is PaymentFrequency.Daily -> {
                buf.putInt(1)
                Unit
            }
            is PaymentFrequency.Weekly -> {
                buf.putInt(2)
                Unit
            }
            is PaymentFrequency.Monthly -> {
                buf.putInt(3)
                FfiConverterUByte.write(value.`dayOfMonth`, buf)
                Unit
            }
            is PaymentFrequency.Yearly -> {
                buf.putInt(4)
                FfiConverterUByte.write(value.`month`, buf)
                FfiConverterUByte.write(value.`day`, buf)
                Unit
            }
            is PaymentFrequency.Custom -> {
                buf.putInt(5)
                FfiConverterULong.write(value.`intervalSeconds`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Payment status.
 */

enum class PaymentStatus {
    
    PENDING,
    PROCESSING,
    CONFIRMED,
    FINALIZED,
    FAILED,
    CANCELLED,
    EXPIRED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypePaymentStatus: FfiConverterRustBuffer<PaymentStatus> {
    override fun read(buf: ByteBuffer) = try {
        PaymentStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PaymentStatus) = 4UL

    override fun write(value: PaymentStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Payment request status.
 */

enum class RequestStatus {
    
    PENDING,
    ACCEPTED,
    DECLINED,
    EXPIRED,
    PAID;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeRequestStatus: FfiConverterRustBuffer<RequestStatus> {
    override fun read(buf: ByteBuffer) = try {
        RequestStatus.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RequestStatus) = 4UL

    override fun write(value: RequestStatus, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Selection strategy.
 */

enum class SelectionStrategy {
    
    BALANCED,
    COST_OPTIMIZED,
    SPEED_OPTIMIZED,
    PRIVACY_OPTIMIZED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSelectionStrategy: FfiConverterRustBuffer<SelectionStrategy> {
    override fun read(buf: ByteBuffer) = try {
        SelectionStrategy.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SelectionStrategy) = 4UL

    override fun write(value: SelectionStrategy, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * FFI-safe storage error type.
 */
sealed class StorageCacheException: kotlin.Exception() {
    
    class Storage(
        
        val `msg`: kotlin.String
        ) : StorageCacheException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    class Lock(
        
        val `msg`: kotlin.String
        ) : StorageCacheException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StorageCacheException> {
        override fun lift(error_buf: RustBuffer.ByValue): StorageCacheException = FfiConverterTypeStorageCacheError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeStorageCacheError : FfiConverterRustBuffer<StorageCacheException> {
    override fun read(buf: ByteBuffer): StorageCacheException {
        

        return when(buf.getInt()) {
            1 -> StorageCacheException.Storage(
                FfiConverterString.read(buf),
                )
            2 -> StorageCacheException.Lock(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StorageCacheException): ULong {
        return when(value) {
            is StorageCacheException.Storage -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is StorageCacheException.Lock -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
        }
    }

    override fun write(value: StorageCacheException, buf: ByteBuffer) {
        when(value) {
            is StorageCacheException.Storage -> {
                buf.putInt(1)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is StorageCacheException.Lock -> {
                buf.putInt(2)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * Type of scanned URI.
 */

enum class UriType {
    
    /**
     * A Pubky public key URI.
     */
    PUBKY,
    /**
     * An invoice URI (Lightning, Bitcoin, etc.).
     */
    INVOICE,
    /**
     * A payment request URI.
     */
    PAYMENT_REQUEST,
    /**
     * Unknown or invalid format.
     */
    UNKNOWN;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeUriType: FfiConverterRustBuffer<UriType> {
    override fun read(buf: ByteBuffer) = try {
        UriType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: UriType) = 4UL

    override fun write(value: UriType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * Bitcoin executor callback interface for mobile wallets.
 *
 * Implement this interface in Swift/Kotlin to provide on-chain Bitcoin
 * payment capabilities to Paykit.
 *
 * # Thread Safety
 *
 * All methods may be called from any thread. Implementations must be
 * thread-safe.
 *
 * # Error Handling
 *
 * Return `PaykitMobileError` for failures. The error will be propagated
 * to the caller.
 */
public interface BitcoinExecutorFfi {
    
    /**
     * Send Bitcoin to an address.
     *
     * # Arguments
     *
     * * `address` - The destination Bitcoin address
     * * `amount_sats` - The amount to send in satoshis
     * * `fee_rate` - Optional fee rate in sat/vB (uses wallet default if None)
     *
     * # Returns
     *
     * Transaction result with txid and fee details.
     *
     * # Errors
     *
     * Returns an error if:
     * - The address is invalid
     * - Insufficient funds
     * - Network error
     * - Wallet is locked
     */
    fun `sendToAddress`(`address`: kotlin.String, `amountSats`: kotlin.ULong, `feeRate`: kotlin.Double?): BitcoinTxResultFfi
    
    /**
     * Estimate the fee for a transaction.
     *
     * # Arguments
     *
     * * `address` - The destination address
     * * `amount_sats` - The amount to send in satoshis
     * * `target_blocks` - Confirmation target in blocks (1, 3, 6, etc.)
     *
     * # Returns
     *
     * Estimated fee in satoshis.
     */
    fun `estimateFee`(`address`: kotlin.String, `amountSats`: kotlin.ULong, `targetBlocks`: kotlin.UInt): kotlin.ULong
    
    /**
     * Get transaction details by txid.
     *
     * # Arguments
     *
     * * `txid` - The transaction ID (hex-encoded)
     *
     * # Returns
     *
     * Transaction details if found, None otherwise.
     */
    fun `getTransaction`(`txid`: kotlin.String): BitcoinTxResultFfi?
    
    /**
     * Verify a transaction was sent to the expected address and amount.
     *
     * # Arguments
     *
     * * `txid` - The transaction ID
     * * `address` - Expected destination address
     * * `amount_sats` - Expected amount in satoshis
     *
     * # Returns
     *
     * True if the transaction matches, false otherwise.
     */
    fun `verifyTransaction`(`txid`: kotlin.String, `address`: kotlin.String, `amountSats`: kotlin.ULong): kotlin.Boolean
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceBitcoinExecutorFFI {
    internal object `sendToAddress`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod0 {
        override fun callback(`uniffiHandle`: Long,`address`: RustBuffer.ByValue,`amountSats`: Long,`feeRate`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeBitcoinExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`sendToAddress`(
                    FfiConverterString.lift(`address`),
                    FfiConverterULong.lift(`amountSats`),
                    FfiConverterOptionalDouble.lift(`feeRate`),
                )
            }
            val writeReturn = { value: BitcoinTxResultFfi -> uniffiOutReturn.setValue(FfiConverterTypeBitcoinTxResultFFI.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: PaykitMobileException -> FfiConverterTypePaykitMobileError.lower(e) }
            )
        }
    }
    internal object `estimateFee`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod1 {
        override fun callback(`uniffiHandle`: Long,`address`: RustBuffer.ByValue,`amountSats`: Long,`targetBlocks`: Int,`uniffiOutReturn`: LongByReference,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeBitcoinExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`estimateFee`(
                    FfiConverterString.lift(`address`),
                    FfiConverterULong.lift(`amountSats`),
                    FfiConverterUInt.lift(`targetBlocks`),
                )
            }
            val writeReturn = { value: kotlin.ULong -> uniffiOutReturn.setValue(FfiConverterULong.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: PaykitMobileException -> FfiConverterTypePaykitMobileError.lower(e) }
            )
        }
    }
    internal object `getTransaction`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod2 {
        override fun callback(`uniffiHandle`: Long,`txid`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeBitcoinExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`getTransaction`(
                    FfiConverterString.lift(`txid`),
                )
            }
            val writeReturn = { value: BitcoinTxResultFfi? -> uniffiOutReturn.setValue(FfiConverterOptionalTypeBitcoinTxResultFFI.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: PaykitMobileException -> FfiConverterTypePaykitMobileError.lower(e) }
            )
        }
    }
    internal object `verifyTransaction`: UniffiCallbackInterfaceBitcoinExecutorFfiMethod3 {
        override fun callback(`uniffiHandle`: Long,`txid`: RustBuffer.ByValue,`address`: RustBuffer.ByValue,`amountSats`: Long,`uniffiOutReturn`: ByteByReference,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeBitcoinExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`verifyTransaction`(
                    FfiConverterString.lift(`txid`),
                    FfiConverterString.lift(`address`),
                    FfiConverterULong.lift(`amountSats`),
                )
            }
            val writeReturn = { value: kotlin.Boolean -> uniffiOutReturn.setValue(FfiConverterBoolean.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: PaykitMobileException -> FfiConverterTypePaykitMobileError.lower(e) }
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeBitcoinExecutorFFI.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceBitcoinExecutorFfi.UniffiByValue(
        `sendToAddress`,
        `estimateFee`,
        `getTransaction`,
        `verifyTransaction`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_paykit_mobile_fn_init_callback_vtable_bitcoinexecutorffi(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeBitcoinExecutorFFI: FfiConverterCallbackInterface<BitcoinExecutorFfi>()





/**
 * Lightning executor callback interface for mobile wallets.
 *
 * Implement this interface in Swift/Kotlin to provide Lightning Network
 * payment capabilities to Paykit.
 *
 * # Thread Safety
 *
 * All methods may be called from any thread. Implementations must be
 * thread-safe.
 *
 * # Error Handling
 *
 * Return `PaykitMobileError` for failures. The error will be propagated
 * to the caller.
 */
public interface LightningExecutorFfi {
    
    /**
     * Pay a BOLT11 invoice.
     *
     * # Arguments
     *
     * * `invoice` - The BOLT11 invoice string
     * * `amount_msat` - Optional amount in millisatoshis (for zero-amount invoices)
     * * `max_fee_msat` - Maximum fee willing to pay in millisatoshis
     *
     * # Returns
     *
     * Payment result with preimage proof.
     *
     * # Errors
     *
     * Returns an error if:
     * - Invoice is invalid or expired
     * - No route found
     * - Insufficient funds
     * - Payment failed
     */
    fun `payInvoice`(`invoice`: kotlin.String, `amountMsat`: kotlin.ULong?, `maxFeeMsat`: kotlin.ULong?): LightningPaymentResultFfi
    
    /**
     * Decode a BOLT11 invoice without paying.
     *
     * # Arguments
     *
     * * `invoice` - The BOLT11 invoice string
     *
     * # Returns
     *
     * Decoded invoice details.
     */
    fun `decodeInvoice`(`invoice`: kotlin.String): DecodedInvoiceFfi
    
    /**
     * Estimate the fee for paying an invoice.
     *
     * # Arguments
     *
     * * `invoice` - The BOLT11 invoice
     *
     * # Returns
     *
     * Estimated fee in millisatoshis.
     */
    fun `estimateFee`(`invoice`: kotlin.String): kotlin.ULong
    
    /**
     * Check the status of a payment by payment hash.
     *
     * # Arguments
     *
     * * `payment_hash` - The payment hash (hex-encoded)
     *
     * # Returns
     *
     * Payment result if found, None otherwise.
     */
    fun `getPayment`(`paymentHash`: kotlin.String): LightningPaymentResultFfi?
    
    /**
     * Verify a payment was made (check preimage matches hash).
     *
     * # Arguments
     *
     * * `preimage` - The payment preimage (hex-encoded)
     * * `payment_hash` - The payment hash (hex-encoded)
     *
     * # Returns
     *
     * True if preimage matches hash.
     */
    fun `verifyPreimage`(`preimage`: kotlin.String, `paymentHash`: kotlin.String): kotlin.Boolean
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceLightningExecutorFFI {
    internal object `payInvoice`: UniffiCallbackInterfaceLightningExecutorFfiMethod0 {
        override fun callback(`uniffiHandle`: Long,`invoice`: RustBuffer.ByValue,`amountMsat`: RustBuffer.ByValue,`maxFeeMsat`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLightningExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`payInvoice`(
                    FfiConverterString.lift(`invoice`),
                    FfiConverterOptionalULong.lift(`amountMsat`),
                    FfiConverterOptionalULong.lift(`maxFeeMsat`),
                )
            }
            val writeReturn = { value: LightningPaymentResultFfi -> uniffiOutReturn.setValue(FfiConverterTypeLightningPaymentResultFFI.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: PaykitMobileException -> FfiConverterTypePaykitMobileError.lower(e) }
            )
        }
    }
    internal object `decodeInvoice`: UniffiCallbackInterfaceLightningExecutorFfiMethod1 {
        override fun callback(`uniffiHandle`: Long,`invoice`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLightningExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`decodeInvoice`(
                    FfiConverterString.lift(`invoice`),
                )
            }
            val writeReturn = { value: DecodedInvoiceFfi -> uniffiOutReturn.setValue(FfiConverterTypeDecodedInvoiceFFI.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: PaykitMobileException -> FfiConverterTypePaykitMobileError.lower(e) }
            )
        }
    }
    internal object `estimateFee`: UniffiCallbackInterfaceLightningExecutorFfiMethod2 {
        override fun callback(`uniffiHandle`: Long,`invoice`: RustBuffer.ByValue,`uniffiOutReturn`: LongByReference,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLightningExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`estimateFee`(
                    FfiConverterString.lift(`invoice`),
                )
            }
            val writeReturn = { value: kotlin.ULong -> uniffiOutReturn.setValue(FfiConverterULong.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: PaykitMobileException -> FfiConverterTypePaykitMobileError.lower(e) }
            )
        }
    }
    internal object `getPayment`: UniffiCallbackInterfaceLightningExecutorFfiMethod3 {
        override fun callback(`uniffiHandle`: Long,`paymentHash`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLightningExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`getPayment`(
                    FfiConverterString.lift(`paymentHash`),
                )
            }
            val writeReturn = { value: LightningPaymentResultFfi? -> uniffiOutReturn.setValue(FfiConverterOptionalTypeLightningPaymentResultFFI.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: PaykitMobileException -> FfiConverterTypePaykitMobileError.lower(e) }
            )
        }
    }
    internal object `verifyPreimage`: UniffiCallbackInterfaceLightningExecutorFfiMethod4 {
        override fun callback(`uniffiHandle`: Long,`preimage`: RustBuffer.ByValue,`paymentHash`: RustBuffer.ByValue,`uniffiOutReturn`: ByteByReference,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLightningExecutorFFI.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`verifyPreimage`(
                    FfiConverterString.lift(`preimage`),
                    FfiConverterString.lift(`paymentHash`),
                )
            }
            val writeReturn = { value: kotlin.Boolean -> uniffiOutReturn.setValue(FfiConverterBoolean.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeLightningExecutorFFI.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceLightningExecutorFfi.UniffiByValue(
        `payInvoice`,
        `decodeInvoice`,
        `estimateFee`,
        `getPayment`,
        `verifyPreimage`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_paykit_mobile_fn_init_callback_vtable_lightningexecutorffi(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeLightningExecutorFFI: FfiConverterCallbackInterface<LightningExecutorFfi>()





/**
 * Callback interface for authenticated Pubky storage operations.
 *
 * Mobile apps implement this to wrap their Pubky SDK session.
 * All operations are performed on the owner's storage.
 *
 * # Thread Safety
 *
 * Implementations must be thread-safe (Send + Sync).
 */
public interface PubkyAuthenticatedStorageCallback {
    
    /**
     * Put (create or update) content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path (e.g., "/pub/paykit.app/v0/lightning")
     * * `content` - Content to store
     */
    fun `put`(`path`: kotlin.String, `content`: kotlin.String): StorageOperationResult
    
    /**
     * Get content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path to read
     *
     * # Returns
     *
     * Content if found, None if path doesn't exist.
     */
    fun `get`(`path`: kotlin.String): StorageGetResult
    
    /**
     * Delete content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path to delete
     */
    fun `delete`(`path`: kotlin.String): StorageOperationResult
    
    /**
     * List files with the given prefix.
     *
     * # Arguments
     *
     * * `prefix` - Path prefix to list (e.g., "/pub/paykit.app/v0/")
     */
    fun `list`(`prefix`: kotlin.String): StorageListResult
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfacePubkyAuthenticatedStorageCallback {
    internal object `put`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`path`: RustBuffer.ByValue,`content`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePubkyAuthenticatedStorageCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`put`(
                    FfiConverterString.lift(`path`),
                    FfiConverterString.lift(`content`),
                )
            }
            val writeReturn = { value: StorageOperationResult -> uniffiOutReturn.setValue(FfiConverterTypeStorageOperationResult.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `get`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod1 {
        override fun callback(`uniffiHandle`: Long,`path`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePubkyAuthenticatedStorageCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`get`(
                    FfiConverterString.lift(`path`),
                )
            }
            val writeReturn = { value: StorageGetResult -> uniffiOutReturn.setValue(FfiConverterTypeStorageGetResult.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `delete`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod2 {
        override fun callback(`uniffiHandle`: Long,`path`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePubkyAuthenticatedStorageCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`delete`(
                    FfiConverterString.lift(`path`),
                )
            }
            val writeReturn = { value: StorageOperationResult -> uniffiOutReturn.setValue(FfiConverterTypeStorageOperationResult.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `list`: UniffiCallbackInterfacePubkyAuthenticatedStorageCallbackMethod3 {
        override fun callback(`uniffiHandle`: Long,`prefix`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePubkyAuthenticatedStorageCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`list`(
                    FfiConverterString.lift(`prefix`),
                )
            }
            val writeReturn = { value: StorageListResult -> uniffiOutReturn.setValue(FfiConverterTypeStorageListResult.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypePubkyAuthenticatedStorageCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfacePubkyAuthenticatedStorageCallback.UniffiByValue(
        `put`,
        `get`,
        `delete`,
        `list`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_paykit_mobile_fn_init_callback_vtable_pubkyauthenticatedstoragecallback(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypePubkyAuthenticatedStorageCallback: FfiConverterCallbackInterface<PubkyAuthenticatedStorageCallback>()





/**
 * Callback interface for unauthenticated (read-only) Pubky storage operations.
 *
 * Mobile apps implement this to wrap their Pubky SDK public storage.
 *
 * # Thread Safety
 *
 * Implementations must be thread-safe (Send + Sync).
 */
public interface PubkyUnauthenticatedStorageCallback {
    
    /**
     * Get content at the given path from another user's public storage.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     * * `path` - Storage path to read
     */
    fun `get`(`ownerPubkey`: kotlin.String, `path`: kotlin.String): StorageGetResult
    
    /**
     * List files with the given prefix from another user's public storage.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     * * `prefix` - Path prefix to list
     */
    fun `list`(`ownerPubkey`: kotlin.String, `prefix`: kotlin.String): StorageListResult
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfacePubkyUnauthenticatedStorageCallback {
    internal object `get`: UniffiCallbackInterfacePubkyUnauthenticatedStorageCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`ownerPubkey`: RustBuffer.ByValue,`path`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePubkyUnauthenticatedStorageCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`get`(
                    FfiConverterString.lift(`ownerPubkey`),
                    FfiConverterString.lift(`path`),
                )
            }
            val writeReturn = { value: StorageGetResult -> uniffiOutReturn.setValue(FfiConverterTypeStorageGetResult.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `list`: UniffiCallbackInterfacePubkyUnauthenticatedStorageCallbackMethod1 {
        override fun callback(`uniffiHandle`: Long,`ownerPubkey`: RustBuffer.ByValue,`prefix`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePubkyUnauthenticatedStorageCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`list`(
                    FfiConverterString.lift(`ownerPubkey`),
                    FfiConverterString.lift(`prefix`),
                )
            }
            val writeReturn = { value: StorageListResult -> uniffiOutReturn.setValue(FfiConverterTypeStorageListResult.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypePubkyUnauthenticatedStorageCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfacePubkyUnauthenticatedStorageCallback.UniffiByValue(
        `get`,
        `list`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_paykit_mobile_fn_init_callback_vtable_pubkyunauthenticatedstoragecallback(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypePubkyUnauthenticatedStorageCallback: FfiConverterCallbackInterface<PubkyUnauthenticatedStorageCallback>()





/**
 * Callback interface for mobile receipt generation.
 *
 * Mobile apps implement this to generate receipts (e.g., create Lightning invoices).
 * When a payment request is received, this callback is invoked to produce
 * the final receipt with payment endpoint.
 *
 * # Example (Swift)
 *
 * ```swift
 * class MyReceiptGenerator: ReceiptGeneratorCallback {
 * func generateReceipt(request: ReceiptRequest) -> ReceiptGenerationResult {
 * // Create Lightning invoice
 * let invoice = createInvoice(amount: request.amount)
 *
 * // Update receipt with invoice in metadata
 * var receipt = request
 * receipt.metadataJson = "{\"invoice\":\"\(invoice)\"}"
 *
 * return ReceiptGenerationResult.ok(receipt: receipt)
 * }
 * }
 * ```
 */
public interface ReceiptGeneratorCallback {
    
    /**
     * Generate a receipt for a payment request.
     *
     * # Arguments
     *
     * * `request` - The provisional receipt request from the payer
     *
     * # Returns
     *
     * A `ReceiptGenerationResult` with either the finalized receipt or an error.
     */
    fun `generateReceipt`(`request`: ReceiptRequest): ReceiptGenerationResult
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceReceiptGeneratorCallback {
    internal object `generateReceipt`: UniffiCallbackInterfaceReceiptGeneratorCallbackMethod0 {
        override fun callback(`uniffiHandle`: Long,`request`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeReceiptGeneratorCallback.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`generateReceipt`(
                    FfiConverterTypeReceiptRequest.lift(`request`),
                )
            }
            val writeReturn = { value: ReceiptGenerationResult -> uniffiOutReturn.setValue(FfiConverterTypeReceiptGenerationResult.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeReceiptGeneratorCallback.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceReceiptGeneratorCallback.UniffiByValue(
        `generateReceipt`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_paykit_mobile_fn_init_callback_vtable_receiptgeneratorcallback(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeReceiptGeneratorCallback: FfiConverterCallbackInterface<ReceiptGeneratorCallback>()




/**
 * @suppress
 */
public object FfiConverterOptionalUShort: FfiConverterRustBuffer<kotlin.UShort?> {
    override fun read(buf: ByteBuffer): kotlin.UShort? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUShort.read(buf)
    }

    override fun allocationSize(value: kotlin.UShort?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUShort.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UShort?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUShort.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalULong: FfiConverterRustBuffer<kotlin.ULong?> {
    override fun read(buf: ByteBuffer): kotlin.ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: kotlin.ULong?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalLong: FfiConverterRustBuffer<kotlin.Long?> {
    override fun read(buf: ByteBuffer): kotlin.Long? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterLong.read(buf)
    }

    override fun allocationSize(value: kotlin.Long?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterLong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Long?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterLong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalDouble: FfiConverterRustBuffer<kotlin.Double?> {
    override fun read(buf: ByteBuffer): kotlin.Double? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterDouble.read(buf)
    }

    override fun allocationSize(value: kotlin.Double?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterDouble.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Double?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterDouble.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeBitcoinTxResultFFI: FfiConverterRustBuffer<BitcoinTxResultFfi?> {
    override fun read(buf: ByteBuffer): BitcoinTxResultFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeBitcoinTxResultFFI.read(buf)
    }

    override fun allocationSize(value: BitcoinTxResultFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeBitcoinTxResultFFI.allocationSize(value)
        }
    }

    override fun write(value: BitcoinTxResultFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeBitcoinTxResultFFI.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeCachedContactFFI: FfiConverterRustBuffer<CachedContactFfi?> {
    override fun read(buf: ByteBuffer): CachedContactFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeCachedContactFFI.read(buf)
    }

    override fun allocationSize(value: CachedContactFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeCachedContactFFI.allocationSize(value)
        }
    }

    override fun write(value: CachedContactFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeCachedContactFFI.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeLightningPaymentResultFFI: FfiConverterRustBuffer<LightningPaymentResultFfi?> {
    override fun read(buf: ByteBuffer): LightningPaymentResultFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeLightningPaymentResultFFI.read(buf)
    }

    override fun allocationSize(value: LightningPaymentResultFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeLightningPaymentResultFFI.allocationSize(value)
        }
    }

    override fun write(value: LightningPaymentResultFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeLightningPaymentResultFFI.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeNoiseEndpointInfo: FfiConverterRustBuffer<NoiseEndpointInfo?> {
    override fun read(buf: ByteBuffer): NoiseEndpointInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeNoiseEndpointInfo.read(buf)
    }

    override fun allocationSize(value: NoiseEndpointInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeNoiseEndpointInfo.allocationSize(value)
        }
    }

    override fun write(value: NoiseEndpointInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeNoiseEndpointInfo.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePaymentExecutionResult: FfiConverterRustBuffer<PaymentExecutionResult?> {
    override fun read(buf: ByteBuffer): PaymentExecutionResult? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePaymentExecutionResult.read(buf)
    }

    override fun allocationSize(value: PaymentExecutionResult?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePaymentExecutionResult.allocationSize(value)
        }
    }

    override fun write(value: PaymentExecutionResult?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePaymentExecutionResult.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePaymentStatusInfo: FfiConverterRustBuffer<PaymentStatusInfo?> {
    override fun read(buf: ByteBuffer): PaymentStatusInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePaymentStatusInfo.read(buf)
    }

    override fun allocationSize(value: PaymentStatusInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePaymentStatusInfo.allocationSize(value)
        }
    }

    override fun write(value: PaymentStatusInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePaymentStatusInfo.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePeerSpendingLimitFFI: FfiConverterRustBuffer<PeerSpendingLimitFfi?> {
    override fun read(buf: ByteBuffer): PeerSpendingLimitFfi? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePeerSpendingLimitFFI.read(buf)
    }

    override fun allocationSize(value: PeerSpendingLimitFfi?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePeerSpendingLimitFFI.allocationSize(value)
        }
    }

    override fun write(value: PeerSpendingLimitFfi?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePeerSpendingLimitFFI.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePrivateEndpointOffer: FfiConverterRustBuffer<PrivateEndpointOffer?> {
    override fun read(buf: ByteBuffer): PrivateEndpointOffer? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePrivateEndpointOffer.read(buf)
    }

    override fun allocationSize(value: PrivateEndpointOffer?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePrivateEndpointOffer.allocationSize(value)
        }
    }

    override fun write(value: PrivateEndpointOffer?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePrivateEndpointOffer.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeReceiptRequest: FfiConverterRustBuffer<ReceiptRequest?> {
    override fun read(buf: ByteBuffer): ReceiptRequest? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeReceiptRequest.read(buf)
    }

    override fun allocationSize(value: ReceiptRequest?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeReceiptRequest.allocationSize(value)
        }
    }

    override fun write(value: ReceiptRequest?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeReceiptRequest.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSelectionPreferences: FfiConverterRustBuffer<SelectionPreferences?> {
    override fun read(buf: ByteBuffer): SelectionPreferences? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSelectionPreferences.read(buf)
    }

    override fun allocationSize(value: SelectionPreferences?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSelectionPreferences.allocationSize(value)
        }
    }

    override fun write(value: SelectionPreferences?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSelectionPreferences.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeHealthStatus: FfiConverterRustBuffer<HealthStatus?> {
    override fun read(buf: ByteBuffer): HealthStatus? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeHealthStatus.read(buf)
    }

    override fun allocationSize(value: HealthStatus?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeHealthStatus.allocationSize(value)
        }
    }

    override fun write(value: HealthStatus?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeHealthStatus.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCachedContactFFI: FfiConverterRustBuffer<List<CachedContactFfi>> {
    override fun read(buf: ByteBuffer): List<CachedContactFfi> {
        val len = buf.getInt()
        return List<CachedContactFfi>(len) {
            FfiConverterTypeCachedContactFFI.read(buf)
        }
    }

    override fun allocationSize(value: List<CachedContactFfi>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCachedContactFFI.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<CachedContactFfi>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCachedContactFFI.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeHealthCheckResult: FfiConverterRustBuffer<List<HealthCheckResult>> {
    override fun read(buf: ByteBuffer): List<HealthCheckResult> {
        val len = buf.getInt()
        return List<HealthCheckResult>(len) {
            FfiConverterTypeHealthCheckResult.read(buf)
        }
    }

    override fun allocationSize(value: List<HealthCheckResult>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeHealthCheckResult.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<HealthCheckResult>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeHealthCheckResult.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePaymentAttempt: FfiConverterRustBuffer<List<PaymentAttempt>> {
    override fun read(buf: ByteBuffer): List<PaymentAttempt> {
        val len = buf.getInt()
        return List<PaymentAttempt>(len) {
            FfiConverterTypePaymentAttempt.read(buf)
        }
    }

    override fun allocationSize(value: List<PaymentAttempt>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePaymentAttempt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PaymentAttempt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePaymentAttempt.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePaymentCandidate: FfiConverterRustBuffer<List<PaymentCandidate>> {
    override fun read(buf: ByteBuffer): List<PaymentCandidate> {
        val len = buf.getInt()
        return List<PaymentCandidate>(len) {
            FfiConverterTypePaymentCandidate.read(buf)
        }
    }

    override fun allocationSize(value: List<PaymentCandidate>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePaymentCandidate.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PaymentCandidate>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePaymentCandidate.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePaymentMethod: FfiConverterRustBuffer<List<PaymentMethod>> {
    override fun read(buf: ByteBuffer): List<PaymentMethod> {
        val len = buf.getInt()
        return List<PaymentMethod>(len) {
            FfiConverterTypePaymentMethod.read(buf)
        }
    }

    override fun allocationSize(value: List<PaymentMethod>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePaymentMethod.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PaymentMethod>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePaymentMethod.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePaymentStatusInfo: FfiConverterRustBuffer<List<PaymentStatusInfo>> {
    override fun read(buf: ByteBuffer): List<PaymentStatusInfo> {
        val len = buf.getInt()
        return List<PaymentStatusInfo>(len) {
            FfiConverterTypePaymentStatusInfo.read(buf)
        }
    }

    override fun allocationSize(value: List<PaymentStatusInfo>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePaymentStatusInfo.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PaymentStatusInfo>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePaymentStatusInfo.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePeerSpendingLimitFFI: FfiConverterRustBuffer<List<PeerSpendingLimitFfi>> {
    override fun read(buf: ByteBuffer): List<PeerSpendingLimitFfi> {
        val len = buf.getInt()
        return List<PeerSpendingLimitFfi>(len) {
            FfiConverterTypePeerSpendingLimitFFI.read(buf)
        }
    }

    override fun allocationSize(value: List<PeerSpendingLimitFfi>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePeerSpendingLimitFFI.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PeerSpendingLimitFfi>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePeerSpendingLimitFFI.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypePrivateEndpointOffer: FfiConverterRustBuffer<List<PrivateEndpointOffer>> {
    override fun read(buf: ByteBuffer): List<PrivateEndpointOffer> {
        val len = buf.getInt()
        return List<PrivateEndpointOffer>(len) {
            FfiConverterTypePrivateEndpointOffer.read(buf)
        }
    }

    override fun allocationSize(value: List<PrivateEndpointOffer>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePrivateEndpointOffer.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PrivateEndpointOffer>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePrivateEndpointOffer.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeReceiptRequest: FfiConverterRustBuffer<List<ReceiptRequest>> {
    override fun read(buf: ByteBuffer): List<ReceiptRequest> {
        val len = buf.getInt()
        return List<ReceiptRequest>(len) {
            FfiConverterTypeReceiptRequest.read(buf)
        }
    }

    override fun allocationSize(value: List<ReceiptRequest>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeReceiptRequest.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ReceiptRequest>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeReceiptRequest.write(it, buf)
        }
    }
}
        /**
         * Create a new contact cache.
         */ fun `createContactCache`(): ContactCacheFfi {
            return FfiConverterTypeContactCacheFFI.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_contact_cache(
        _status)
}
    )
    }
    

        /**
         * Create a new async directory operations manager.
         */
    @Throws(PaykitMobileException::class) fun `createDirectoryOperationsAsync`(): DirectoryOperationsAsync {
            return FfiConverterTypeDirectoryOperationsAsync.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_directory_operations_async(
        _status)
}
    )
    }
    

        /**
         * Create an error message.
         *
         * # Arguments
         *
         * * `code` - Error code
         * * `message` - Error description
         */
    @Throws(PaykitMobileException::class) fun `createErrorMessage`(`code`: kotlin.String, `message`: kotlin.String): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_error_message(
        FfiConverterString.lower(`code`),FfiConverterString.lower(`message`),_status)
}
    )
    }
    

        /**
         * Create a new executor async bridge.
         */
    @Throws(PaykitMobileException::class) fun `createExecutorAsyncBridge`(): ExecutorAsyncBridge {
            return FfiConverterTypeExecutorAsyncBridge.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_executor_async_bridge(
        _status)
}
    )
    }
    

        /**
         * Create an executor async bridge with custom timeout.
         */
    @Throws(PaykitMobileException::class) fun `createExecutorAsyncBridgeWithTimeout`(`timeoutMs`: kotlin.ULong): ExecutorAsyncBridge {
            return FfiConverterTypeExecutorAsyncBridge.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_executor_async_bridge_with_timeout(
        FfiConverterULong.lower(`timeoutMs`),_status)
}
    )
    }
    

        /**
         * Create a new interactive manager.
         */ fun `createInteractiveManager`(`store`: ReceiptStore): PaykitInteractiveManagerFfi {
            return FfiConverterTypePaykitInteractiveManagerFFI.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_interactive_manager(
        FfiConverterTypeReceiptStore.lower(`store`),_status)
}
    )
    }
    

        /**
         * Create a new message builder.
         */ fun `createMessageBuilder`(): PaykitMessageBuilder {
            return FfiConverterTypePaykitMessageBuilder.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_message_builder(
        _status)
}
    )
    }
    

        /**
         * Create a default noise server configuration.
         */ fun `createNoiseServerConfig`(): NoiseServerConfig {
            return FfiConverterTypeNoiseServerConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_noise_server_config(
        _status)
}
    )
    }
    

        /**
         * Create a noise server configuration with a specific port.
         */ fun `createNoiseServerConfigWithPort`(`port`: kotlin.UShort): NoiseServerConfig {
            return FfiConverterTypeNoiseServerConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_noise_server_config_with_port(
        FfiConverterUShort.lower(`port`),_status)
}
    )
    }
    

        /**
         * Create a new Paykit client.
         */
    @Throws(PaykitMobileException::class) fun `createPaykitClient`(): PaykitClient {
            return FfiConverterTypePaykitClient.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_paykit_client(
        _status)
}
    )
    }
    

        /**
         * Create a private endpoint offer message.
         *
         * # Arguments
         *
         * * `method_id` - Payment method identifier
         * * `endpoint` - The private endpoint data
         * * `expires_in_secs` - Optional expiration time in seconds
         */
    @Throws(PaykitMobileException::class) fun `createPrivateEndpointOfferMessage`(`methodId`: kotlin.String, `endpoint`: kotlin.String, `expiresInSecs`: kotlin.ULong?): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_private_endpoint_offer_message(
        FfiConverterString.lower(`methodId`),FfiConverterString.lower(`endpoint`),FfiConverterOptionalULong.lower(`expiresInSecs`),_status)
}
    )
    }
    

        /**
         * Create a receipt confirmation message.
         *
         * # Arguments
         *
         * * `receipt_id` - The receipt ID being confirmed
         * * `payer_pubkey` - Payer's public key
         * * `payee_pubkey` - Payee's public key
         * * `method_id` - Payment method used
         * * `amount` - Payment amount
         * * `currency` - Currency code
         * * `signature` - Optional signature from payee
         */
    @Throws(PaykitMobileException::class) fun `createReceiptConfirmationMessage`(`receiptId`: kotlin.String, `payerPubkey`: kotlin.String, `payeePubkey`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?, `signature`: kotlin.String?): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_receipt_confirmation_message(
        FfiConverterString.lower(`receiptId`),FfiConverterString.lower(`payerPubkey`),FfiConverterString.lower(`payeePubkey`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),FfiConverterOptionalString.lower(`signature`),_status)
}
    )
    }
    

        /**
         * Create a receipt request message.
         *
         * # Arguments
         *
         * * `receipt_id` - Unique identifier for this receipt
         * * `payer_pubkey` - Payer's public key (z-base32)
         * * `payee_pubkey` - Payee's public key (z-base32)
         * * `method_id` - Payment method identifier
         * * `amount` - Optional payment amount
         * * `currency` - Optional currency code
         */
    @Throws(PaykitMobileException::class) fun `createReceiptRequestMessage`(`receiptId`: kotlin.String, `payerPubkey`: kotlin.String, `payeePubkey`: kotlin.String, `methodId`: kotlin.String, `amount`: kotlin.String?, `currency`: kotlin.String?): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_receipt_request_message(
        FfiConverterString.lower(`receiptId`),FfiConverterString.lower(`payerPubkey`),FfiConverterString.lower(`payeePubkey`),FfiConverterString.lower(`methodId`),FfiConverterOptionalString.lower(`amount`),FfiConverterOptionalString.lower(`currency`),_status)
}
    )
    }
    

        /**
         * Create a new receipt store.
         */ fun `createReceiptStore`(): ReceiptStore {
            return FfiConverterTypeReceiptStore.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_receipt_store(
        _status)
}
    )
    }
    

        /**
         * Create a new spending manager.
         *
         * # Arguments
         *
         * * `storage_path` - Path to the storage directory
         */
    @Throws(PaykitMobileException::class) fun `createSpendingManager`(`storagePath`: kotlin.String): SpendingManagerFfi {
            return FfiConverterTypeSpendingManagerFFI.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_create_spending_manager(
        FfiConverterString.lower(`storagePath`),_status)
}
    )
    }
    

        /**
         * Derive X25519 keypair for Noise protocol from Ed25519 seed.
         *
         * This uses the pubky-noise KDF to derive device-specific encryption keys
         * from the Ed25519 identity seed.
         *
         * # Arguments
         *
         * * `ed25519_secret_hex` - The Ed25519 secret key (seed) in hex format.
         * * `device_id` - A unique identifier for this device.
         * * `epoch` - Key rotation epoch (increment to rotate keys).
         *
         * # Returns
         *
         * The derived X25519 keypair for use with Noise protocol.
         */
    @Throws(PaykitMobileException::class) fun `deriveX25519Keypair`(`ed25519SecretHex`: kotlin.String, `deviceId`: kotlin.String, `epoch`: kotlin.UInt): X25519Keypair {
            return FfiConverterTypeX25519Keypair.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_derive_x25519_keypair(
        FfiConverterString.lower(`ed25519SecretHex`),FfiConverterString.lower(`deviceId`),FfiConverterUInt.lower(`epoch`),_status)
}
    )
    }
    

        /**
         * Discover a Noise endpoint for a recipient.
         *
         * Queries the recipient's public directory for their Noise server information.
         *
         * # Arguments
         *
         * * `transport` - Unauthenticated transport for reading
         * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
         *
         * # Returns
         *
         * The noise endpoint info if found, None otherwise.
         *
         * # Example
         *
         * ```ignore
         * let transport = UnauthenticatedTransportFFI::new_mock();
         * if let Some(endpoint) = discover_noise_endpoint(&transport, "8pinxxgqs41...")? {
         * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
         * println!("Server pubkey: {}", endpoint.server_noise_pubkey);
         * }
         * ```
         */
    @Throws(PaykitMobileException::class) fun `discoverNoiseEndpoint`(`transport`: UnauthenticatedTransportFfi, `recipientPubkey`: kotlin.String): NoiseEndpointInfo? {
            return FfiConverterOptionalTypeNoiseEndpointInfo.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_discover_noise_endpoint(
        FfiConverterTypeUnauthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`recipientPubkey`),_status)
}
    )
    }
    

        /**
         * Derive Ed25519 public key from secret key.
         *
         * # Arguments
         *
         * * `secret_key_hex` - The 32-byte secret key in hex format.
         *
         * # Returns
         *
         * The complete keypair derived from the secret.
         */
    @Throws(PaykitMobileException::class) fun `ed25519KeypairFromSecret`(`secretKeyHex`: kotlin.String): Ed25519Keypair {
            return FfiConverterTypeEd25519Keypair.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_ed25519_keypair_from_secret(
        FfiConverterString.lower(`secretKeyHex`),_status)
}
    )
    }
    

        /**
         * Export keypair to encrypted backup.
         *
         * # Arguments
         *
         * * `secret_key_hex` - The secret key to backup.
         * * `password` - Password to encrypt the backup.
         *
         * # Returns
         *
         * Encrypted backup that can be stored or transferred.
         */
    @Throws(PaykitMobileException::class) fun `exportKeypairToBackup`(`secretKeyHex`: kotlin.String, `password`: kotlin.String): KeyBackup {
            return FfiConverterTypeKeyBackup.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_export_keypair_to_backup(
        FfiConverterString.lower(`secretKeyHex`),FfiConverterString.lower(`password`),_status)
}
    )
    }
    

        /**
         * Format public key as z-base32 (pkarr format).
         */
    @Throws(PaykitMobileException::class) fun `formatPublicKeyZ32`(`publicKeyHex`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_format_public_key_z32(
        FfiConverterString.lower(`publicKeyHex`),_status)
}
    )
    }
    

        /**
         * Get the unique device ID for this device.
         *
         * This should be stored persistently and reused for consistent key derivation.
         * If not available, generates a new random device ID.
         */ fun `generateDeviceId`(): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_generate_device_id(
        _status)
}
    )
    }
    

        /**
         * Generate a new Ed25519 keypair for identity.
         *
         * This creates a new random identity. The secret key should be stored
         * securely and backed up.
         *
         * # Returns
         *
         * A new Ed25519 keypair with the secret in hex format.
         */
    @Throws(PaykitMobileException::class) fun `generateEd25519Keypair`(): Ed25519Keypair {
            return FfiConverterTypeEd25519Keypair.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_generate_ed25519_keypair(
        _status)
}
    )
    }
    

        /**
         * Get the library version.
         */ fun `getVersion`(): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_get_version(
        _status)
}
    )
    }
    

        /**
         * Import keypair from encrypted backup.
         *
         * # Arguments
         *
         * * `backup` - The encrypted backup.
         * * `password` - Password to decrypt the backup.
         *
         * # Returns
         *
         * The decrypted keypair.
         */
    @Throws(PaykitMobileException::class) fun `importKeypairFromBackup`(`backup`: KeyBackup, `password`: kotlin.String): Ed25519Keypair {
            return FfiConverterTypeEd25519Keypair.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_import_keypair_from_backup(
        FfiConverterTypeKeyBackup.lower(`backup`),FfiConverterString.lower(`password`),_status)
}
    )
    }
    

        /**
         * Parse a payment message from JSON.
         *
         * # Arguments
         *
         * * `json` - The JSON string to parse
         */
    @Throws(PaykitMobileException::class) fun `parsePaymentMessage`(`json`: kotlin.String): NoisePaymentMessage {
            return FfiConverterTypeNoisePaymentMessage.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_parse_payment_message(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    

        /**
         * Parse z-base32 public key to hex.
         */
    @Throws(PaykitMobileException::class) fun `parsePublicKeyZ32`(`publicKeyZ32`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_parse_public_key_z32(
        FfiConverterString.lower(`publicKeyZ32`),_status)
}
    )
    }
    

        /**
         * Publish a Noise endpoint to the directory.
         *
         * Makes this device discoverable for receiving payments via Noise protocol.
         *
         * # Arguments
         *
         * * `transport` - Authenticated transport for writing
         * * `host` - Host address where the Noise server is listening
         * * `port` - Port number where the Noise server is listening
         * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
         * * `metadata` - Optional metadata about the endpoint
         */
    @Throws(PaykitMobileException::class) fun `publishNoiseEndpoint`(`transport`: AuthenticatedTransportFfi, `host`: kotlin.String, `port`: kotlin.UShort, `noisePubkey`: kotlin.String, `metadata`: kotlin.String?)
        = 
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_publish_noise_endpoint(
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),FfiConverterString.lower(`host`),FfiConverterUShort.lower(`port`),FfiConverterString.lower(`noisePubkey`),FfiConverterOptionalString.lower(`metadata`),_status)
}
    
    

        /**
         * Remove the Noise endpoint from the directory.
         *
         * Makes this device no longer discoverable for Noise payments.
         *
         * # Arguments
         *
         * * `transport` - Authenticated transport for writing
         */
    @Throws(PaykitMobileException::class) fun `removeNoiseEndpoint`(`transport`: AuthenticatedTransportFfi)
        = 
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_remove_noise_endpoint(
        FfiConverterTypeAuthenticatedTransportFFI.lower(`transport`),_status)
}
    
    

        /**
         * Sign a message with Ed25519 secret key.
         *
         * # Arguments
         *
         * * `secret_key_hex` - The Ed25519 secret key in hex format.
         * * `message` - The message bytes to sign.
         *
         * # Returns
         *
         * The 64-byte signature in hex format.
         */
    @Throws(PaykitMobileException::class) fun `signMessage`(`secretKeyHex`: kotlin.String, `message`: kotlin.ByteArray): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_sign_message(
        FfiConverterString.lower(`secretKeyHex`),FfiConverterByteArray.lower(`message`),_status)
}
    )
    }
    

        /**
         * Verify an Ed25519 signature.
         *
         * # Arguments
         *
         * * `public_key_hex` - The Ed25519 public key in hex format.
         * * `message` - The original message bytes.
         * * `signature_hex` - The 64-byte signature in hex format.
         *
         * # Returns
         *
         * True if the signature is valid, false otherwise.
         */
    @Throws(PaykitMobileException::class) fun `verifySignature`(`publicKeyHex`: kotlin.String, `message`: kotlin.ByteArray, `signatureHex`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCallWithError(PaykitMobileException) { _status ->
    UniffiLib.INSTANCE.uniffi_paykit_mobile_fn_func_verify_signature(
        FfiConverterString.lower(`publicKeyHex`),FfiConverterByteArray.lower(`message`),FfiConverterString.lower(`signatureHex`),_status)
}
    )
    }
    


