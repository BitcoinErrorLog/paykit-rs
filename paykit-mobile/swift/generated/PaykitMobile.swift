// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(PaykitMobileFFI)
import PaykitMobileFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_paykit_mobile_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_paykit_mobile_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * FFI wrapper for authenticated transport operations.
 *
 * This wraps authenticated write access to Pubky homeservers.
 * Mobile apps can use either:
 * - `new_mock()` for testing
 * - `from_callback()` for production with real Pubky SDK
 */
public protocol AuthenticatedTransportFfiProtocol : AnyObject {
    
    /**
     * Delete a file at the given path.
     */
    func delete(path: String) throws 
    
    /**
     * Get a file at the given path.
     */
    func get(path: String) throws  -> String?
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    func isMock() throws  -> Bool
    
    /**
     * List files with a given prefix.
     */
    func list(prefix: String) throws  -> [String]
    
    /**
     * Get the owner's public key.
     */
    func ownerPubkey()  -> String
    
    /**
     * Put (create or update) a file at the given path.
     */
    func put(path: String, content: String) throws 
    
}

/**
 * FFI wrapper for authenticated transport operations.
 *
 * This wraps authenticated write access to Pubky homeservers.
 * Mobile apps can use either:
 * - `new_mock()` for testing
 * - `from_callback()` for production with real Pubky SDK
 */
public class AuthenticatedTransportFfi:
    AuthenticatedTransportFfiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_authenticatedtransportffi(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_paykit_mobile_fn_free_authenticatedtransportffi(pointer, $0) }
    }

    
    /**
     * Create authenticated transport from a storage callback.
     *
     * # Arguments
     *
     * * `callback` - Storage callback implementing PubkyAuthenticatedStorageCallback
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     *
     * # Example (Swift)
     *
     * ```swift
     * class MyPubkyStorage: PubkyAuthenticatedStorageCallback {
     * let session: PubkySession
     *
     * func put(path: String, content: String) -> StorageOperationResult {
     * do {
     * try session.storage.put(path, content)
     * return StorageOperationResult.ok()
     * } catch {
     * return StorageOperationResult.err(error.localizedDescription)
     * }
     * }
     * // ... implement other methods
     * }
     *
     * let transport = AuthenticatedTransportFFI.fromCallback(
     * MyPubkyStorage(session: session),
     * ownerPubkey: myPublicKey
     * )
     * ```
     */
    public static func fromCallback(callback: PubkyAuthenticatedStorageCallback, ownerPubkey: String)  -> AuthenticatedTransportFfi {
        return AuthenticatedTransportFfi(unsafeFromRawPointer: try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_callback(
        FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.lower(callback),
        FfiConverterString.lower(ownerPubkey),$0)
})
    }

    
    /**
     * Create authenticated transport from a Pubky session JSON.
     *
     * # Deprecated
     *
     * This method creates a mock transport. Use `from_callback()` for production.
     *
     * # Arguments
     *
     * * `session_json` - JSON configuration (validated but not used)
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     */
    public static func fromSessionJson(sessionJson: String, ownerPubkey: String) throws  -> AuthenticatedTransportFfi {
        return AuthenticatedTransportFfi(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_session_json(
        FfiConverterString.lower(sessionJson),
        FfiConverterString.lower(ownerPubkey),$0)
})
    }

    
    /**
     * Create a new authenticated transport for testing/development.
     *
     * Uses in-memory storage - data is not persisted.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     */
    public static func newMock(ownerPubkey: String)  -> AuthenticatedTransportFfi {
        return AuthenticatedTransportFfi(unsafeFromRawPointer: try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_new_mock(
        FfiConverterString.lower(ownerPubkey),$0)
})
    }

    

    
    
    /**
     * Delete a file at the given path.
     */
    public func delete(path: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_delete(self.uniffiClonePointer(), 
        FfiConverterString.lower(path),$0
    )
}
    }
    /**
     * Get a file at the given path.
     */
    public func get(path: String) throws  -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_get(self.uniffiClonePointer(), 
        FfiConverterString.lower(path),$0
    )
}
        )
    }
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    public func isMock() throws  -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_is_mock(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * List files with a given prefix.
     */
    public func list(prefix: String) throws  -> [String] {
        return try  FfiConverterSequenceString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_list(self.uniffiClonePointer(), 
        FfiConverterString.lower(prefix),$0
    )
}
        )
    }
    /**
     * Get the owner's public key.
     */
    public func ownerPubkey()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_owner_pubkey(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Put (create or update) a file at the given path.
     */
    public func put(path: String, content: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_put(self.uniffiClonePointer(), 
        FfiConverterString.lower(path),
        FfiConverterString.lower(content),$0
    )
}
    }

}

public struct FfiConverterTypeAuthenticatedTransportFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AuthenticatedTransportFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticatedTransportFfi {
        return AuthenticatedTransportFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AuthenticatedTransportFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticatedTransportFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AuthenticatedTransportFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeAuthenticatedTransportFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticatedTransportFfi {
    return try FfiConverterTypeAuthenticatedTransportFFI.lift(pointer)
}

public func FfiConverterTypeAuthenticatedTransportFFI_lower(_ value: AuthenticatedTransportFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAuthenticatedTransportFFI.lower(value)
}




/**
 * FFI-safe wrapper for local contact cache.
 */
public protocol ContactCacheFfiProtocol : AnyObject {
    
    /**
     * Add a contact by public key.
     */
    func add(pubkey: String) throws 
    
    /**
     * Add a contact with a display name.
     */
    func addWithName(pubkey: String, name: String) throws 
    
    /**
     * Clear all cached contacts.
     */
    func clear() throws 
    
    /**
     * Check if a contact exists.
     */
    func contains(pubkey: String) throws  -> Bool
    
    /**
     * Get the number of cached contacts.
     */
    func count() throws  -> UInt32
    
    /**
     * Get a specific contact by public key.
     */
    func get(pubkey: String) throws  -> CachedContactFfi?
    
    /**
     * Get all cached contacts.
     */
    func getAll() throws  -> [CachedContactFfi]
    
    /**
     * Remove a contact by public key.
     */
    func remove(pubkey: String) throws 
    
    /**
     * Sync with remote contacts.
     */
    func sync(remotePubkeys: [String]) throws  -> SyncResultFfi
    
}

/**
 * FFI-safe wrapper for local contact cache.
 */
public class ContactCacheFfi:
    ContactCacheFfiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_contactcacheffi(self.pointer, $0) }
    }
    /**
     * Create a new contact cache (uses in-memory storage).
     */
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_contactcacheffi_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_paykit_mobile_fn_free_contactcacheffi(pointer, $0) }
    }

    

    
    
    /**
     * Add a contact by public key.
     */
    public func add(pubkey: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_add(self.uniffiClonePointer(), 
        FfiConverterString.lower(pubkey),$0
    )
}
    }
    /**
     * Add a contact with a display name.
     */
    public func addWithName(pubkey: String, name: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_add_with_name(self.uniffiClonePointer(), 
        FfiConverterString.lower(pubkey),
        FfiConverterString.lower(name),$0
    )
}
    }
    /**
     * Clear all cached contacts.
     */
    public func clear() throws  {
        try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_clear(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Check if a contact exists.
     */
    public func contains(pubkey: String) throws  -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_contains(self.uniffiClonePointer(), 
        FfiConverterString.lower(pubkey),$0
    )
}
        )
    }
    /**
     * Get the number of cached contacts.
     */
    public func count() throws  -> UInt32 {
        return try  FfiConverterUInt32.lift(
            try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_count(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get a specific contact by public key.
     */
    public func get(pubkey: String) throws  -> CachedContactFfi? {
        return try  FfiConverterOptionTypeCachedContactFFI.lift(
            try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_get(self.uniffiClonePointer(), 
        FfiConverterString.lower(pubkey),$0
    )
}
        )
    }
    /**
     * Get all cached contacts.
     */
    public func getAll() throws  -> [CachedContactFfi] {
        return try  FfiConverterSequenceTypeCachedContactFFI.lift(
            try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_get_all(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Remove a contact by public key.
     */
    public func remove(pubkey: String) throws  {
        try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_remove(self.uniffiClonePointer(), 
        FfiConverterString.lower(pubkey),$0
    )
}
    }
    /**
     * Sync with remote contacts.
     */
    public func sync(remotePubkeys: [String]) throws  -> SyncResultFfi {
        return try  FfiConverterTypeSyncResultFFI.lift(
            try 
    rustCallWithError(FfiConverterTypeStorageCacheError.lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_sync(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(remotePubkeys),$0
    )
}
        )
    }

}

public struct FfiConverterTypeContactCacheFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ContactCacheFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ContactCacheFfi {
        return ContactCacheFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ContactCacheFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContactCacheFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ContactCacheFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeContactCacheFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> ContactCacheFfi {
    return try FfiConverterTypeContactCacheFFI.lift(pointer)
}

public func FfiConverterTypeContactCacheFFI_lower(_ value: ContactCacheFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeContactCacheFFI.lower(value)
}




/**
 * Async directory operations manager.
 *
 * Provides non-blocking directory operations with callback support.
 */
public protocol DirectoryOperationsAsyncProtocol : AnyObject {
    
    /**
     * Add a contact asynchronously.
     */
    func addContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws 
    
    /**
     * Fetch known contacts asynchronously.
     */
    func fetchKnownContacts(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [String]
    
    /**
     * Fetch a specific payment endpoint asynchronously.
     */
    func fetchPaymentEndpoint(transport: UnauthenticatedTransportFfi, ownerPubkey: String, methodId: String) throws  -> String?
    
    /**
     * Fetch all supported payment methods asynchronously.
     */
    func fetchSupportedPayments(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [PaymentMethod]
    
    /**
     * List all contacts asynchronously.
     */
    func listContacts(transport: AuthenticatedTransportFfi) throws  -> [String]
    
    /**
     * Publish a payment endpoint asynchronously.
     *
     * This is a blocking call that wraps the async operation.
     * For true non-blocking behavior, use the callback-based methods from mobile SDKs.
     */
    func publishPaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String, endpointData: String) throws 
    
    /**
     * Remove a contact asynchronously.
     */
    func removeContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws 
    
    /**
     * Remove a payment endpoint asynchronously.
     */
    func removePaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String) throws 
    
}

/**
 * Async directory operations manager.
 *
 * Provides non-blocking directory operations with callback support.
 */
public class DirectoryOperationsAsync:
    DirectoryOperationsAsyncProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_directoryoperationsasync(self.pointer, $0) }
    }
    /**
     * Create a new async directory operations manager.
     */
    public convenience init() throws  {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_constructor_directoryoperationsasync_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_paykit_mobile_fn_free_directoryoperationsasync(pointer, $0) }
    }

    

    
    
    /**
     * Add a contact asynchronously.
     */
    public func addContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_add_contact(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(contactPubkey),$0
    )
}
    }
    /**
     * Fetch known contacts asynchronously.
     */
    public func fetchKnownContacts(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [String] {
        return try  FfiConverterSequenceString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_known_contacts(self.uniffiClonePointer(), 
        FfiConverterTypeUnauthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(ownerPubkey),$0
    )
}
        )
    }
    /**
     * Fetch a specific payment endpoint asynchronously.
     */
    public func fetchPaymentEndpoint(transport: UnauthenticatedTransportFfi, ownerPubkey: String, methodId: String) throws  -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_payment_endpoint(self.uniffiClonePointer(), 
        FfiConverterTypeUnauthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(ownerPubkey),
        FfiConverterString.lower(methodId),$0
    )
}
        )
    }
    /**
     * Fetch all supported payment methods asynchronously.
     */
    public func fetchSupportedPayments(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [PaymentMethod] {
        return try  FfiConverterSequenceTypePaymentMethod.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_supported_payments(self.uniffiClonePointer(), 
        FfiConverterTypeUnauthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(ownerPubkey),$0
    )
}
        )
    }
    /**
     * List all contacts asynchronously.
     */
    public func listContacts(transport: AuthenticatedTransportFfi) throws  -> [String] {
        return try  FfiConverterSequenceString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_list_contacts(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),$0
    )
}
        )
    }
    /**
     * Publish a payment endpoint asynchronously.
     *
     * This is a blocking call that wraps the async operation.
     * For true non-blocking behavior, use the callback-based methods from mobile SDKs.
     */
    public func publishPaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String, endpointData: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_publish_payment_endpoint(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpointData),$0
    )
}
    }
    /**
     * Remove a contact asynchronously.
     */
    public func removeContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_contact(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(contactPubkey),$0
    )
}
    }
    /**
     * Remove a payment endpoint asynchronously.
     */
    public func removePaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_payment_endpoint(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(methodId),$0
    )
}
    }

}

public struct FfiConverterTypeDirectoryOperationsAsync: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DirectoryOperationsAsync

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DirectoryOperationsAsync {
        return DirectoryOperationsAsync(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DirectoryOperationsAsync) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DirectoryOperationsAsync {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DirectoryOperationsAsync, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeDirectoryOperationsAsync_lift(_ pointer: UnsafeMutableRawPointer) throws -> DirectoryOperationsAsync {
    return try FfiConverterTypeDirectoryOperationsAsync.lift(pointer)
}

public func FfiConverterTypeDirectoryOperationsAsync_lower(_ value: DirectoryOperationsAsync) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDirectoryOperationsAsync.lower(value)
}




/**
 * Main Paykit client for mobile applications.
 */
public protocol PaykitClientProtocol : AnyObject {
    
    /**
     * Add a contact to the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to add
     */
    func addContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws 
    
    /**
     * Calculate proration for a subscription modification.
     */
    func calculateProration(currentAmountSats: Int64, newAmountSats: Int64, periodStart: Int64, periodEnd: Int64, changeDate: Int64) throws  -> ProrationResult
    
    /**
     * Check health of all payment methods.
     */
    func checkHealth()  -> [HealthCheckResult]
    
    /**
     * Create a payment request.
     */
    func createPaymentRequest(fromPubkey: String, toPubkey: String, amountSats: Int64, currency: String, methodId: String, description: String, expiresInSecs: UInt64?) throws  -> PaymentRequest
    
    /**
     * Create a new receipt.
     */
    func createReceipt(payer: String, payee: String, methodId: String, amount: String?, currency: String?) throws  -> Receipt
    
    /**
     * Create a new subscription.
     */
    func createSubscription(subscriber: String, provider: String, terms: SubscriptionTerms) throws  -> Subscription
    
    /**
     * Get days remaining in current billing period.
     */
    func daysRemainingInPeriod(periodEnd: Int64)  -> UInt32
    
    /**
     * Extract public key from scanned QR code.
     */
    func extractKeyFromQr(scannedData: String)  -> String?
    
    /**
     * Extract payment method from scanned QR code.
     */
    func extractMethodFromQr(scannedData: String)  -> String?
    
    /**
     * Fetch known contacts for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     *
     * # Returns
     *
     * List of contact public keys.
     */
    func fetchKnownContacts(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [String]
    
    /**
     * Fetch a specific payment endpoint for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     * * `method_id` - The payment method to fetch
     *
     * # Returns
     *
     * The endpoint data if found, None otherwise.
     */
    func fetchPaymentEndpoint(transport: UnauthenticatedTransportFfi, ownerPubkey: String, methodId: String) throws  -> String?
    
    /**
     * Fetch all supported payment methods for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query (z-base32 encoded)
     *
     * # Returns
     *
     * List of payment methods with their endpoints.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * let methods = client.fetch_supported_payments(transport, "8pinxxgqs41...")?;
     * for method in methods {
     * println!("{}: {}", method.method_id, method.endpoint);
     * }
     * ```
     */
    func fetchSupportedPayments(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [PaymentMethod]
    
    /**
     * Get health status of a specific method.
     */
    func getHealthStatus(methodId: String)  -> HealthStatus?
    
    /**
     * Get all in-progress payments.
     */
    func getInProgressPayments()  -> [PaymentStatusInfo]
    
    /**
     * Get payment status for a receipt.
     */
    func getPaymentStatus(receiptId: String)  -> PaymentStatusInfo?
    
    /**
     * Check if a method is usable (healthy or degraded).
     */
    func isMethodUsable(methodId: String)  -> Bool
    
    /**
     * Check if scanned data looks like a Paykit URI.
     */
    func isPaykitQr(scannedData: String)  -> Bool
    
    /**
     * List all contacts.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     *
     * # Returns
     *
     * List of contact public keys.
     */
    func listContacts(transport: AuthenticatedTransportFfi) throws  -> [String]
    
    /**
     * Get the list of registered payment methods.
     */
    func listMethods()  -> [String]
    
    /**
     * Parse receipt metadata as JSON.
     */
    func parseReceiptMetadata(metadataJson: String) throws  -> String
    
    /**
     * Parse scanned QR code data as a Paykit URI.
     */
    func parseScannedQr(scannedData: String) throws  -> ScannedUri
    
    /**
     * Publish a payment endpoint to the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint_data` - The endpoint data to publish
     *
     * # Example
     *
     * ```ignore
     * let transport = AuthenticatedTransportFFI::from_session_json(session, pubkey)?;
     * client.publish_payment_endpoint(transport, "lightning", "lnbc1...")?;
     * ```
     */
    func publishPaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String, endpointData: String) throws 
    
    /**
     * Remove a contact from the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to remove
     */
    func removeContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws 
    
    /**
     * Remove a payment endpoint from the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier to remove
     */
    func removePaymentEndpointFromDirectory(transport: AuthenticatedTransportFfi, methodId: String) throws 
    
    /**
     * Select the best payment method from supported options.
     */
    func selectMethod(supportedMethods: [PaymentMethod], amountSats: UInt64, preferences: SelectionPreferences?) throws  -> SelectionResult
    
    /**
     * Validate an endpoint for a specific method.
     */
    func validateEndpoint(methodId: String, endpoint: String) throws  -> Bool
    
}

/**
 * Main Paykit client for mobile applications.
 */
public class PaykitClient:
    PaykitClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_paykitclient(self.pointer, $0) }
    }
    /**
     * Create a new Paykit client.
     */
    public convenience init() throws  {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_constructor_paykitclient_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_paykit_mobile_fn_free_paykitclient(pointer, $0) }
    }

    

    
    
    /**
     * Add a contact to the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to add
     */
    public func addContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_add_contact(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(contactPubkey),$0
    )
}
    }
    /**
     * Calculate proration for a subscription modification.
     */
    public func calculateProration(currentAmountSats: Int64, newAmountSats: Int64, periodStart: Int64, periodEnd: Int64, changeDate: Int64) throws  -> ProrationResult {
        return try  FfiConverterTypeProrationResult.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_calculate_proration(self.uniffiClonePointer(), 
        FfiConverterInt64.lower(currentAmountSats),
        FfiConverterInt64.lower(newAmountSats),
        FfiConverterInt64.lower(periodStart),
        FfiConverterInt64.lower(periodEnd),
        FfiConverterInt64.lower(changeDate),$0
    )
}
        )
    }
    /**
     * Check health of all payment methods.
     */
    public func checkHealth()  -> [HealthCheckResult] {
        return try!  FfiConverterSequenceTypeHealthCheckResult.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_check_health(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Create a payment request.
     */
    public func createPaymentRequest(fromPubkey: String, toPubkey: String, amountSats: Int64, currency: String, methodId: String, description: String, expiresInSecs: UInt64?) throws  -> PaymentRequest {
        return try  FfiConverterTypePaymentRequest.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_payment_request(self.uniffiClonePointer(), 
        FfiConverterString.lower(fromPubkey),
        FfiConverterString.lower(toPubkey),
        FfiConverterInt64.lower(amountSats),
        FfiConverterString.lower(currency),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(description),
        FfiConverterOptionUInt64.lower(expiresInSecs),$0
    )
}
        )
    }
    /**
     * Create a new receipt.
     */
    public func createReceipt(payer: String, payee: String, methodId: String, amount: String?, currency: String?) throws  -> Receipt {
        return try  FfiConverterTypeReceipt.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_receipt(self.uniffiClonePointer(), 
        FfiConverterString.lower(payer),
        FfiConverterString.lower(payee),
        FfiConverterString.lower(methodId),
        FfiConverterOptionString.lower(amount),
        FfiConverterOptionString.lower(currency),$0
    )
}
        )
    }
    /**
     * Create a new subscription.
     */
    public func createSubscription(subscriber: String, provider: String, terms: SubscriptionTerms) throws  -> Subscription {
        return try  FfiConverterTypeSubscription.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_subscription(self.uniffiClonePointer(), 
        FfiConverterString.lower(subscriber),
        FfiConverterString.lower(provider),
        FfiConverterTypeSubscriptionTerms.lower(terms),$0
    )
}
        )
    }
    /**
     * Get days remaining in current billing period.
     */
    public func daysRemainingInPeriod(periodEnd: Int64)  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_days_remaining_in_period(self.uniffiClonePointer(), 
        FfiConverterInt64.lower(periodEnd),$0
    )
}
        )
    }
    /**
     * Extract public key from scanned QR code.
     */
    public func extractKeyFromQr(scannedData: String)  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_extract_key_from_qr(self.uniffiClonePointer(), 
        FfiConverterString.lower(scannedData),$0
    )
}
        )
    }
    /**
     * Extract payment method from scanned QR code.
     */
    public func extractMethodFromQr(scannedData: String)  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_extract_method_from_qr(self.uniffiClonePointer(), 
        FfiConverterString.lower(scannedData),$0
    )
}
        )
    }
    /**
     * Fetch known contacts for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     *
     * # Returns
     *
     * List of contact public keys.
     */
    public func fetchKnownContacts(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [String] {
        return try  FfiConverterSequenceString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_fetch_known_contacts(self.uniffiClonePointer(), 
        FfiConverterTypeUnauthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(ownerPubkey),$0
    )
}
        )
    }
    /**
     * Fetch a specific payment endpoint for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     * * `method_id` - The payment method to fetch
     *
     * # Returns
     *
     * The endpoint data if found, None otherwise.
     */
    public func fetchPaymentEndpoint(transport: UnauthenticatedTransportFfi, ownerPubkey: String, methodId: String) throws  -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_fetch_payment_endpoint(self.uniffiClonePointer(), 
        FfiConverterTypeUnauthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(ownerPubkey),
        FfiConverterString.lower(methodId),$0
    )
}
        )
    }
    /**
     * Fetch all supported payment methods for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query (z-base32 encoded)
     *
     * # Returns
     *
     * List of payment methods with their endpoints.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * let methods = client.fetch_supported_payments(transport, "8pinxxgqs41...")?;
     * for method in methods {
     * println!("{}: {}", method.method_id, method.endpoint);
     * }
     * ```
     */
    public func fetchSupportedPayments(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [PaymentMethod] {
        return try  FfiConverterSequenceTypePaymentMethod.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_fetch_supported_payments(self.uniffiClonePointer(), 
        FfiConverterTypeUnauthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(ownerPubkey),$0
    )
}
        )
    }
    /**
     * Get health status of a specific method.
     */
    public func getHealthStatus(methodId: String)  -> HealthStatus? {
        return try!  FfiConverterOptionTypeHealthStatus.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_get_health_status(self.uniffiClonePointer(), 
        FfiConverterString.lower(methodId),$0
    )
}
        )
    }
    /**
     * Get all in-progress payments.
     */
    public func getInProgressPayments()  -> [PaymentStatusInfo] {
        return try!  FfiConverterSequenceTypePaymentStatusInfo.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_get_in_progress_payments(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get payment status for a receipt.
     */
    public func getPaymentStatus(receiptId: String)  -> PaymentStatusInfo? {
        return try!  FfiConverterOptionTypePaymentStatusInfo.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_get_payment_status(self.uniffiClonePointer(), 
        FfiConverterString.lower(receiptId),$0
    )
}
        )
    }
    /**
     * Check if a method is usable (healthy or degraded).
     */
    public func isMethodUsable(methodId: String)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_is_method_usable(self.uniffiClonePointer(), 
        FfiConverterString.lower(methodId),$0
    )
}
        )
    }
    /**
     * Check if scanned data looks like a Paykit URI.
     */
    public func isPaykitQr(scannedData: String)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_is_paykit_qr(self.uniffiClonePointer(), 
        FfiConverterString.lower(scannedData),$0
    )
}
        )
    }
    /**
     * List all contacts.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     *
     * # Returns
     *
     * List of contact public keys.
     */
    public func listContacts(transport: AuthenticatedTransportFfi) throws  -> [String] {
        return try  FfiConverterSequenceString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_list_contacts(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),$0
    )
}
        )
    }
    /**
     * Get the list of registered payment methods.
     */
    public func listMethods()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitclient_list_methods(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Parse receipt metadata as JSON.
     */
    public func parseReceiptMetadata(metadataJson: String) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_parse_receipt_metadata(self.uniffiClonePointer(), 
        FfiConverterString.lower(metadataJson),$0
    )
}
        )
    }
    /**
     * Parse scanned QR code data as a Paykit URI.
     */
    public func parseScannedQr(scannedData: String) throws  -> ScannedUri {
        return try  FfiConverterTypeScannedUri.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_parse_scanned_qr(self.uniffiClonePointer(), 
        FfiConverterString.lower(scannedData),$0
    )
}
        )
    }
    /**
     * Publish a payment endpoint to the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint_data` - The endpoint data to publish
     *
     * # Example
     *
     * ```ignore
     * let transport = AuthenticatedTransportFFI::from_session_json(session, pubkey)?;
     * client.publish_payment_endpoint(transport, "lightning", "lnbc1...")?;
     * ```
     */
    public func publishPaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String, endpointData: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_publish_payment_endpoint(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpointData),$0
    )
}
    }
    /**
     * Remove a contact from the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to remove
     */
    public func removeContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_remove_contact(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(contactPubkey),$0
    )
}
    }
    /**
     * Remove a payment endpoint from the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier to remove
     */
    public func removePaymentEndpointFromDirectory(transport: AuthenticatedTransportFfi, methodId: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_remove_payment_endpoint_from_directory(self.uniffiClonePointer(), 
        FfiConverterTypeAuthenticatedTransportFFI.lower(transport),
        FfiConverterString.lower(methodId),$0
    )
}
    }
    /**
     * Select the best payment method from supported options.
     */
    public func selectMethod(supportedMethods: [PaymentMethod], amountSats: UInt64, preferences: SelectionPreferences?) throws  -> SelectionResult {
        return try  FfiConverterTypeSelectionResult.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_select_method(self.uniffiClonePointer(), 
        FfiConverterSequenceTypePaymentMethod.lower(supportedMethods),
        FfiConverterUInt64.lower(amountSats),
        FfiConverterOptionTypeSelectionPreferences.lower(preferences),$0
    )
}
        )
    }
    /**
     * Validate an endpoint for a specific method.
     */
    public func validateEndpoint(methodId: String, endpoint: String) throws  -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_validate_endpoint(self.uniffiClonePointer(), 
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpoint),$0
    )
}
        )
    }

}

public struct FfiConverterTypePaykitClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaykitClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitClient {
        return PaykitClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaykitClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaykitClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypePaykitClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitClient {
    return try FfiConverterTypePaykitClient.lift(pointer)
}

public func FfiConverterTypePaykitClient_lower(_ value: PaykitClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaykitClient.lower(value)
}




/**
 * FFI wrapper for PaykitInteractiveManager.
 *
 * This provides a high-level interface for managing interactive payment flows
 * over Noise channels. Mobile apps use this to:
 *
 * 1. Process incoming messages and generate responses
 * 2. Initiate payment flows
 * 3. Manage receipts and private endpoints
 *
 * # Thread Safety
 *
 * This type is thread-safe and can be used from multiple threads.
 */
public protocol PaykitInteractiveManagerFfiProtocol : AnyObject {
    
    /**
     * Create a private endpoint offer message.
     *
     * Use this to offer a private payment endpoint to a peer.
     *
     * # Arguments
     *
     * * `method_id` - Payment method (e.g., "lightning")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice)
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    func createEndpointOffer(methodId: String, endpoint: String) throws  -> String
    
    /**
     * Create a payment request message to initiate a payment flow.
     *
     * Use this to create the initial message for requesting payment from a peer.
     *
     * # Arguments
     *
     * * `payer` - Your public key (the one paying)
     * * `payee` - The recipient's public key
     * * `method_id` - Payment method (e.g., "lightning", "onchain")
     * * `amount` - Optional amount (as string, e.g., "1000")
     * * `currency` - Optional currency code (e.g., "SAT")
     * * `metadata_json` - Optional JSON metadata
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    func createPaymentRequest(payer: String, payee: String, methodId: String, amount: String?, currency: String?, metadataJson: String?) throws  -> String
    
    /**
     * Get a private endpoint for a peer.
     */
    func getPrivateEndpoint(peer: String, methodId: String) throws  -> PrivateEndpointOffer?
    
    /**
     * Get a receipt by ID.
     */
    func getReceipt(receiptId: String) throws  -> ReceiptRequest?
    
    /**
     * Get the receipt store.
     */
    func getStore()  -> ReceiptStore
    
    /**
     * Handle an incoming message from a peer.
     *
     * This processes a JSON message received over a Noise channel and returns
     * an optional response to send back.
     *
     * # Arguments
     *
     * * `message_json` - The JSON-encoded message from the Noise channel
     * * `peer_pubkey` - The public key of the peer who sent the message
     * * `my_pubkey` - Your own public key
     *
     * # Returns
     *
     * Optional JSON response to send back over the Noise channel.
     * Returns `None` for messages that don't require a response (e.g., Ack).
     *
     * # Example
     *
     * ```ignore
     * // In Swift/Kotlin
     * let response = manager.handleMessage(messageJson, peerPubkey, myPubkey)
     * if let responseJson = response {
     * noiseChannel.send(responseJson)
     * }
     * ```
     */
    func handleMessage(messageJson: String, peerPubkey: String, myPubkey: String) throws  -> String?
    
    /**
     * Handle a payment confirmation response.
     *
     * Call this when you receive a response to your payment request.
     * It validates the response and saves the confirmed receipt.
     *
     * # Arguments
     *
     * * `response_json` - The JSON response from the Noise channel
     * * `original_receipt_id` - The receipt ID from your original request
     *
     * # Returns
     *
     * The confirmed receipt if successful, or an error.
     */
    func handlePaymentResponse(responseJson: String, originalReceiptId: String) throws  -> ReceiptRequest
    
    /**
     * List all private endpoints for a peer.
     */
    func listPrivateEndpoints(peer: String) throws  -> [PrivateEndpointOffer]
    
    /**
     * List all receipts.
     */
    func listReceipts() throws  -> [ReceiptRequest]
    
    /**
     * Set the receipt generator callback.
     *
     * This must be called before handling receipt requests.
     *
     * # Arguments
     *
     * * `generator` - Callback for generating receipts (implement in Swift/Kotlin)
     *
     * # Errors
     *
     * Returns an error if the internal lock is poisoned.
     */
    func setGenerator(generator: ReceiptGeneratorCallback) throws 
    
}

/**
 * FFI wrapper for PaykitInteractiveManager.
 *
 * This provides a high-level interface for managing interactive payment flows
 * over Noise channels. Mobile apps use this to:
 *
 * 1. Process incoming messages and generate responses
 * 2. Initiate payment flows
 * 3. Manage receipts and private endpoints
 *
 * # Thread Safety
 *
 * This type is thread-safe and can be used from multiple threads.
 */
public class PaykitInteractiveManagerFfi:
    PaykitInteractiveManagerFfiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_paykitinteractivemanagerffi(self.pointer, $0) }
    }
    /**
     * Create a new interactive manager without a generator.
     *
     * Use `set_generator` to set the receipt generator callback.
     *
     * # Arguments
     *
     * * `store` - Receipt store for persistence
     */
    public convenience init(store: ReceiptStore)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_paykitinteractivemanagerffi_new(
        FfiConverterTypeReceiptStore.lower(store),$0)
})
    }

    deinit {
        try! rustCall { uniffi_paykit_mobile_fn_free_paykitinteractivemanagerffi(pointer, $0) }
    }

    

    
    
    /**
     * Create a private endpoint offer message.
     *
     * Use this to offer a private payment endpoint to a peer.
     *
     * # Arguments
     *
     * * `method_id` - Payment method (e.g., "lightning")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice)
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    public func createEndpointOffer(methodId: String, endpoint: String) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_endpoint_offer(self.uniffiClonePointer(), 
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpoint),$0
    )
}
        )
    }
    /**
     * Create a payment request message to initiate a payment flow.
     *
     * Use this to create the initial message for requesting payment from a peer.
     *
     * # Arguments
     *
     * * `payer` - Your public key (the one paying)
     * * `payee` - The recipient's public key
     * * `method_id` - Payment method (e.g., "lightning", "onchain")
     * * `amount` - Optional amount (as string, e.g., "1000")
     * * `currency` - Optional currency code (e.g., "SAT")
     * * `metadata_json` - Optional JSON metadata
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    public func createPaymentRequest(payer: String, payee: String, methodId: String, amount: String?, currency: String?, metadataJson: String?) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_payment_request(self.uniffiClonePointer(), 
        FfiConverterString.lower(payer),
        FfiConverterString.lower(payee),
        FfiConverterString.lower(methodId),
        FfiConverterOptionString.lower(amount),
        FfiConverterOptionString.lower(currency),
        FfiConverterOptionString.lower(metadataJson),$0
    )
}
        )
    }
    /**
     * Get a private endpoint for a peer.
     */
    public func getPrivateEndpoint(peer: String, methodId: String) throws  -> PrivateEndpointOffer? {
        return try  FfiConverterOptionTypePrivateEndpointOffer.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_private_endpoint(self.uniffiClonePointer(), 
        FfiConverterString.lower(peer),
        FfiConverterString.lower(methodId),$0
    )
}
        )
    }
    /**
     * Get a receipt by ID.
     */
    public func getReceipt(receiptId: String) throws  -> ReceiptRequest? {
        return try  FfiConverterOptionTypeReceiptRequest.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_receipt(self.uniffiClonePointer(), 
        FfiConverterString.lower(receiptId),$0
    )
}
        )
    }
    /**
     * Get the receipt store.
     */
    public func getStore()  -> ReceiptStore {
        return try!  FfiConverterTypeReceiptStore.lift(
            try! 
    rustCall() {
    
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_store(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Handle an incoming message from a peer.
     *
     * This processes a JSON message received over a Noise channel and returns
     * an optional response to send back.
     *
     * # Arguments
     *
     * * `message_json` - The JSON-encoded message from the Noise channel
     * * `peer_pubkey` - The public key of the peer who sent the message
     * * `my_pubkey` - Your own public key
     *
     * # Returns
     *
     * Optional JSON response to send back over the Noise channel.
     * Returns `None` for messages that don't require a response (e.g., Ack).
     *
     * # Example
     *
     * ```ignore
     * // In Swift/Kotlin
     * let response = manager.handleMessage(messageJson, peerPubkey, myPubkey)
     * if let responseJson = response {
     * noiseChannel.send(responseJson)
     * }
     * ```
     */
    public func handleMessage(messageJson: String, peerPubkey: String, myPubkey: String) throws  -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_message(self.uniffiClonePointer(), 
        FfiConverterString.lower(messageJson),
        FfiConverterString.lower(peerPubkey),
        FfiConverterString.lower(myPubkey),$0
    )
}
        )
    }
    /**
     * Handle a payment confirmation response.
     *
     * Call this when you receive a response to your payment request.
     * It validates the response and saves the confirmed receipt.
     *
     * # Arguments
     *
     * * `response_json` - The JSON response from the Noise channel
     * * `original_receipt_id` - The receipt ID from your original request
     *
     * # Returns
     *
     * The confirmed receipt if successful, or an error.
     */
    public func handlePaymentResponse(responseJson: String, originalReceiptId: String) throws  -> ReceiptRequest {
        return try  FfiConverterTypeReceiptRequest.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_payment_response(self.uniffiClonePointer(), 
        FfiConverterString.lower(responseJson),
        FfiConverterString.lower(originalReceiptId),$0
    )
}
        )
    }
    /**
     * List all private endpoints for a peer.
     */
    public func listPrivateEndpoints(peer: String) throws  -> [PrivateEndpointOffer] {
        return try  FfiConverterSequenceTypePrivateEndpointOffer.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_private_endpoints(self.uniffiClonePointer(), 
        FfiConverterString.lower(peer),$0
    )
}
        )
    }
    /**
     * List all receipts.
     */
    public func listReceipts() throws  -> [ReceiptRequest] {
        return try  FfiConverterSequenceTypeReceiptRequest.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_receipts(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Set the receipt generator callback.
     *
     * This must be called before handling receipt requests.
     *
     * # Arguments
     *
     * * `generator` - Callback for generating receipts (implement in Swift/Kotlin)
     *
     * # Errors
     *
     * Returns an error if the internal lock is poisoned.
     */
    public func setGenerator(generator: ReceiptGeneratorCallback) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_set_generator(self.uniffiClonePointer(), 
        FfiConverterCallbackInterfaceReceiptGeneratorCallback.lower(generator),$0
    )
}
    }

}

public struct FfiConverterTypePaykitInteractiveManagerFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaykitInteractiveManagerFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitInteractiveManagerFfi {
        return PaykitInteractiveManagerFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaykitInteractiveManagerFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitInteractiveManagerFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaykitInteractiveManagerFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypePaykitInteractiveManagerFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitInteractiveManagerFfi {
    return try FfiConverterTypePaykitInteractiveManagerFFI.lift(pointer)
}

public func FfiConverterTypePaykitInteractiveManagerFFI_lower(_ value: PaykitInteractiveManagerFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaykitInteractiveManagerFFI.lower(value)
}




/**
 * Builder for creating Paykit protocol messages.
 *
 * Use this to create JSON messages for sending over Noise channels.
 */
public protocol PaykitMessageBuilderProtocol : AnyObject {
    
    /**
     * Create an acknowledgment message.
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createAck() throws  -> String
    
    /**
     * Create an endpoint offer message.
     *
     * # Arguments
     *
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice, Bitcoin address)
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createEndpointOffer(methodId: String, endpoint: String) throws  -> String
    
    /**
     * Create an error message.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error message
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createError(code: String, message: String) throws  -> String
    
    /**
     * Create a receipt confirmation message.
     *
     * # Arguments
     *
     * * `receipt` - The confirmed receipt details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createReceiptConfirm(receipt: ReceiptRequest) throws  -> String
    
    /**
     * Create a receipt request message.
     *
     * # Arguments
     *
     * * `request` - The receipt request details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createReceiptRequest(request: ReceiptRequest) throws  -> String
    
    /**
     * Get the message type from a JSON message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message
     *
     * # Returns
     *
     * The message type.
     */
    func getMessageType(messageJson: String) throws  -> PaykitMessageType
    
    /**
     * Parse a received message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message from Noise channel
     *
     * # Returns
     *
     * Parsed message for processing.
     */
    func parseMessage(messageJson: String) throws  -> ParsedMessage
    
}

/**
 * Builder for creating Paykit protocol messages.
 *
 * Use this to create JSON messages for sending over Noise channels.
 */
public class PaykitMessageBuilder:
    PaykitMessageBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_paykitmessagebuilder(self.pointer, $0) }
    }
    /**
     * Create a new message builder.
     */
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_paykitmessagebuilder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_paykit_mobile_fn_free_paykitmessagebuilder(pointer, $0) }
    }

    

    
    
    /**
     * Create an acknowledgment message.
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    public func createAck() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_ack(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Create an endpoint offer message.
     *
     * # Arguments
     *
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice, Bitcoin address)
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    public func createEndpointOffer(methodId: String, endpoint: String) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_endpoint_offer(self.uniffiClonePointer(), 
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpoint),$0
    )
}
        )
    }
    /**
     * Create an error message.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error message
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    public func createError(code: String, message: String) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_error(self.uniffiClonePointer(), 
        FfiConverterString.lower(code),
        FfiConverterString.lower(message),$0
    )
}
        )
    }
    /**
     * Create a receipt confirmation message.
     *
     * # Arguments
     *
     * * `receipt` - The confirmed receipt details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    public func createReceiptConfirm(receipt: ReceiptRequest) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_confirm(self.uniffiClonePointer(), 
        FfiConverterTypeReceiptRequest.lower(receipt),$0
    )
}
        )
    }
    /**
     * Create a receipt request message.
     *
     * # Arguments
     *
     * * `request` - The receipt request details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    public func createReceiptRequest(request: ReceiptRequest) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_request(self.uniffiClonePointer(), 
        FfiConverterTypeReceiptRequest.lower(request),$0
    )
}
        )
    }
    /**
     * Get the message type from a JSON message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message
     *
     * # Returns
     *
     * The message type.
     */
    public func getMessageType(messageJson: String) throws  -> PaykitMessageType {
        return try  FfiConverterTypePaykitMessageType.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_get_message_type(self.uniffiClonePointer(), 
        FfiConverterString.lower(messageJson),$0
    )
}
        )
    }
    /**
     * Parse a received message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message from Noise channel
     *
     * # Returns
     *
     * Parsed message for processing.
     */
    public func parseMessage(messageJson: String) throws  -> ParsedMessage {
        return try  FfiConverterTypeParsedMessage.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_parse_message(self.uniffiClonePointer(), 
        FfiConverterString.lower(messageJson),$0
    )
}
        )
    }

}

public struct FfiConverterTypePaykitMessageBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaykitMessageBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitMessageBuilder {
        return PaykitMessageBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaykitMessageBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitMessageBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaykitMessageBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypePaykitMessageBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitMessageBuilder {
    return try FfiConverterTypePaykitMessageBuilder.lift(pointer)
}

public func FfiConverterTypePaykitMessageBuilder_lower(_ value: PaykitMessageBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaykitMessageBuilder.lower(value)
}




/**
 * In-memory receipt storage for mobile.
 *
 * Stores receipts during a session. For persistence, mobile apps should
 * save receipts to their own storage (Keychain/SharedPreferences).
 */
public protocol ReceiptStoreProtocol : AnyObject {
    
    /**
     * Clear all stored data.
     */
    func clear() throws 
    
    /**
     * Delete a receipt.
     */
    func deleteReceipt(receiptId: String) throws 
    
    /**
     * Export all receipts as JSON.
     */
    func exportReceiptsJson() throws  -> String
    
    /**
     * Get a private endpoint.
     */
    func getPrivateEndpoint(peer: String, methodId: String) throws  -> PrivateEndpointOffer?
    
    /**
     * Get a receipt by ID.
     */
    func getReceipt(receiptId: String) throws  -> ReceiptRequest?
    
    /**
     * Import receipts from JSON.
     */
    func importReceiptsJson(json: String) throws  -> UInt32
    
    /**
     * List all private endpoints for a peer.
     */
    func listPrivateEndpoints(peer: String) throws  -> [PrivateEndpointOffer]
    
    /**
     * List all receipts.
     */
    func listReceipts() throws  -> [ReceiptRequest]
    
    /**
     * Save a private endpoint.
     */
    func savePrivateEndpoint(peer: String, offer: PrivateEndpointOffer) throws 
    
    /**
     * Save a receipt.
     */
    func saveReceipt(receipt: ReceiptRequest) throws 
    
}

/**
 * In-memory receipt storage for mobile.
 *
 * Stores receipts during a session. For persistence, mobile apps should
 * save receipts to their own storage (Keychain/SharedPreferences).
 */
public class ReceiptStore:
    ReceiptStoreProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_receiptstore(self.pointer, $0) }
    }
    /**
     * Create a new receipt store.
     */
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_receiptstore_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_paykit_mobile_fn_free_receiptstore(pointer, $0) }
    }

    

    
    
    /**
     * Clear all stored data.
     */
    public func clear() throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_clear(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Delete a receipt.
     */
    public func deleteReceipt(receiptId: String) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_delete_receipt(self.uniffiClonePointer(), 
        FfiConverterString.lower(receiptId),$0
    )
}
    }
    /**
     * Export all receipts as JSON.
     */
    public func exportReceiptsJson() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_export_receipts_json(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get a private endpoint.
     */
    public func getPrivateEndpoint(peer: String, methodId: String) throws  -> PrivateEndpointOffer? {
        return try  FfiConverterOptionTypePrivateEndpointOffer.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_get_private_endpoint(self.uniffiClonePointer(), 
        FfiConverterString.lower(peer),
        FfiConverterString.lower(methodId),$0
    )
}
        )
    }
    /**
     * Get a receipt by ID.
     */
    public func getReceipt(receiptId: String) throws  -> ReceiptRequest? {
        return try  FfiConverterOptionTypeReceiptRequest.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_get_receipt(self.uniffiClonePointer(), 
        FfiConverterString.lower(receiptId),$0
    )
}
        )
    }
    /**
     * Import receipts from JSON.
     */
    public func importReceiptsJson(json: String) throws  -> UInt32 {
        return try  FfiConverterUInt32.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_import_receipts_json(self.uniffiClonePointer(), 
        FfiConverterString.lower(json),$0
    )
}
        )
    }
    /**
     * List all private endpoints for a peer.
     */
    public func listPrivateEndpoints(peer: String) throws  -> [PrivateEndpointOffer] {
        return try  FfiConverterSequenceTypePrivateEndpointOffer.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_list_private_endpoints(self.uniffiClonePointer(), 
        FfiConverterString.lower(peer),$0
    )
}
        )
    }
    /**
     * List all receipts.
     */
    public func listReceipts() throws  -> [ReceiptRequest] {
        return try  FfiConverterSequenceTypeReceiptRequest.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_list_receipts(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Save a private endpoint.
     */
    public func savePrivateEndpoint(peer: String, offer: PrivateEndpointOffer) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_save_private_endpoint(self.uniffiClonePointer(), 
        FfiConverterString.lower(peer),
        FfiConverterTypePrivateEndpointOffer.lower(offer),$0
    )
}
    }
    /**
     * Save a receipt.
     */
    public func saveReceipt(receipt: ReceiptRequest) throws  {
        try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_save_receipt(self.uniffiClonePointer(), 
        FfiConverterTypeReceiptRequest.lower(receipt),$0
    )
}
    }

}

public struct FfiConverterTypeReceiptStore: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ReceiptStore

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ReceiptStore {
        return ReceiptStore(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ReceiptStore) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiptStore {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ReceiptStore, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeReceiptStore_lift(_ pointer: UnsafeMutableRawPointer) throws -> ReceiptStore {
    return try FfiConverterTypeReceiptStore.lift(pointer)
}

public func FfiConverterTypeReceiptStore_lower(_ value: ReceiptStore) -> UnsafeMutableRawPointer {
    return FfiConverterTypeReceiptStore.lower(value)
}




/**
 * FFI wrapper for unauthenticated (read-only) transport operations.
 *
 * This wraps read-only access to public Pubky storage.
 * Mobile apps can use this to discover payment methods for other users.
 *
 * # Creating in Production
 *
 * Implement `PubkyUnauthenticatedStorageCallback` in Swift/Kotlin:
 *
 * ```swift
 * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
 * func get(ownerPubkey: String, path: String) -> StorageGetResult {
 * // Use Pubky SDK to read from public storage
 * let url = "pubky://\(ownerPubkey)\(path)"
 * if let content = try? pubkyClient.get(url) {
 * return StorageGetResult.ok(content: content)
 * }
 * return StorageGetResult.ok(content: nil) // Not found
 * }
 *
 * func list(ownerPubkey: String, prefix: String) -> StorageListResult {
 * // ... implement using Pubky SDK
 * }
 * }
 *
 * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
 * ```
 */
public protocol UnauthenticatedTransportFfiProtocol : AnyObject {
    
    /**
     * Get a file at the given path from a public key's storage.
     */
    func get(ownerPubkey: String, path: String) throws  -> String?
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    func isMock() throws  -> Bool
    
    /**
     * List files with a given prefix from a public key's storage.
     */
    func list(ownerPubkey: String, prefix: String) throws  -> [String]
    
}

/**
 * FFI wrapper for unauthenticated (read-only) transport operations.
 *
 * This wraps read-only access to public Pubky storage.
 * Mobile apps can use this to discover payment methods for other users.
 *
 * # Creating in Production
 *
 * Implement `PubkyUnauthenticatedStorageCallback` in Swift/Kotlin:
 *
 * ```swift
 * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
 * func get(ownerPubkey: String, path: String) -> StorageGetResult {
 * // Use Pubky SDK to read from public storage
 * let url = "pubky://\(ownerPubkey)\(path)"
 * if let content = try? pubkyClient.get(url) {
 * return StorageGetResult.ok(content: content)
 * }
 * return StorageGetResult.ok(content: nil) // Not found
 * }
 *
 * func list(ownerPubkey: String, prefix: String) -> StorageListResult {
 * // ... implement using Pubky SDK
 * }
 * }
 *
 * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
 * ```
 */
public class UnauthenticatedTransportFfi:
    UnauthenticatedTransportFfiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_unauthenticatedtransportffi(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_paykit_mobile_fn_free_unauthenticatedtransportffi(pointer, $0) }
    }

    
    /**
     * Create unauthenticated transport that shares mock storage with an authenticated transport.
     *
     * Useful for testing when you want reads to see writes from the same session.
     *
     * # Note
     *
     * This only works with mock transports. For callback-based transports,
     * create a new `UnauthenticatedTransportFFI::from_callback()` that shares
     * the underlying Pubky client.
     */
    public static func fromAuthenticated(auth: AuthenticatedTransportFfi) throws  -> UnauthenticatedTransportFfi {
        return UnauthenticatedTransportFfi(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_authenticated(
        FfiConverterTypeAuthenticatedTransportFFI.lower(auth),$0)
})
    }

    
    /**
     * Create unauthenticated transport from a storage callback.
     *
     * # Arguments
     *
     * * `callback` - Storage callback implementing PubkyUnauthenticatedStorageCallback
     *
     * # Example (Swift)
     *
     * ```swift
     * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
     * func get(ownerPubkey: String, path: String) -> StorageGetResult {
     * // Use Pubky SDK to read from public storage
     * // ...
     * }
     * }
     *
     * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
     * ```
     */
    public static func fromCallback(callback: PubkyUnauthenticatedStorageCallback)  -> UnauthenticatedTransportFfi {
        return UnauthenticatedTransportFfi(unsafeFromRawPointer: try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_callback(
        FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.lower(callback),$0)
})
    }

    
    /**
     * Create unauthenticated transport from Pubky SDK configuration.
     *
     * # Deprecated
     *
     * This method creates a mock transport. Use `from_callback()` for production.
     *
     * # Arguments
     *
     * * `config_json` - JSON configuration (validated but not used)
     */
    public static func fromConfigJson(configJson: String) throws  -> UnauthenticatedTransportFfi {
        return UnauthenticatedTransportFfi(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_config_json(
        FfiConverterString.lower(configJson),$0)
})
    }

    
    /**
     * Create a new unauthenticated transport for testing/development.
     *
     * Uses in-memory storage - no network calls are made.
     */
    public static func newMock()  -> UnauthenticatedTransportFfi {
        return UnauthenticatedTransportFfi(unsafeFromRawPointer: try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_new_mock($0)
})
    }

    

    
    
    /**
     * Get a file at the given path from a public key's storage.
     */
    public func get(ownerPubkey: String, path: String) throws  -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_get(self.uniffiClonePointer(), 
        FfiConverterString.lower(ownerPubkey),
        FfiConverterString.lower(path),$0
    )
}
        )
    }
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    public func isMock() throws  -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_is_mock(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * List files with a given prefix from a public key's storage.
     */
    public func list(ownerPubkey: String, prefix: String) throws  -> [String] {
        return try  FfiConverterSequenceString.lift(
            try 
    rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_list(self.uniffiClonePointer(), 
        FfiConverterString.lower(ownerPubkey),
        FfiConverterString.lower(prefix),$0
    )
}
        )
    }

}

public struct FfiConverterTypeUnauthenticatedTransportFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnauthenticatedTransportFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnauthenticatedTransportFfi {
        return UnauthenticatedTransportFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnauthenticatedTransportFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnauthenticatedTransportFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnauthenticatedTransportFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeUnauthenticatedTransportFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnauthenticatedTransportFfi {
    return try FfiConverterTypeUnauthenticatedTransportFFI.lift(pointer)
}

public func FfiConverterTypeUnauthenticatedTransportFFI_lower(_ value: UnauthenticatedTransportFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnauthenticatedTransportFFI.lower(value)
}


/**
 * Payment amount.
 */
public struct Amount {
    public var value: String
    public var currency: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: String, 
        currency: String) {
        self.value = value
        self.currency = currency
    }
}


extension Amount: Equatable, Hashable {
    public static func ==(lhs: Amount, rhs: Amount) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(currency)
    }
}


public struct FfiConverterTypeAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        return
            try Amount(
                value: FfiConverterString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
    }
}


public func FfiConverterTypeAmount_lift(_ buf: RustBuffer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(buf)
}

public func FfiConverterTypeAmount_lower(_ value: Amount) -> RustBuffer {
    return FfiConverterTypeAmount.lower(value)
}


/**
 * FFI-safe cached contact.
 */
public struct CachedContactFfi {
    public var pubkey: String
    public var name: String?
    public var addedAt: Int64
    public var lastSyncedAt: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        pubkey: String, 
        name: String?, 
        addedAt: Int64, 
        lastSyncedAt: Int64?) {
        self.pubkey = pubkey
        self.name = name
        self.addedAt = addedAt
        self.lastSyncedAt = lastSyncedAt
    }
}


extension CachedContactFfi: Equatable, Hashable {
    public static func ==(lhs: CachedContactFfi, rhs: CachedContactFfi) -> Bool {
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.addedAt != rhs.addedAt {
            return false
        }
        if lhs.lastSyncedAt != rhs.lastSyncedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pubkey)
        hasher.combine(name)
        hasher.combine(addedAt)
        hasher.combine(lastSyncedAt)
    }
}


public struct FfiConverterTypeCachedContactFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CachedContactFfi {
        return
            try CachedContactFfi(
                pubkey: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                addedAt: FfiConverterInt64.read(from: &buf), 
                lastSyncedAt: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: CachedContactFfi, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterInt64.write(value.addedAt, into: &buf)
        FfiConverterOptionInt64.write(value.lastSyncedAt, into: &buf)
    }
}


public func FfiConverterTypeCachedContactFFI_lift(_ buf: RustBuffer) throws -> CachedContactFfi {
    return try FfiConverterTypeCachedContactFFI.lift(buf)
}

public func FfiConverterTypeCachedContactFFI_lower(_ value: CachedContactFfi) -> RustBuffer {
    return FfiConverterTypeCachedContactFFI.lower(value)
}


/**
 * Generated Ed25519 keypair for identity.
 */
public struct Ed25519Keypair {
    /**
     * Secret key (seed) - 32 bytes, hex encoded.
     * SENSITIVE: Store securely, this is the root identity secret.
     */
    public var secretKeyHex: String
    /**
     * Public key - 32 bytes, hex encoded.
     */
    public var publicKeyHex: String
    /**
     * Public key in z-base32 format (pkarr format).
     */
    public var publicKeyZ32: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Secret key (seed) - 32 bytes, hex encoded.
         * SENSITIVE: Store securely, this is the root identity secret.
         */
        secretKeyHex: String, 
        /**
         * Public key - 32 bytes, hex encoded.
         */
        publicKeyHex: String, 
        /**
         * Public key in z-base32 format (pkarr format).
         */
        publicKeyZ32: String) {
        self.secretKeyHex = secretKeyHex
        self.publicKeyHex = publicKeyHex
        self.publicKeyZ32 = publicKeyZ32
    }
}


extension Ed25519Keypair: Equatable, Hashable {
    public static func ==(lhs: Ed25519Keypair, rhs: Ed25519Keypair) -> Bool {
        if lhs.secretKeyHex != rhs.secretKeyHex {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        if lhs.publicKeyZ32 != rhs.publicKeyZ32 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretKeyHex)
        hasher.combine(publicKeyHex)
        hasher.combine(publicKeyZ32)
    }
}


public struct FfiConverterTypeEd25519Keypair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Keypair {
        return
            try Ed25519Keypair(
                secretKeyHex: FfiConverterString.read(from: &buf), 
                publicKeyHex: FfiConverterString.read(from: &buf), 
                publicKeyZ32: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Ed25519Keypair, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretKeyHex, into: &buf)
        FfiConverterString.write(value.publicKeyHex, into: &buf)
        FfiConverterString.write(value.publicKeyZ32, into: &buf)
    }
}


public func FfiConverterTypeEd25519Keypair_lift(_ buf: RustBuffer) throws -> Ed25519Keypair {
    return try FfiConverterTypeEd25519Keypair.lift(buf)
}

public func FfiConverterTypeEd25519Keypair_lower(_ value: Ed25519Keypair) -> RustBuffer {
    return FfiConverterTypeEd25519Keypair.lower(value)
}


/**
 * Endpoint data for a payment method.
 */
public struct EndpointData {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: String) {
        self.value = value
    }
}


extension EndpointData: Equatable, Hashable {
    public static func ==(lhs: EndpointData, rhs: EndpointData) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeEndpointData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EndpointData {
        return
            try EndpointData(
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EndpointData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeEndpointData_lift(_ buf: RustBuffer) throws -> EndpointData {
    return try FfiConverterTypeEndpointData.lift(buf)
}

public func FfiConverterTypeEndpointData_lower(_ value: EndpointData) -> RustBuffer {
    return FfiConverterTypeEndpointData.lower(value)
}


/**
 * FFI-safe error message.
 */
public struct ErrorMessage {
    public var code: String
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        code: String, 
        message: String) {
        self.code = code
        self.message = message
    }
}


extension ErrorMessage: Equatable, Hashable {
    public static func ==(lhs: ErrorMessage, rhs: ErrorMessage) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeErrorMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorMessage {
        return
            try ErrorMessage(
                code: FfiConverterString.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ErrorMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeErrorMessage_lift(_ buf: RustBuffer) throws -> ErrorMessage {
    return try FfiConverterTypeErrorMessage.lift(buf)
}

public func FfiConverterTypeErrorMessage_lower(_ value: ErrorMessage) -> RustBuffer {
    return FfiConverterTypeErrorMessage.lower(value)
}


/**
 * Health check result.
 */
public struct HealthCheckResult {
    public var methodId: String
    public var status: HealthStatus
    public var checkedAt: Int64
    public var latencyMs: UInt64?
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        methodId: String, 
        status: HealthStatus, 
        checkedAt: Int64, 
        latencyMs: UInt64?, 
        error: String?) {
        self.methodId = methodId
        self.status = status
        self.checkedAt = checkedAt
        self.latencyMs = latencyMs
        self.error = error
    }
}


extension HealthCheckResult: Equatable, Hashable {
    public static func ==(lhs: HealthCheckResult, rhs: HealthCheckResult) -> Bool {
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.checkedAt != rhs.checkedAt {
            return false
        }
        if lhs.latencyMs != rhs.latencyMs {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(methodId)
        hasher.combine(status)
        hasher.combine(checkedAt)
        hasher.combine(latencyMs)
        hasher.combine(error)
    }
}


public struct FfiConverterTypeHealthCheckResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HealthCheckResult {
        return
            try HealthCheckResult(
                methodId: FfiConverterString.read(from: &buf), 
                status: FfiConverterTypeHealthStatus.read(from: &buf), 
                checkedAt: FfiConverterInt64.read(from: &buf), 
                latencyMs: FfiConverterOptionUInt64.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HealthCheckResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterTypeHealthStatus.write(value.status, into: &buf)
        FfiConverterInt64.write(value.checkedAt, into: &buf)
        FfiConverterOptionUInt64.write(value.latencyMs, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


public func FfiConverterTypeHealthCheckResult_lift(_ buf: RustBuffer) throws -> HealthCheckResult {
    return try FfiConverterTypeHealthCheckResult.lift(buf)
}

public func FfiConverterTypeHealthCheckResult_lower(_ value: HealthCheckResult) -> RustBuffer {
    return FfiConverterTypeHealthCheckResult.lower(value)
}


/**
 * Encrypted key backup for export/import.
 */
public struct KeyBackup {
    /**
     * Version of the backup format.
     */
    public var version: UInt32
    /**
     * Encrypted secret key (AES-GCM).
     */
    public var encryptedDataHex: String
    /**
     * Salt for key derivation from password.
     */
    public var saltHex: String
    /**
     * Nonce for AES-GCM.
     */
    public var nonceHex: String
    /**
     * Public key (not encrypted, for identification).
     */
    public var publicKeyZ32: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Version of the backup format.
         */
        version: UInt32, 
        /**
         * Encrypted secret key (AES-GCM).
         */
        encryptedDataHex: String, 
        /**
         * Salt for key derivation from password.
         */
        saltHex: String, 
        /**
         * Nonce for AES-GCM.
         */
        nonceHex: String, 
        /**
         * Public key (not encrypted, for identification).
         */
        publicKeyZ32: String) {
        self.version = version
        self.encryptedDataHex = encryptedDataHex
        self.saltHex = saltHex
        self.nonceHex = nonceHex
        self.publicKeyZ32 = publicKeyZ32
    }
}


extension KeyBackup: Equatable, Hashable {
    public static func ==(lhs: KeyBackup, rhs: KeyBackup) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.encryptedDataHex != rhs.encryptedDataHex {
            return false
        }
        if lhs.saltHex != rhs.saltHex {
            return false
        }
        if lhs.nonceHex != rhs.nonceHex {
            return false
        }
        if lhs.publicKeyZ32 != rhs.publicKeyZ32 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(encryptedDataHex)
        hasher.combine(saltHex)
        hasher.combine(nonceHex)
        hasher.combine(publicKeyZ32)
    }
}


public struct FfiConverterTypeKeyBackup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyBackup {
        return
            try KeyBackup(
                version: FfiConverterUInt32.read(from: &buf), 
                encryptedDataHex: FfiConverterString.read(from: &buf), 
                saltHex: FfiConverterString.read(from: &buf), 
                nonceHex: FfiConverterString.read(from: &buf), 
                publicKeyZ32: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: KeyBackup, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.version, into: &buf)
        FfiConverterString.write(value.encryptedDataHex, into: &buf)
        FfiConverterString.write(value.saltHex, into: &buf)
        FfiConverterString.write(value.nonceHex, into: &buf)
        FfiConverterString.write(value.publicKeyZ32, into: &buf)
    }
}


public func FfiConverterTypeKeyBackup_lift(_ buf: RustBuffer) throws -> KeyBackup {
    return try FfiConverterTypeKeyBackup.lift(buf)
}

public func FfiConverterTypeKeyBackup_lower(_ value: KeyBackup) -> RustBuffer {
    return FfiConverterTypeKeyBackup.lower(value)
}


/**
 * A payment method identifier.
 */
public struct MethodId {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: String) {
        self.value = value
    }
}


extension MethodId: Equatable, Hashable {
    public static func ==(lhs: MethodId, rhs: MethodId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeMethodId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MethodId {
        return
            try MethodId(
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MethodId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeMethodId_lift(_ buf: RustBuffer) throws -> MethodId {
    return try FfiConverterTypeMethodId.lift(buf)
}

public func FfiConverterTypeMethodId_lower(_ value: MethodId) -> RustBuffer {
    return FfiConverterTypeMethodId.lower(value)
}


/**
 * A supported payment method with its endpoint.
 */
public struct PaymentMethod {
    public var methodId: String
    public var endpoint: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        methodId: String, 
        endpoint: String) {
        self.methodId = methodId
        self.endpoint = endpoint
    }
}


extension PaymentMethod: Equatable, Hashable {
    public static func ==(lhs: PaymentMethod, rhs: PaymentMethod) -> Bool {
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(methodId)
        hasher.combine(endpoint)
    }
}


public struct FfiConverterTypePaymentMethod: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMethod {
        return
            try PaymentMethod(
                methodId: FfiConverterString.read(from: &buf), 
                endpoint: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentMethod, into buf: inout [UInt8]) {
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.endpoint, into: &buf)
    }
}


public func FfiConverterTypePaymentMethod_lift(_ buf: RustBuffer) throws -> PaymentMethod {
    return try FfiConverterTypePaymentMethod.lift(buf)
}

public func FfiConverterTypePaymentMethod_lower(_ value: PaymentMethod) -> RustBuffer {
    return FfiConverterTypePaymentMethod.lower(value)
}


/**
 * Payment request.
 */
public struct PaymentRequest {
    public var requestId: String
    public var fromPubkey: String
    public var toPubkey: String
    public var amountSats: Int64
    public var currency: String
    public var methodId: String
    public var description: String
    public var createdAt: Int64
    public var expiresAt: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        requestId: String, 
        fromPubkey: String, 
        toPubkey: String, 
        amountSats: Int64, 
        currency: String, 
        methodId: String, 
        description: String, 
        createdAt: Int64, 
        expiresAt: Int64?) {
        self.requestId = requestId
        self.fromPubkey = fromPubkey
        self.toPubkey = toPubkey
        self.amountSats = amountSats
        self.currency = currency
        self.methodId = methodId
        self.description = description
        self.createdAt = createdAt
        self.expiresAt = expiresAt
    }
}


extension PaymentRequest: Equatable, Hashable {
    public static func ==(lhs: PaymentRequest, rhs: PaymentRequest) -> Bool {
        if lhs.requestId != rhs.requestId {
            return false
        }
        if lhs.fromPubkey != rhs.fromPubkey {
            return false
        }
        if lhs.toPubkey != rhs.toPubkey {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requestId)
        hasher.combine(fromPubkey)
        hasher.combine(toPubkey)
        hasher.combine(amountSats)
        hasher.combine(currency)
        hasher.combine(methodId)
        hasher.combine(description)
        hasher.combine(createdAt)
        hasher.combine(expiresAt)
    }
}


public struct FfiConverterTypePaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentRequest {
        return
            try PaymentRequest(
                requestId: FfiConverterString.read(from: &buf), 
                fromPubkey: FfiConverterString.read(from: &buf), 
                toPubkey: FfiConverterString.read(from: &buf), 
                amountSats: FfiConverterInt64.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                expiresAt: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.requestId, into: &buf)
        FfiConverterString.write(value.fromPubkey, into: &buf)
        FfiConverterString.write(value.toPubkey, into: &buf)
        FfiConverterInt64.write(value.amountSats, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterOptionInt64.write(value.expiresAt, into: &buf)
    }
}


public func FfiConverterTypePaymentRequest_lift(_ buf: RustBuffer) throws -> PaymentRequest {
    return try FfiConverterTypePaymentRequest.lift(buf)
}

public func FfiConverterTypePaymentRequest_lower(_ value: PaymentRequest) -> RustBuffer {
    return FfiConverterTypePaymentRequest.lower(value)
}


/**
 * Payment status information.
 */
public struct PaymentStatusInfo {
    public var status: PaymentStatus
    public var receiptId: String
    public var methodId: String
    public var updatedAt: Int64
    public var confirmations: UInt64?
    public var requiredConfirmations: UInt64?
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        status: PaymentStatus, 
        receiptId: String, 
        methodId: String, 
        updatedAt: Int64, 
        confirmations: UInt64?, 
        requiredConfirmations: UInt64?, 
        error: String?) {
        self.status = status
        self.receiptId = receiptId
        self.methodId = methodId
        self.updatedAt = updatedAt
        self.confirmations = confirmations
        self.requiredConfirmations = requiredConfirmations
        self.error = error
    }
}


extension PaymentStatusInfo: Equatable, Hashable {
    public static func ==(lhs: PaymentStatusInfo, rhs: PaymentStatusInfo) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.receiptId != rhs.receiptId {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.confirmations != rhs.confirmations {
            return false
        }
        if lhs.requiredConfirmations != rhs.requiredConfirmations {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(receiptId)
        hasher.combine(methodId)
        hasher.combine(updatedAt)
        hasher.combine(confirmations)
        hasher.combine(requiredConfirmations)
        hasher.combine(error)
    }
}


public struct FfiConverterTypePaymentStatusInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatusInfo {
        return
            try PaymentStatusInfo(
                status: FfiConverterTypePaymentStatus.read(from: &buf), 
                receiptId: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                updatedAt: FfiConverterInt64.read(from: &buf), 
                confirmations: FfiConverterOptionUInt64.read(from: &buf), 
                requiredConfirmations: FfiConverterOptionUInt64.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentStatusInfo, into buf: inout [UInt8]) {
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.receiptId, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterInt64.write(value.updatedAt, into: &buf)
        FfiConverterOptionUInt64.write(value.confirmations, into: &buf)
        FfiConverterOptionUInt64.write(value.requiredConfirmations, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


public func FfiConverterTypePaymentStatusInfo_lift(_ buf: RustBuffer) throws -> PaymentStatusInfo {
    return try FfiConverterTypePaymentStatusInfo.lift(buf)
}

public func FfiConverterTypePaymentStatusInfo_lower(_ value: PaymentStatusInfo) -> RustBuffer {
    return FfiConverterTypePaymentStatusInfo.lower(value)
}


/**
 * Private endpoint information.
 */
public struct PrivateEndpoint {
    public var peer: String
    public var methodId: String
    public var endpoint: String
    public var createdAt: Int64
    public var expiresAt: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        peer: String, 
        methodId: String, 
        endpoint: String, 
        createdAt: Int64, 
        expiresAt: Int64?) {
        self.peer = peer
        self.methodId = methodId
        self.endpoint = endpoint
        self.createdAt = createdAt
        self.expiresAt = expiresAt
    }
}


extension PrivateEndpoint: Equatable, Hashable {
    public static func ==(lhs: PrivateEndpoint, rhs: PrivateEndpoint) -> Bool {
        if lhs.peer != rhs.peer {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(peer)
        hasher.combine(methodId)
        hasher.combine(endpoint)
        hasher.combine(createdAt)
        hasher.combine(expiresAt)
    }
}


public struct FfiConverterTypePrivateEndpoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateEndpoint {
        return
            try PrivateEndpoint(
                peer: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                endpoint: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                expiresAt: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PrivateEndpoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.peer, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.endpoint, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterOptionInt64.write(value.expiresAt, into: &buf)
    }
}


public func FfiConverterTypePrivateEndpoint_lift(_ buf: RustBuffer) throws -> PrivateEndpoint {
    return try FfiConverterTypePrivateEndpoint.lift(buf)
}

public func FfiConverterTypePrivateEndpoint_lower(_ value: PrivateEndpoint) -> RustBuffer {
    return FfiConverterTypePrivateEndpoint.lower(value)
}


/**
 * FFI-safe private endpoint offer.
 */
public struct PrivateEndpointOffer {
    public var methodId: String
    public var endpoint: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        methodId: String, 
        endpoint: String) {
        self.methodId = methodId
        self.endpoint = endpoint
    }
}


extension PrivateEndpointOffer: Equatable, Hashable {
    public static func ==(lhs: PrivateEndpointOffer, rhs: PrivateEndpointOffer) -> Bool {
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(methodId)
        hasher.combine(endpoint)
    }
}


public struct FfiConverterTypePrivateEndpointOffer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateEndpointOffer {
        return
            try PrivateEndpointOffer(
                methodId: FfiConverterString.read(from: &buf), 
                endpoint: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PrivateEndpointOffer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.endpoint, into: &buf)
    }
}


public func FfiConverterTypePrivateEndpointOffer_lift(_ buf: RustBuffer) throws -> PrivateEndpointOffer {
    return try FfiConverterTypePrivateEndpointOffer.lift(buf)
}

public func FfiConverterTypePrivateEndpointOffer_lower(_ value: PrivateEndpointOffer) -> RustBuffer {
    return FfiConverterTypePrivateEndpointOffer.lower(value)
}


/**
 * Proration result.
 */
public struct ProrationResult {
    public var creditSats: Int64
    public var chargeSats: Int64
    public var netSats: Int64
    public var isRefund: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        creditSats: Int64, 
        chargeSats: Int64, 
        netSats: Int64, 
        isRefund: Bool) {
        self.creditSats = creditSats
        self.chargeSats = chargeSats
        self.netSats = netSats
        self.isRefund = isRefund
    }
}


extension ProrationResult: Equatable, Hashable {
    public static func ==(lhs: ProrationResult, rhs: ProrationResult) -> Bool {
        if lhs.creditSats != rhs.creditSats {
            return false
        }
        if lhs.chargeSats != rhs.chargeSats {
            return false
        }
        if lhs.netSats != rhs.netSats {
            return false
        }
        if lhs.isRefund != rhs.isRefund {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(creditSats)
        hasher.combine(chargeSats)
        hasher.combine(netSats)
        hasher.combine(isRefund)
    }
}


public struct FfiConverterTypeProrationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProrationResult {
        return
            try ProrationResult(
                creditSats: FfiConverterInt64.read(from: &buf), 
                chargeSats: FfiConverterInt64.read(from: &buf), 
                netSats: FfiConverterInt64.read(from: &buf), 
                isRefund: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ProrationResult, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.creditSats, into: &buf)
        FfiConverterInt64.write(value.chargeSats, into: &buf)
        FfiConverterInt64.write(value.netSats, into: &buf)
        FfiConverterBool.write(value.isRefund, into: &buf)
    }
}


public func FfiConverterTypeProrationResult_lift(_ buf: RustBuffer) throws -> ProrationResult {
    return try FfiConverterTypeProrationResult.lift(buf)
}

public func FfiConverterTypeProrationResult_lower(_ value: ProrationResult) -> RustBuffer {
    return FfiConverterTypeProrationResult.lower(value)
}


/**
 * Payment receipt.
 */
public struct Receipt {
    public var receiptId: String
    public var payer: String
    public var payee: String
    public var methodId: String
    public var amount: String?
    public var currency: String?
    public var createdAt: Int64
    public var metadataJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        receiptId: String, 
        payer: String, 
        payee: String, 
        methodId: String, 
        amount: String?, 
        currency: String?, 
        createdAt: Int64, 
        metadataJson: String) {
        self.receiptId = receiptId
        self.payer = payer
        self.payee = payee
        self.methodId = methodId
        self.amount = amount
        self.currency = currency
        self.createdAt = createdAt
        self.metadataJson = metadataJson
    }
}


extension Receipt: Equatable, Hashable {
    public static func ==(lhs: Receipt, rhs: Receipt) -> Bool {
        if lhs.receiptId != rhs.receiptId {
            return false
        }
        if lhs.payer != rhs.payer {
            return false
        }
        if lhs.payee != rhs.payee {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.metadataJson != rhs.metadataJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(receiptId)
        hasher.combine(payer)
        hasher.combine(payee)
        hasher.combine(methodId)
        hasher.combine(amount)
        hasher.combine(currency)
        hasher.combine(createdAt)
        hasher.combine(metadataJson)
    }
}


public struct FfiConverterTypeReceipt: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Receipt {
        return
            try Receipt(
                receiptId: FfiConverterString.read(from: &buf), 
                payer: FfiConverterString.read(from: &buf), 
                payee: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionString.read(from: &buf), 
                currency: FfiConverterOptionString.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                metadataJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Receipt, into buf: inout [UInt8]) {
        FfiConverterString.write(value.receiptId, into: &buf)
        FfiConverterString.write(value.payer, into: &buf)
        FfiConverterString.write(value.payee, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterOptionString.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.currency, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.metadataJson, into: &buf)
    }
}


public func FfiConverterTypeReceipt_lift(_ buf: RustBuffer) throws -> Receipt {
    return try FfiConverterTypeReceipt.lift(buf)
}

public func FfiConverterTypeReceipt_lower(_ value: Receipt) -> RustBuffer {
    return FfiConverterTypeReceipt.lower(value)
}


/**
 * Result type for receipt generation.
 *
 * Used to communicate success/failure from mobile callbacks.
 */
public struct ReceiptGenerationResult {
    /**
     * Whether generation succeeded
     */
    public var success: Bool
    /**
     * The generated receipt (if successful)
     */
    public var receipt: ReceiptRequest?
    /**
     * Error message (if failed)
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether generation succeeded
         */
        success: Bool, 
        /**
         * The generated receipt (if successful)
         */
        receipt: ReceiptRequest?, 
        /**
         * Error message (if failed)
         */
        error: String?) {
        self.success = success
        self.receipt = receipt
        self.error = error
    }
}


extension ReceiptGenerationResult: Equatable, Hashable {
    public static func ==(lhs: ReceiptGenerationResult, rhs: ReceiptGenerationResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.receipt != rhs.receipt {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(receipt)
        hasher.combine(error)
    }
}


public struct FfiConverterTypeReceiptGenerationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiptGenerationResult {
        return
            try ReceiptGenerationResult(
                success: FfiConverterBool.read(from: &buf), 
                receipt: FfiConverterOptionTypeReceiptRequest.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiptGenerationResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterOptionTypeReceiptRequest.write(value.receipt, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


public func FfiConverterTypeReceiptGenerationResult_lift(_ buf: RustBuffer) throws -> ReceiptGenerationResult {
    return try FfiConverterTypeReceiptGenerationResult.lift(buf)
}

public func FfiConverterTypeReceiptGenerationResult_lower(_ value: ReceiptGenerationResult) -> RustBuffer {
    return FfiConverterTypeReceiptGenerationResult.lower(value)
}


/**
 * FFI-safe receipt request.
 */
public struct ReceiptRequest {
    public var receiptId: String
    public var payer: String
    public var payee: String
    public var methodId: String
    public var amount: String?
    public var currency: String?
    public var metadataJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        receiptId: String, 
        payer: String, 
        payee: String, 
        methodId: String, 
        amount: String?, 
        currency: String?, 
        metadataJson: String) {
        self.receiptId = receiptId
        self.payer = payer
        self.payee = payee
        self.methodId = methodId
        self.amount = amount
        self.currency = currency
        self.metadataJson = metadataJson
    }
}


extension ReceiptRequest: Equatable, Hashable {
    public static func ==(lhs: ReceiptRequest, rhs: ReceiptRequest) -> Bool {
        if lhs.receiptId != rhs.receiptId {
            return false
        }
        if lhs.payer != rhs.payer {
            return false
        }
        if lhs.payee != rhs.payee {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.metadataJson != rhs.metadataJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(receiptId)
        hasher.combine(payer)
        hasher.combine(payee)
        hasher.combine(methodId)
        hasher.combine(amount)
        hasher.combine(currency)
        hasher.combine(metadataJson)
    }
}


public struct FfiConverterTypeReceiptRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiptRequest {
        return
            try ReceiptRequest(
                receiptId: FfiConverterString.read(from: &buf), 
                payer: FfiConverterString.read(from: &buf), 
                payee: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionString.read(from: &buf), 
                currency: FfiConverterOptionString.read(from: &buf), 
                metadataJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiptRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.receiptId, into: &buf)
        FfiConverterString.write(value.payer, into: &buf)
        FfiConverterString.write(value.payee, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterOptionString.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.currency, into: &buf)
        FfiConverterString.write(value.metadataJson, into: &buf)
    }
}


public func FfiConverterTypeReceiptRequest_lift(_ buf: RustBuffer) throws -> ReceiptRequest {
    return try FfiConverterTypeReceiptRequest.lift(buf)
}

public func FfiConverterTypeReceiptRequest_lower(_ value: ReceiptRequest) -> RustBuffer {
    return FfiConverterTypeReceiptRequest.lower(value)
}


/**
 * Result of scanning a QR code.
 */
public struct ScannedUri {
    /**
     * The type of URI that was scanned.
     */
    public var uriType: UriType
    /**
     * The public key if this is a Pubky URI.
     */
    public var publicKey: String?
    /**
     * The payment method if this is an Invoice URI.
     */
    public var methodId: String?
    /**
     * The invoice/endpoint data.
     */
    public var data: String?
    /**
     * The payment request ID if this is a PaymentRequest URI.
     */
    public var requestId: String?
    /**
     * The requester's public key if this is a PaymentRequest URI.
     */
    public var requester: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The type of URI that was scanned.
         */
        uriType: UriType, 
        /**
         * The public key if this is a Pubky URI.
         */
        publicKey: String?, 
        /**
         * The payment method if this is an Invoice URI.
         */
        methodId: String?, 
        /**
         * The invoice/endpoint data.
         */
        data: String?, 
        /**
         * The payment request ID if this is a PaymentRequest URI.
         */
        requestId: String?, 
        /**
         * The requester's public key if this is a PaymentRequest URI.
         */
        requester: String?) {
        self.uriType = uriType
        self.publicKey = publicKey
        self.methodId = methodId
        self.data = data
        self.requestId = requestId
        self.requester = requester
    }
}


extension ScannedUri: Equatable, Hashable {
    public static func ==(lhs: ScannedUri, rhs: ScannedUri) -> Bool {
        if lhs.uriType != rhs.uriType {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.requestId != rhs.requestId {
            return false
        }
        if lhs.requester != rhs.requester {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uriType)
        hasher.combine(publicKey)
        hasher.combine(methodId)
        hasher.combine(data)
        hasher.combine(requestId)
        hasher.combine(requester)
    }
}


public struct FfiConverterTypeScannedUri: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScannedUri {
        return
            try ScannedUri(
                uriType: FfiConverterTypeUriType.read(from: &buf), 
                publicKey: FfiConverterOptionString.read(from: &buf), 
                methodId: FfiConverterOptionString.read(from: &buf), 
                data: FfiConverterOptionString.read(from: &buf), 
                requestId: FfiConverterOptionString.read(from: &buf), 
                requester: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ScannedUri, into buf: inout [UInt8]) {
        FfiConverterTypeUriType.write(value.uriType, into: &buf)
        FfiConverterOptionString.write(value.publicKey, into: &buf)
        FfiConverterOptionString.write(value.methodId, into: &buf)
        FfiConverterOptionString.write(value.data, into: &buf)
        FfiConverterOptionString.write(value.requestId, into: &buf)
        FfiConverterOptionString.write(value.requester, into: &buf)
    }
}


public func FfiConverterTypeScannedUri_lift(_ buf: RustBuffer) throws -> ScannedUri {
    return try FfiConverterTypeScannedUri.lift(buf)
}

public func FfiConverterTypeScannedUri_lower(_ value: ScannedUri) -> RustBuffer {
    return FfiConverterTypeScannedUri.lower(value)
}


/**
 * Selection preferences.
 */
public struct SelectionPreferences {
    public var strategy: SelectionStrategy
    public var excludedMethods: [String]
    public var maxFeeSats: UInt64?
    public var maxConfirmationTimeSecs: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        strategy: SelectionStrategy, 
        excludedMethods: [String], 
        maxFeeSats: UInt64?, 
        maxConfirmationTimeSecs: UInt64?) {
        self.strategy = strategy
        self.excludedMethods = excludedMethods
        self.maxFeeSats = maxFeeSats
        self.maxConfirmationTimeSecs = maxConfirmationTimeSecs
    }
}


extension SelectionPreferences: Equatable, Hashable {
    public static func ==(lhs: SelectionPreferences, rhs: SelectionPreferences) -> Bool {
        if lhs.strategy != rhs.strategy {
            return false
        }
        if lhs.excludedMethods != rhs.excludedMethods {
            return false
        }
        if lhs.maxFeeSats != rhs.maxFeeSats {
            return false
        }
        if lhs.maxConfirmationTimeSecs != rhs.maxConfirmationTimeSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(strategy)
        hasher.combine(excludedMethods)
        hasher.combine(maxFeeSats)
        hasher.combine(maxConfirmationTimeSecs)
    }
}


public struct FfiConverterTypeSelectionPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectionPreferences {
        return
            try SelectionPreferences(
                strategy: FfiConverterTypeSelectionStrategy.read(from: &buf), 
                excludedMethods: FfiConverterSequenceString.read(from: &buf), 
                maxFeeSats: FfiConverterOptionUInt64.read(from: &buf), 
                maxConfirmationTimeSecs: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SelectionPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeSelectionStrategy.write(value.strategy, into: &buf)
        FfiConverterSequenceString.write(value.excludedMethods, into: &buf)
        FfiConverterOptionUInt64.write(value.maxFeeSats, into: &buf)
        FfiConverterOptionUInt64.write(value.maxConfirmationTimeSecs, into: &buf)
    }
}


public func FfiConverterTypeSelectionPreferences_lift(_ buf: RustBuffer) throws -> SelectionPreferences {
    return try FfiConverterTypeSelectionPreferences.lift(buf)
}

public func FfiConverterTypeSelectionPreferences_lower(_ value: SelectionPreferences) -> RustBuffer {
    return FfiConverterTypeSelectionPreferences.lower(value)
}


/**
 * Result of payment method selection.
 */
public struct SelectionResult {
    public var primaryMethod: String
    public var fallbackMethods: [String]
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        primaryMethod: String, 
        fallbackMethods: [String], 
        reason: String) {
        self.primaryMethod = primaryMethod
        self.fallbackMethods = fallbackMethods
        self.reason = reason
    }
}


extension SelectionResult: Equatable, Hashable {
    public static func ==(lhs: SelectionResult, rhs: SelectionResult) -> Bool {
        if lhs.primaryMethod != rhs.primaryMethod {
            return false
        }
        if lhs.fallbackMethods != rhs.fallbackMethods {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryMethod)
        hasher.combine(fallbackMethods)
        hasher.combine(reason)
    }
}


public struct FfiConverterTypeSelectionResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectionResult {
        return
            try SelectionResult(
                primaryMethod: FfiConverterString.read(from: &buf), 
                fallbackMethods: FfiConverterSequenceString.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SelectionResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.primaryMethod, into: &buf)
        FfiConverterSequenceString.write(value.fallbackMethods, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
    }
}


public func FfiConverterTypeSelectionResult_lift(_ buf: RustBuffer) throws -> SelectionResult {
    return try FfiConverterTypeSelectionResult.lift(buf)
}

public func FfiConverterTypeSelectionResult_lower(_ value: SelectionResult) -> RustBuffer {
    return FfiConverterTypeSelectionResult.lower(value)
}


/**
 * Result type for storage get operations.
 */
public struct StorageGetResult {
    /**
     * Whether the operation succeeded
     */
    public var success: Bool
    /**
     * The content if found (None if not found but successful)
     */
    public var content: String?
    /**
     * Error message if failed
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the operation succeeded
         */
        success: Bool, 
        /**
         * The content if found (None if not found but successful)
         */
        content: String?, 
        /**
         * Error message if failed
         */
        error: String?) {
        self.success = success
        self.content = content
        self.error = error
    }
}


extension StorageGetResult: Equatable, Hashable {
    public static func ==(lhs: StorageGetResult, rhs: StorageGetResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(content)
        hasher.combine(error)
    }
}


public struct FfiConverterTypeStorageGetResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageGetResult {
        return
            try StorageGetResult(
                success: FfiConverterBool.read(from: &buf), 
                content: FfiConverterOptionString.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StorageGetResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterOptionString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


public func FfiConverterTypeStorageGetResult_lift(_ buf: RustBuffer) throws -> StorageGetResult {
    return try FfiConverterTypeStorageGetResult.lift(buf)
}

public func FfiConverterTypeStorageGetResult_lower(_ value: StorageGetResult) -> RustBuffer {
    return FfiConverterTypeStorageGetResult.lower(value)
}


/**
 * Result type for storage list operations.
 */
public struct StorageListResult {
    /**
     * Whether the operation succeeded
     */
    public var success: Bool
    /**
     * List of file names/paths
     */
    public var entries: [String]
    /**
     * Error message if failed
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the operation succeeded
         */
        success: Bool, 
        /**
         * List of file names/paths
         */
        entries: [String], 
        /**
         * Error message if failed
         */
        error: String?) {
        self.success = success
        self.entries = entries
        self.error = error
    }
}


extension StorageListResult: Equatable, Hashable {
    public static func ==(lhs: StorageListResult, rhs: StorageListResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.entries != rhs.entries {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(entries)
        hasher.combine(error)
    }
}


public struct FfiConverterTypeStorageListResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageListResult {
        return
            try StorageListResult(
                success: FfiConverterBool.read(from: &buf), 
                entries: FfiConverterSequenceString.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StorageListResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterSequenceString.write(value.entries, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


public func FfiConverterTypeStorageListResult_lift(_ buf: RustBuffer) throws -> StorageListResult {
    return try FfiConverterTypeStorageListResult.lift(buf)
}

public func FfiConverterTypeStorageListResult_lower(_ value: StorageListResult) -> RustBuffer {
    return FfiConverterTypeStorageListResult.lower(value)
}


/**
 * Result type for storage operations.
 */
public struct StorageOperationResult {
    /**
     * Whether the operation succeeded
     */
    public var success: Bool
    /**
     * Error message if failed
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the operation succeeded
         */
        success: Bool, 
        /**
         * Error message if failed
         */
        error: String?) {
        self.success = success
        self.error = error
    }
}


extension StorageOperationResult: Equatable, Hashable {
    public static func ==(lhs: StorageOperationResult, rhs: StorageOperationResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(error)
    }
}


public struct FfiConverterTypeStorageOperationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageOperationResult {
        return
            try StorageOperationResult(
                success: FfiConverterBool.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StorageOperationResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


public func FfiConverterTypeStorageOperationResult_lift(_ buf: RustBuffer) throws -> StorageOperationResult {
    return try FfiConverterTypeStorageOperationResult.lift(buf)
}

public func FfiConverterTypeStorageOperationResult_lower(_ value: StorageOperationResult) -> RustBuffer {
    return FfiConverterTypeStorageOperationResult.lower(value)
}


/**
 * Subscription information.
 */
public struct Subscription {
    public var subscriptionId: String
    public var subscriber: String
    public var provider: String
    public var terms: SubscriptionTerms
    public var createdAt: Int64
    public var startsAt: Int64
    public var endsAt: Int64?
    public var isActive: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        subscriptionId: String, 
        subscriber: String, 
        provider: String, 
        terms: SubscriptionTerms, 
        createdAt: Int64, 
        startsAt: Int64, 
        endsAt: Int64?, 
        isActive: Bool) {
        self.subscriptionId = subscriptionId
        self.subscriber = subscriber
        self.provider = provider
        self.terms = terms
        self.createdAt = createdAt
        self.startsAt = startsAt
        self.endsAt = endsAt
        self.isActive = isActive
    }
}


extension Subscription: Equatable, Hashable {
    public static func ==(lhs: Subscription, rhs: Subscription) -> Bool {
        if lhs.subscriptionId != rhs.subscriptionId {
            return false
        }
        if lhs.subscriber != rhs.subscriber {
            return false
        }
        if lhs.provider != rhs.provider {
            return false
        }
        if lhs.terms != rhs.terms {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.startsAt != rhs.startsAt {
            return false
        }
        if lhs.endsAt != rhs.endsAt {
            return false
        }
        if lhs.isActive != rhs.isActive {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(subscriptionId)
        hasher.combine(subscriber)
        hasher.combine(provider)
        hasher.combine(terms)
        hasher.combine(createdAt)
        hasher.combine(startsAt)
        hasher.combine(endsAt)
        hasher.combine(isActive)
    }
}


public struct FfiConverterTypeSubscription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Subscription {
        return
            try Subscription(
                subscriptionId: FfiConverterString.read(from: &buf), 
                subscriber: FfiConverterString.read(from: &buf), 
                provider: FfiConverterString.read(from: &buf), 
                terms: FfiConverterTypeSubscriptionTerms.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                startsAt: FfiConverterInt64.read(from: &buf), 
                endsAt: FfiConverterOptionInt64.read(from: &buf), 
                isActive: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Subscription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.subscriptionId, into: &buf)
        FfiConverterString.write(value.subscriber, into: &buf)
        FfiConverterString.write(value.provider, into: &buf)
        FfiConverterTypeSubscriptionTerms.write(value.terms, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterInt64.write(value.startsAt, into: &buf)
        FfiConverterOptionInt64.write(value.endsAt, into: &buf)
        FfiConverterBool.write(value.isActive, into: &buf)
    }
}


public func FfiConverterTypeSubscription_lift(_ buf: RustBuffer) throws -> Subscription {
    return try FfiConverterTypeSubscription.lift(buf)
}

public func FfiConverterTypeSubscription_lower(_ value: Subscription) -> RustBuffer {
    return FfiConverterTypeSubscription.lower(value)
}


/**
 * Subscription terms.
 */
public struct SubscriptionTerms {
    public var amountSats: Int64
    public var currency: String
    public var frequency: PaymentFrequency
    public var methodId: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        amountSats: Int64, 
        currency: String, 
        frequency: PaymentFrequency, 
        methodId: String, 
        description: String) {
        self.amountSats = amountSats
        self.currency = currency
        self.frequency = frequency
        self.methodId = methodId
        self.description = description
    }
}


extension SubscriptionTerms: Equatable, Hashable {
    public static func ==(lhs: SubscriptionTerms, rhs: SubscriptionTerms) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.frequency != rhs.frequency {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(currency)
        hasher.combine(frequency)
        hasher.combine(methodId)
        hasher.combine(description)
    }
}


public struct FfiConverterTypeSubscriptionTerms: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscriptionTerms {
        return
            try SubscriptionTerms(
                amountSats: FfiConverterInt64.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                frequency: FfiConverterTypePaymentFrequency.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SubscriptionTerms, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.amountSats, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterTypePaymentFrequency.write(value.frequency, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


public func FfiConverterTypeSubscriptionTerms_lift(_ buf: RustBuffer) throws -> SubscriptionTerms {
    return try FfiConverterTypeSubscriptionTerms.lift(buf)
}

public func FfiConverterTypeSubscriptionTerms_lower(_ value: SubscriptionTerms) -> RustBuffer {
    return FfiConverterTypeSubscriptionTerms.lower(value)
}


/**
 * FFI-safe sync result.
 */
public struct SyncResultFfi {
    public var total: UInt32
    public var added: UInt32
    public var removed: UInt32
    public var syncedAt: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        total: UInt32, 
        added: UInt32, 
        removed: UInt32, 
        syncedAt: Int64) {
        self.total = total
        self.added = added
        self.removed = removed
        self.syncedAt = syncedAt
    }
}


extension SyncResultFfi: Equatable, Hashable {
    public static func ==(lhs: SyncResultFfi, rhs: SyncResultFfi) -> Bool {
        if lhs.total != rhs.total {
            return false
        }
        if lhs.added != rhs.added {
            return false
        }
        if lhs.removed != rhs.removed {
            return false
        }
        if lhs.syncedAt != rhs.syncedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(total)
        hasher.combine(added)
        hasher.combine(removed)
        hasher.combine(syncedAt)
    }
}


public struct FfiConverterTypeSyncResultFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncResultFfi {
        return
            try SyncResultFfi(
                total: FfiConverterUInt32.read(from: &buf), 
                added: FfiConverterUInt32.read(from: &buf), 
                removed: FfiConverterUInt32.read(from: &buf), 
                syncedAt: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SyncResultFfi, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.total, into: &buf)
        FfiConverterUInt32.write(value.added, into: &buf)
        FfiConverterUInt32.write(value.removed, into: &buf)
        FfiConverterInt64.write(value.syncedAt, into: &buf)
    }
}


public func FfiConverterTypeSyncResultFFI_lift(_ buf: RustBuffer) throws -> SyncResultFfi {
    return try FfiConverterTypeSyncResultFFI.lift(buf)
}

public func FfiConverterTypeSyncResultFFI_lower(_ value: SyncResultFfi) -> RustBuffer {
    return FfiConverterTypeSyncResultFFI.lower(value)
}


/**
 * Derived X25519 keypair for Noise protocol.
 */
public struct X25519Keypair {
    /**
     * Secret key - 32 bytes, hex encoded.
     */
    public var secretKeyHex: String
    /**
     * Public key - 32 bytes, hex encoded.
     */
    public var publicKeyHex: String
    /**
     * Device ID used for derivation.
     */
    public var deviceId: String
    /**
     * Epoch used for derivation.
     */
    public var epoch: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Secret key - 32 bytes, hex encoded.
         */
        secretKeyHex: String, 
        /**
         * Public key - 32 bytes, hex encoded.
         */
        publicKeyHex: String, 
        /**
         * Device ID used for derivation.
         */
        deviceId: String, 
        /**
         * Epoch used for derivation.
         */
        epoch: UInt32) {
        self.secretKeyHex = secretKeyHex
        self.publicKeyHex = publicKeyHex
        self.deviceId = deviceId
        self.epoch = epoch
    }
}


extension X25519Keypair: Equatable, Hashable {
    public static func ==(lhs: X25519Keypair, rhs: X25519Keypair) -> Bool {
        if lhs.secretKeyHex != rhs.secretKeyHex {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.epoch != rhs.epoch {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretKeyHex)
        hasher.combine(publicKeyHex)
        hasher.combine(deviceId)
        hasher.combine(epoch)
    }
}


public struct FfiConverterTypeX25519Keypair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> X25519Keypair {
        return
            try X25519Keypair(
                secretKeyHex: FfiConverterString.read(from: &buf), 
                publicKeyHex: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                epoch: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: X25519Keypair, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretKeyHex, into: &buf)
        FfiConverterString.write(value.publicKeyHex, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterUInt32.write(value.epoch, into: &buf)
    }
}


public func FfiConverterTypeX25519Keypair_lift(_ buf: RustBuffer) throws -> X25519Keypair {
    return try FfiConverterTypeX25519Keypair.lift(buf)
}

public func FfiConverterTypeX25519Keypair_lower(_ value: X25519Keypair) -> RustBuffer {
    return FfiConverterTypeX25519Keypair.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Health status of a payment method.
 */
public enum HealthStatus {
    
    case healthy
    case degraded
    case unavailable
    case unknown
}

public struct FfiConverterTypeHealthStatus: FfiConverterRustBuffer {
    typealias SwiftType = HealthStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HealthStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .healthy
        
        case 2: return .degraded
        
        case 3: return .unavailable
        
        case 4: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HealthStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .healthy:
            writeInt(&buf, Int32(1))
        
        
        case .degraded:
            writeInt(&buf, Int32(2))
        
        
        case .unavailable:
            writeInt(&buf, Int32(3))
        
        
        case .unknown:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeHealthStatus_lift(_ buf: RustBuffer) throws -> HealthStatus {
    return try FfiConverterTypeHealthStatus.lift(buf)
}

public func FfiConverterTypeHealthStatus_lower(_ value: HealthStatus) -> RustBuffer {
    return FfiConverterTypeHealthStatus.lower(value)
}


extension HealthStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Modification type for subscriptions.
 */
public enum ModificationType {
    
    case upgrade(
        newAmountSats: Int64, 
        effectiveDate: Int64
    )
    case downgrade(
        newAmountSats: Int64, 
        effectiveDate: Int64
    )
    case changeMethod(
        newMethodId: String
    )
    case changeBillingDate(
        newDay: UInt8
    )
    case cancel(
        effectiveDate: Int64, 
        reason: String?
    )
    case pause(
        resumeDate: Int64
    )
    case resume
}

public struct FfiConverterTypeModificationType: FfiConverterRustBuffer {
    typealias SwiftType = ModificationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModificationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .upgrade(
            newAmountSats: try FfiConverterInt64.read(from: &buf), 
            effectiveDate: try FfiConverterInt64.read(from: &buf)
        )
        
        case 2: return .downgrade(
            newAmountSats: try FfiConverterInt64.read(from: &buf), 
            effectiveDate: try FfiConverterInt64.read(from: &buf)
        )
        
        case 3: return .changeMethod(
            newMethodId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .changeBillingDate(
            newDay: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 5: return .cancel(
            effectiveDate: try FfiConverterInt64.read(from: &buf), 
            reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .pause(
            resumeDate: try FfiConverterInt64.read(from: &buf)
        )
        
        case 7: return .resume
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModificationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .upgrade(newAmountSats,effectiveDate):
            writeInt(&buf, Int32(1))
            FfiConverterInt64.write(newAmountSats, into: &buf)
            FfiConverterInt64.write(effectiveDate, into: &buf)
            
        
        case let .downgrade(newAmountSats,effectiveDate):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(newAmountSats, into: &buf)
            FfiConverterInt64.write(effectiveDate, into: &buf)
            
        
        case let .changeMethod(newMethodId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(newMethodId, into: &buf)
            
        
        case let .changeBillingDate(newDay):
            writeInt(&buf, Int32(4))
            FfiConverterUInt8.write(newDay, into: &buf)
            
        
        case let .cancel(effectiveDate,reason):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(effectiveDate, into: &buf)
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .pause(resumeDate):
            writeInt(&buf, Int32(6))
            FfiConverterInt64.write(resumeDate, into: &buf)
            
        
        case .resume:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeModificationType_lift(_ buf: RustBuffer) throws -> ModificationType {
    return try FfiConverterTypeModificationType.lift(buf)
}

public func FfiConverterTypeModificationType_lower(_ value: ModificationType) -> RustBuffer {
    return FfiConverterTypeModificationType.lower(value)
}


extension ModificationType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Parsed Paykit message.
 */
public enum ParsedMessage {
    
    case offerPrivateEndpoint(
        offer: PrivateEndpointOffer
    )
    case requestReceipt(
        request: ReceiptRequest
    )
    case confirmReceipt(
        receipt: ReceiptRequest
    )
    case ack
    case error(
        error: ErrorMessage
    )
}

public struct FfiConverterTypeParsedMessage: FfiConverterRustBuffer {
    typealias SwiftType = ParsedMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .offerPrivateEndpoint(
            offer: try FfiConverterTypePrivateEndpointOffer.read(from: &buf)
        )
        
        case 2: return .requestReceipt(
            request: try FfiConverterTypeReceiptRequest.read(from: &buf)
        )
        
        case 3: return .confirmReceipt(
            receipt: try FfiConverterTypeReceiptRequest.read(from: &buf)
        )
        
        case 4: return .ack
        
        case 5: return .error(
            error: try FfiConverterTypeErrorMessage.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParsedMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .offerPrivateEndpoint(offer):
            writeInt(&buf, Int32(1))
            FfiConverterTypePrivateEndpointOffer.write(offer, into: &buf)
            
        
        case let .requestReceipt(request):
            writeInt(&buf, Int32(2))
            FfiConverterTypeReceiptRequest.write(request, into: &buf)
            
        
        case let .confirmReceipt(receipt):
            writeInt(&buf, Int32(3))
            FfiConverterTypeReceiptRequest.write(receipt, into: &buf)
            
        
        case .ack:
            writeInt(&buf, Int32(4))
        
        
        case let .error(error):
            writeInt(&buf, Int32(5))
            FfiConverterTypeErrorMessage.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeParsedMessage_lift(_ buf: RustBuffer) throws -> ParsedMessage {
    return try FfiConverterTypeParsedMessage.lift(buf)
}

public func FfiConverterTypeParsedMessage_lower(_ value: ParsedMessage) -> RustBuffer {
    return FfiConverterTypeParsedMessage.lower(value)
}


extension ParsedMessage: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe Paykit message type.
 */
public enum PaykitMessageType {
    
    /**
     * Offer a private endpoint.
     */
    case offerPrivateEndpoint
    /**
     * Request a receipt.
     */
    case requestReceipt
    /**
     * Confirm a receipt.
     */
    case confirmReceipt
    /**
     * Acknowledgment.
     */
    case ack
    /**
     * Error message.
     */
    case error
}

public struct FfiConverterTypePaykitMessageType: FfiConverterRustBuffer {
    typealias SwiftType = PaykitMessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitMessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .offerPrivateEndpoint
        
        case 2: return .requestReceipt
        
        case 3: return .confirmReceipt
        
        case 4: return .ack
        
        case 5: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaykitMessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .offerPrivateEndpoint:
            writeInt(&buf, Int32(1))
        
        
        case .requestReceipt:
            writeInt(&buf, Int32(2))
        
        
        case .confirmReceipt:
            writeInt(&buf, Int32(3))
        
        
        case .ack:
            writeInt(&buf, Int32(4))
        
        
        case .error:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypePaykitMessageType_lift(_ buf: RustBuffer) throws -> PaykitMessageType {
    return try FfiConverterTypePaykitMessageType.lift(buf)
}

public func FfiConverterTypePaykitMessageType_lower(_ value: PaykitMessageType) -> RustBuffer {
    return FfiConverterTypePaykitMessageType.lower(value)
}


extension PaykitMessageType: Equatable, Hashable {}




/**
 * Mobile-friendly error type.
 */
public enum PaykitMobileError {

    
    
    /**
     * Transport layer error (network, I/O).
     */
    case Transport(
        message: String
    )
    /**
     * Validation error (invalid input, format).
     */
    case Validation(
        message: String
    )
    /**
     * Resource not found.
     */
    case NotFound(
        message: String
    )
    /**
     * Serialization/deserialization error.
     */
    case Serialization(
        message: String
    )
    /**
     * Internal error (unexpected state).
     */
    case Internal(
        message: String
    )
    /**
     * Network timeout error.
     */
    case NetworkTimeout(
        message: String
    )
    /**
     * Connection refused or failed.
     */
    case ConnectionError(
        message: String
    )
    /**
     * Authentication failed.
     */
    case AuthenticationError(
        message: String
    )
    /**
     * Session expired or invalid.
     */
    case SessionError(
        message: String
    )
    /**
     * Rate limit exceeded.
     */
    case RateLimitError(
        message: String
    )
    /**
     * Permission denied.
     */
    case PermissionDenied(
        message: String
    )

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypePaykitMobileError.lift(error)
    }
}


public struct FfiConverterTypePaykitMobileError: FfiConverterRustBuffer {
    typealias SwiftType = PaykitMobileError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitMobileError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Transport(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Validation(
            message: try FfiConverterString.read(from: &buf)
            )
        case 3: return .NotFound(
            message: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Serialization(
            message: try FfiConverterString.read(from: &buf)
            )
        case 5: return .Internal(
            message: try FfiConverterString.read(from: &buf)
            )
        case 6: return .NetworkTimeout(
            message: try FfiConverterString.read(from: &buf)
            )
        case 7: return .ConnectionError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 8: return .AuthenticationError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 9: return .SessionError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 10: return .RateLimitError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 11: return .PermissionDenied(
            message: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaykitMobileError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Transport(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Validation(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .NotFound(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Serialization(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Internal(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .NetworkTimeout(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .ConnectionError(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .AuthenticationError(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .SessionError(message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .RateLimitError(message):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .PermissionDenied(message):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


extension PaykitMobileError: Equatable, Hashable {}

extension PaykitMobileError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Payment frequency for subscriptions.
 */
public enum PaymentFrequency {
    
    case daily
    case weekly
    case monthly(
        dayOfMonth: UInt8
    )
    case yearly(
        month: UInt8, 
        day: UInt8
    )
    case custom(
        intervalSeconds: UInt64
    )
}

public struct FfiConverterTypePaymentFrequency: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFrequency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFrequency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .daily
        
        case 2: return .weekly
        
        case 3: return .monthly(
            dayOfMonth: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 4: return .yearly(
            month: try FfiConverterUInt8.read(from: &buf), 
            day: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 5: return .custom(
            intervalSeconds: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentFrequency, into buf: inout [UInt8]) {
        switch value {
        
        
        case .daily:
            writeInt(&buf, Int32(1))
        
        
        case .weekly:
            writeInt(&buf, Int32(2))
        
        
        case let .monthly(dayOfMonth):
            writeInt(&buf, Int32(3))
            FfiConverterUInt8.write(dayOfMonth, into: &buf)
            
        
        case let .yearly(month,day):
            writeInt(&buf, Int32(4))
            FfiConverterUInt8.write(month, into: &buf)
            FfiConverterUInt8.write(day, into: &buf)
            
        
        case let .custom(intervalSeconds):
            writeInt(&buf, Int32(5))
            FfiConverterUInt64.write(intervalSeconds, into: &buf)
            
        }
    }
}


public func FfiConverterTypePaymentFrequency_lift(_ buf: RustBuffer) throws -> PaymentFrequency {
    return try FfiConverterTypePaymentFrequency.lift(buf)
}

public func FfiConverterTypePaymentFrequency_lower(_ value: PaymentFrequency) -> RustBuffer {
    return FfiConverterTypePaymentFrequency.lower(value)
}


extension PaymentFrequency: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Payment status.
 */
public enum PaymentStatus {
    
    case pending
    case processing
    case confirmed
    case finalized
    case failed
    case cancelled
    case expired
}

public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .processing
        
        case 3: return .confirmed
        
        case 4: return .finalized
        
        case 5: return .failed
        
        case 6: return .cancelled
        
        case 7: return .expired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .processing:
            writeInt(&buf, Int32(2))
        
        
        case .confirmed:
            writeInt(&buf, Int32(3))
        
        
        case .finalized:
            writeInt(&buf, Int32(4))
        
        
        case .failed:
            writeInt(&buf, Int32(5))
        
        
        case .cancelled:
            writeInt(&buf, Int32(6))
        
        
        case .expired:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}


extension PaymentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Payment request status.
 */
public enum RequestStatus {
    
    case pending
    case accepted
    case declined
    case expired
    case paid
}

public struct FfiConverterTypeRequestStatus: FfiConverterRustBuffer {
    typealias SwiftType = RequestStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .accepted
        
        case 3: return .declined
        
        case 4: return .expired
        
        case 5: return .paid
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .accepted:
            writeInt(&buf, Int32(2))
        
        
        case .declined:
            writeInt(&buf, Int32(3))
        
        
        case .expired:
            writeInt(&buf, Int32(4))
        
        
        case .paid:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeRequestStatus_lift(_ buf: RustBuffer) throws -> RequestStatus {
    return try FfiConverterTypeRequestStatus.lift(buf)
}

public func FfiConverterTypeRequestStatus_lower(_ value: RequestStatus) -> RustBuffer {
    return FfiConverterTypeRequestStatus.lower(value)
}


extension RequestStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Selection strategy.
 */
public enum SelectionStrategy {
    
    case balanced
    case costOptimized
    case speedOptimized
    case privacyOptimized
}

public struct FfiConverterTypeSelectionStrategy: FfiConverterRustBuffer {
    typealias SwiftType = SelectionStrategy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectionStrategy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .balanced
        
        case 2: return .costOptimized
        
        case 3: return .speedOptimized
        
        case 4: return .privacyOptimized
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SelectionStrategy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .balanced:
            writeInt(&buf, Int32(1))
        
        
        case .costOptimized:
            writeInt(&buf, Int32(2))
        
        
        case .speedOptimized:
            writeInt(&buf, Int32(3))
        
        
        case .privacyOptimized:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSelectionStrategy_lift(_ buf: RustBuffer) throws -> SelectionStrategy {
    return try FfiConverterTypeSelectionStrategy.lift(buf)
}

public func FfiConverterTypeSelectionStrategy_lower(_ value: SelectionStrategy) -> RustBuffer {
    return FfiConverterTypeSelectionStrategy.lower(value)
}


extension SelectionStrategy: Equatable, Hashable {}




/**
 * FFI-safe storage error type.
 */
public enum StorageCacheError {

    
    
    case Storage(
        message: String
    )
    case Lock(
        message: String
    )

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeStorageCacheError.lift(error)
    }
}


public struct FfiConverterTypeStorageCacheError: FfiConverterRustBuffer {
    typealias SwiftType = StorageCacheError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageCacheError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Storage(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Lock(
            message: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageCacheError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Storage(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Lock(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


extension StorageCacheError: Equatable, Hashable {}

extension StorageCacheError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Type of scanned URI.
 */
public enum UriType {
    
    /**
     * A Pubky public key URI.
     */
    case pubky
    /**
     * An invoice URI (Lightning, Bitcoin, etc.).
     */
    case invoice
    /**
     * A payment request URI.
     */
    case paymentRequest
    /**
     * Unknown or invalid format.
     */
    case unknown
}

public struct FfiConverterTypeUriType: FfiConverterRustBuffer {
    typealias SwiftType = UriType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UriType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pubky
        
        case 2: return .invoice
        
        case 3: return .paymentRequest
        
        case 4: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UriType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pubky:
            writeInt(&buf, Int32(1))
        
        
        case .invoice:
            writeInt(&buf, Int32(2))
        
        
        case .paymentRequest:
            writeInt(&buf, Int32(3))
        
        
        case .unknown:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeUriType_lift(_ buf: RustBuffer) throws -> UriType {
    return try FfiConverterTypeUriType.lift(buf)
}

public func FfiConverterTypeUriType_lower(_ value: UriType) -> RustBuffer {
    return FfiConverterTypeUriType.lower(value)
}


extension UriType: Equatable, Hashable {}






/**
 * Callback interface for authenticated Pubky storage operations.
 *
 * Mobile apps implement this to wrap their Pubky SDK session.
 * All operations are performed on the owner's storage.
 *
 * # Thread Safety
 *
 * Implementations must be thread-safe (Send + Sync).
 */
public protocol PubkyAuthenticatedStorageCallback : AnyObject {
    
    /**
     * Put (create or update) content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path (e.g., "/pub/paykit.app/v0/lightning")
     * * `content` - Content to store
     */
    func put(path: String, content: String)  -> StorageOperationResult
    
    /**
     * Get content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path to read
     *
     * # Returns
     *
     * Content if found, None if path doesn't exist.
     */
    func get(path: String)  -> StorageGetResult
    
    /**
     * Delete content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path to delete
     */
    func delete(path: String)  -> StorageOperationResult
    
    /**
     * List files with the given prefix.
     *
     * # Arguments
     *
     * * `prefix` - Path prefix to list (e.g., "/pub/paykit.app/v0/")
     */
    func list(prefix: String)  -> StorageListResult
    
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 1
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for PubkyAuthenticatedStorageCallback Callback Interface

fileprivate let uniffiCallbackHandlerPubkyAuthenticatedStorageCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokePut(_ swiftCallbackInterface: PubkyAuthenticatedStorageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.put(
                    path:  try FfiConverterString.read(from: &reader), 
                    content:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeStorageOperationResult.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeGet(_ swiftCallbackInterface: PubkyAuthenticatedStorageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.get(
                    path:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeStorageGetResult.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeDelete(_ swiftCallbackInterface: PubkyAuthenticatedStorageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.delete(
                    path:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeStorageOperationResult.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeList(_ swiftCallbackInterface: PubkyAuthenticatedStorageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.list(
                    prefix:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeStorageListResult.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.remove(handle: handle)
            // Successful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            guard let cb = FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.get(handle: handle) else {
                out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokePut(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            guard let cb = FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.get(handle: handle) else {
                out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeGet(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            guard let cb = FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.get(handle: handle) else {
                out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDelete(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            guard let cb = FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.get(handle: handle) else {
                out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeList(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

private func uniffiCallbackInitPubkyAuthenticatedStorageCallback() {
    uniffi_paykit_mobile_fn_init_callback_pubkyauthenticatedstoragecallback(uniffiCallbackHandlerPubkyAuthenticatedStorageCallback)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback {
    fileprivate static var handleMap = UniFFICallbackHandleMap<PubkyAuthenticatedStorageCallback>()
}

extension FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback : FfiConverter {
    typealias SwiftType = PubkyAuthenticatedStorageCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * Callback interface for unauthenticated (read-only) Pubky storage operations.
 *
 * Mobile apps implement this to wrap their Pubky SDK public storage.
 *
 * # Thread Safety
 *
 * Implementations must be thread-safe (Send + Sync).
 */
public protocol PubkyUnauthenticatedStorageCallback : AnyObject {
    
    /**
     * Get content at the given path from another user's public storage.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     * * `path` - Storage path to read
     */
    func get(ownerPubkey: String, path: String)  -> StorageGetResult
    
    /**
     * List files with the given prefix from another user's public storage.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     * * `prefix` - Path prefix to list
     */
    func list(ownerPubkey: String, prefix: String)  -> StorageListResult
    
}



// Declaration and FfiConverters for PubkyUnauthenticatedStorageCallback Callback Interface

fileprivate let uniffiCallbackHandlerPubkyUnauthenticatedStorageCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeGet(_ swiftCallbackInterface: PubkyUnauthenticatedStorageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.get(
                    ownerPubkey:  try FfiConverterString.read(from: &reader), 
                    path:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeStorageGetResult.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeList(_ swiftCallbackInterface: PubkyUnauthenticatedStorageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.list(
                    ownerPubkey:  try FfiConverterString.read(from: &reader), 
                    prefix:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeStorageListResult.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.handleMap.remove(handle: handle)
            // Successful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            guard let cb = FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.handleMap.get(handle: handle) else {
                out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeGet(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            guard let cb = FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.handleMap.get(handle: handle) else {
                out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeList(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

private func uniffiCallbackInitPubkyUnauthenticatedStorageCallback() {
    uniffi_paykit_mobile_fn_init_callback_pubkyunauthenticatedstoragecallback(uniffiCallbackHandlerPubkyUnauthenticatedStorageCallback)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback {
    fileprivate static var handleMap = UniFFICallbackHandleMap<PubkyUnauthenticatedStorageCallback>()
}

extension FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback : FfiConverter {
    typealias SwiftType = PubkyUnauthenticatedStorageCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * Callback interface for mobile receipt generation.
 *
 * Mobile apps implement this to generate receipts (e.g., create Lightning invoices).
 * When a payment request is received, this callback is invoked to produce
 * the final receipt with payment endpoint.
 *
 * # Example (Swift)
 *
 * ```swift
 * class MyReceiptGenerator: ReceiptGeneratorCallback {
 * func generateReceipt(request: ReceiptRequest) -> ReceiptGenerationResult {
 * // Create Lightning invoice
 * let invoice = createInvoice(amount: request.amount)
 *
 * // Update receipt with invoice in metadata
 * var receipt = request
 * receipt.metadataJson = "{\"invoice\":\"\(invoice)\"}"
 *
 * return ReceiptGenerationResult.ok(receipt: receipt)
 * }
 * }
 * ```
 */
public protocol ReceiptGeneratorCallback : AnyObject {
    
    /**
     * Generate a receipt for a payment request.
     *
     * # Arguments
     *
     * * `request` - The provisional receipt request from the payer
     *
     * # Returns
     *
     * A `ReceiptGenerationResult` with either the finalized receipt or an error.
     */
    func generateReceipt(request: ReceiptRequest)  -> ReceiptGenerationResult
    
}



// Declaration and FfiConverters for ReceiptGeneratorCallback Callback Interface

fileprivate let uniffiCallbackHandlerReceiptGeneratorCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeGenerateReceipt(_ swiftCallbackInterface: ReceiptGeneratorCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.generateReceipt(
                    request:  try FfiConverterTypeReceiptRequest.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeReceiptGenerationResult.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceReceiptGeneratorCallback.handleMap.remove(handle: handle)
            // Successful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            guard let cb = FfiConverterCallbackInterfaceReceiptGeneratorCallback.handleMap.get(handle: handle) else {
                out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeGenerateReceipt(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

private func uniffiCallbackInitReceiptGeneratorCallback() {
    uniffi_paykit_mobile_fn_init_callback_receiptgeneratorcallback(uniffiCallbackHandlerReceiptGeneratorCallback)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceReceiptGeneratorCallback {
    fileprivate static var handleMap = UniFFICallbackHandleMap<ReceiptGeneratorCallback>()
}

extension FfiConverterCallbackInterfaceReceiptGeneratorCallback : FfiConverter {
    typealias SwiftType = ReceiptGeneratorCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCachedContactFFI: FfiConverterRustBuffer {
    typealias SwiftType = CachedContactFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCachedContactFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCachedContactFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentStatusInfo: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatusInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentStatusInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentStatusInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePrivateEndpointOffer: FfiConverterRustBuffer {
    typealias SwiftType = PrivateEndpointOffer?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePrivateEndpointOffer.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePrivateEndpointOffer.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeReceiptRequest: FfiConverterRustBuffer {
    typealias SwiftType = ReceiptRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeReceiptRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeReceiptRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSelectionPreferences: FfiConverterRustBuffer {
    typealias SwiftType = SelectionPreferences?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSelectionPreferences.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSelectionPreferences.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeHealthStatus: FfiConverterRustBuffer {
    typealias SwiftType = HealthStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHealthStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHealthStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCachedContactFFI: FfiConverterRustBuffer {
    typealias SwiftType = [CachedContactFfi]

    public static func write(_ value: [CachedContactFfi], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCachedContactFFI.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CachedContactFfi] {
        let len: Int32 = try readInt(&buf)
        var seq = [CachedContactFfi]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCachedContactFFI.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeHealthCheckResult: FfiConverterRustBuffer {
    typealias SwiftType = [HealthCheckResult]

    public static func write(_ value: [HealthCheckResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHealthCheckResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HealthCheckResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [HealthCheckResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHealthCheckResult.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentMethod]

    public static func write(_ value: [PaymentMethod], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentMethod.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentMethod] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentMethod]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentMethod.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePaymentStatusInfo: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentStatusInfo]

    public static func write(_ value: [PaymentStatusInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentStatusInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentStatusInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentStatusInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentStatusInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePrivateEndpointOffer: FfiConverterRustBuffer {
    typealias SwiftType = [PrivateEndpointOffer]

    public static func write(_ value: [PrivateEndpointOffer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePrivateEndpointOffer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PrivateEndpointOffer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PrivateEndpointOffer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePrivateEndpointOffer.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReceiptRequest: FfiConverterRustBuffer {
    typealias SwiftType = [ReceiptRequest]

    public static func write(_ value: [ReceiptRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReceiptRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReceiptRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReceiptRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReceiptRequest.read(from: &buf))
        }
        return seq
    }
}
/**
 * Create a new contact cache.
 */
public func createContactCache()  -> ContactCacheFfi {
    return try!  FfiConverterTypeContactCacheFFI.lift(
        try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_contact_cache($0)
}
    )
}
/**
 * Create a new async directory operations manager.
 */
public func createDirectoryOperationsAsync() throws  -> DirectoryOperationsAsync {
    return try  FfiConverterTypeDirectoryOperationsAsync.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_create_directory_operations_async($0)
}
    )
}
/**
 * Create a new interactive manager.
 */
public func createInteractiveManager(store: ReceiptStore)  -> PaykitInteractiveManagerFfi {
    return try!  FfiConverterTypePaykitInteractiveManagerFFI.lift(
        try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_interactive_manager(
        FfiConverterTypeReceiptStore.lower(store),$0)
}
    )
}
/**
 * Create a new message builder.
 */
public func createMessageBuilder()  -> PaykitMessageBuilder {
    return try!  FfiConverterTypePaykitMessageBuilder.lift(
        try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_message_builder($0)
}
    )
}
/**
 * Create a new Paykit client.
 */
public func createPaykitClient() throws  -> PaykitClient {
    return try  FfiConverterTypePaykitClient.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_create_paykit_client($0)
}
    )
}
/**
 * Create a new receipt store.
 */
public func createReceiptStore()  -> ReceiptStore {
    return try!  FfiConverterTypeReceiptStore.lift(
        try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_receipt_store($0)
}
    )
}
/**
 * Derive X25519 keypair for Noise protocol from Ed25519 seed.
 *
 * This uses the pubky-noise KDF to derive device-specific encryption keys
 * from the Ed25519 identity seed.
 *
 * # Arguments
 *
 * * `ed25519_secret_hex` - The Ed25519 secret key (seed) in hex format.
 * * `device_id` - A unique identifier for this device.
 * * `epoch` - Key rotation epoch (increment to rotate keys).
 *
 * # Returns
 *
 * The derived X25519 keypair for use with Noise protocol.
 */
public func deriveX25519Keypair(ed25519SecretHex: String, deviceId: String, epoch: UInt32) throws  -> X25519Keypair {
    return try  FfiConverterTypeX25519Keypair.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_derive_x25519_keypair(
        FfiConverterString.lower(ed25519SecretHex),
        FfiConverterString.lower(deviceId),
        FfiConverterUInt32.lower(epoch),$0)
}
    )
}
/**
 * Derive Ed25519 public key from secret key.
 *
 * # Arguments
 *
 * * `secret_key_hex` - The 32-byte secret key in hex format.
 *
 * # Returns
 *
 * The complete keypair derived from the secret.
 */
public func ed25519KeypairFromSecret(secretKeyHex: String) throws  -> Ed25519Keypair {
    return try  FfiConverterTypeEd25519Keypair.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_ed25519_keypair_from_secret(
        FfiConverterString.lower(secretKeyHex),$0)
}
    )
}
/**
 * Export keypair to encrypted backup.
 *
 * # Arguments
 *
 * * `secret_key_hex` - The secret key to backup.
 * * `password` - Password to encrypt the backup.
 *
 * # Returns
 *
 * Encrypted backup that can be stored or transferred.
 */
public func exportKeypairToBackup(secretKeyHex: String, password: String) throws  -> KeyBackup {
    return try  FfiConverterTypeKeyBackup.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_export_keypair_to_backup(
        FfiConverterString.lower(secretKeyHex),
        FfiConverterString.lower(password),$0)
}
    )
}
/**
 * Format public key as z-base32 (pkarr format).
 */
public func formatPublicKeyZ32(publicKeyHex: String) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_format_public_key_z32(
        FfiConverterString.lower(publicKeyHex),$0)
}
    )
}
/**
 * Get the unique device ID for this device.
 *
 * This should be stored persistently and reused for consistent key derivation.
 * If not available, generates a new random device ID.
 */
public func generateDeviceId()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_paykit_mobile_fn_func_generate_device_id($0)
}
    )
}
/**
 * Generate a new Ed25519 keypair for identity.
 *
 * This creates a new random identity. The secret key should be stored
 * securely and backed up.
 *
 * # Returns
 *
 * A new Ed25519 keypair with the secret in hex format.
 */
public func generateEd25519Keypair() throws  -> Ed25519Keypair {
    return try  FfiConverterTypeEd25519Keypair.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_generate_ed25519_keypair($0)
}
    )
}
/**
 * Get the library version.
 */
public func getVersion()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_paykit_mobile_fn_func_get_version($0)
}
    )
}
/**
 * Import keypair from encrypted backup.
 *
 * # Arguments
 *
 * * `backup` - The encrypted backup.
 * * `password` - Password to decrypt the backup.
 *
 * # Returns
 *
 * The decrypted keypair.
 */
public func importKeypairFromBackup(backup: KeyBackup, password: String) throws  -> Ed25519Keypair {
    return try  FfiConverterTypeEd25519Keypair.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_import_keypair_from_backup(
        FfiConverterTypeKeyBackup.lower(backup),
        FfiConverterString.lower(password),$0)
}
    )
}
/**
 * Parse z-base32 public key to hex.
 */
public func parsePublicKeyZ32(publicKeyZ32: String) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_parse_public_key_z32(
        FfiConverterString.lower(publicKeyZ32),$0)
}
    )
}
/**
 * Sign a message with Ed25519 secret key.
 *
 * # Arguments
 *
 * * `secret_key_hex` - The Ed25519 secret key in hex format.
 * * `message` - The message bytes to sign.
 *
 * # Returns
 *
 * The 64-byte signature in hex format.
 */
public func signMessage(secretKeyHex: String, message: Data) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_sign_message(
        FfiConverterString.lower(secretKeyHex),
        FfiConverterData.lower(message),$0)
}
    )
}
/**
 * Verify an Ed25519 signature.
 *
 * # Arguments
 *
 * * `public_key_hex` - The Ed25519 public key in hex format.
 * * `message` - The original message bytes.
 * * `signature_hex` - The 64-byte signature in hex format.
 *
 * # Returns
 *
 * True if the signature is valid, false otherwise.
 */
public func verifySignature(publicKeyHex: String, message: Data, signatureHex: String) throws  -> Bool {
    return try  FfiConverterBool.lift(
        try rustCallWithError(FfiConverterTypePaykitMobileError.lift) {
    uniffi_paykit_mobile_fn_func_verify_signature(
        FfiConverterString.lower(publicKeyHex),
        FfiConverterData.lower(message),
        FfiConverterString.lower(signatureHex),$0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_paykit_mobile_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_contact_cache() != 8922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_directory_operations_async() != 3774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_interactive_manager() != 6575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_message_builder() != 17772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_paykit_client() != 24343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_receipt_store() != 25695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_derive_x25519_keypair() != 35150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_ed25519_keypair_from_secret() != 9902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_export_keypair_to_backup() != 64738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_format_public_key_z32() != 60670) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_generate_device_id() != 4216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_generate_ed25519_keypair() != 1379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_get_version() != 23495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_import_keypair_from_backup() != 2045) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_parse_public_key_z32() != 18323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_sign_message() != 46705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_verify_signature() != 6178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_delete() != 59452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_get() != 6767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_is_mock() != 21711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_list() != 15374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_owner_pubkey() != 20095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_put() != 11239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_add() != 12782) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_add_with_name() != 63134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_clear() != 8267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_contains() != 10247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_count() != 63824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_get() != 19809) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_get_all() != 31771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_remove() != 23244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_sync() != 54655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_add_contact() != 46348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_known_contacts() != 14389) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_payment_endpoint() != 15229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_supported_payments() != 25737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_list_contacts() != 46871) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_publish_payment_endpoint() != 64662) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_contact() != 28065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_payment_endpoint() != 40611) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_add_contact() != 5322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_calculate_proration() != 64929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_check_health() != 61124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_payment_request() != 59726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt() != 12923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_subscription() != 32373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_days_remaining_in_period() != 4816) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_extract_key_from_qr() != 60905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_extract_method_from_qr() != 63286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_fetch_known_contacts() != 48759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_fetch_payment_endpoint() != 63867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_fetch_supported_payments() != 45518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_get_health_status() != 665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_get_in_progress_payments() != 25824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_get_payment_status() != 49692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_is_method_usable() != 34148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_is_paykit_qr() != 30125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_list_contacts() != 15384) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_list_methods() != 42624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_parse_receipt_metadata() != 40194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_parse_scanned_qr() != 50070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_publish_payment_endpoint() != 17605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_remove_contact() != 26597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_remove_payment_endpoint_from_directory() != 33360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_select_method() != 42832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_validate_endpoint() != 41220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_endpoint_offer() != 36215) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_payment_request() != 12387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_private_endpoint() != 63022) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_receipt() != 3728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_store() != 2983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_message() != 28626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_payment_response() != 41746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_private_endpoints() != 21632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_receipts() != 20652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_set_generator() != 4040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_ack() != 36644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_endpoint_offer() != 25884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_error() != 14599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_confirm() != 17132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_request() != 55941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_get_message_type() != 8687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_parse_message() != 62982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_clear() != 37348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_delete_receipt() != 18988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_export_receipts_json() != 57252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_get_private_endpoint() != 22258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_get_receipt() != 53531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_import_receipts_json() != 7694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_list_private_endpoints() != 11893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_list_receipts() != 50608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_save_private_endpoint() != 7320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_save_receipt() != 7972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_get() != 30485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_is_mock() != 10080) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_list() != 41862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_callback() != 46711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_session_json() != 8313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_new_mock() != 29404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_contactcacheffi_new() != 4021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_directoryoperationsasync_new() != 62626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_paykitclient_new() != 40010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_paykitinteractivemanagerffi_new() != 57460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_paykitmessagebuilder_new() != 30374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_receiptstore_new() != 33744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_authenticated() != 21979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_callback() != 13071) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_config_json() != 23623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_new_mock() != 13023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_put() != 59509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_get() != 7122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_delete() != 8403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_list() != 24077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_get() != 3704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_list() != 35538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptgeneratorcallback_generate_receipt() != 62383) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitPubkyAuthenticatedStorageCallback()
    uniffiCallbackInitPubkyUnauthenticatedStorageCallback()
    uniffiCallbackInitReceiptGeneratorCallback()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}